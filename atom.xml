<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>panghutx&#39;s Blog</title>
  
  
  <link href="https://youngsay.cn/atom.xml" rel="self"/>
  
  <link href="https://youngsay.cn/"/>
  <updated>2026-01-03T01:45:58.000Z</updated>
  <id>https://youngsay.cn/</id>
  
  <author>
    <name>panghutx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何将Hexo部署至服务器</title>
    <link href="https://youngsay.cn/2026/01/02/redeploy-hexo/"/>
    <id>https://youngsay.cn/2026/01/02/redeploy-hexo/</id>
    <published>2026-01-02T13:44:15.000Z</published>
    <updated>2026-01-03T01:45:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>2022年腾讯云搞活动买了五年的服务器，才300多。hexo一直部署在服务器上，比在github或vercel上要快不少。最近想用服务器部署一个项目，用到了node18，发现服务器系统还是centos7，在2024年中旬就不再维护了。服务器上除了博客和大学做的一些<s>垃圾</s>也没什么重要的东西，所以今天直接重装了系统，导致博客打不开，晚上又重新部署了下博客。</p><p>上一次部署的时候就没有留痕，这次部署也遇到些问题，所以打算写一篇博客记录一下。</p><hr><h2 id="一、-环境准备：安装核心依赖">一、 环境准备：安装核心依赖</h2><p>首先，我们需要安装 Node.js、Git、Nginx 以及用于自动化配置 HTTPS 的 Certbot。以 Ubuntu/Debian 系系统为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加 Node.js 18 运行源</span><br><span class="line">curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -</span><br><span class="line"></span><br><span class="line"># 更新并安装依赖</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y nodejs git nginx certbot python3-certbot-nginx</span><br></pre></td></tr></table></figure><blockquote><p>为什么用 Certbot？</p><p>以往配置 HTTPS 需要手动生成 CSR、上传验证文件、修改 Nginx 配置，流程极其繁琐。现在只需一行命令，Certbot 就能自动完成证书申请和 Nginx 配置，简直是运维神器。</p></blockquote><hr><h2 id="二、-配置-Nginx：让站点可访问">二、 配置 Nginx：让站点可访问</h2><p>我们需要为博客创建一个 Nginx 配置文件。</p><ol><li>创建配置文件：<code>sudo vim /etc/nginx/sites-available/yourdomain</code></li><li><strong>写入基础配置：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com www.example.com; # 替换为你的域名</span><br><span class="line"></span><br><span class="line">    root /var/www/hexo; # 博客文件存放目录</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/hexo.access.log;</span><br><span class="line">    error_log  /var/log/nginx/hexo.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>激活配置：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建软链接以激活站点</span><br><span class="line">sudo ln -s /etc/nginx/sites-available/yourdomain /etc/nginx/sites-enabled/</span><br><span class="line"></span><br><span class="line"># 测试配置并重启 Nginx</span><br><span class="line">sudo nginx -t</span><br><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure><blockquote><p><strong>小技巧：</strong> 使用 <code>sites-available</code> 和 <code>sites-enabled</code> 的模式是为了方便管理。如果你想临时下线某个站点，只需删除 <code>sites-enabled</code> 里的快捷方式（软链接）即可，源文件依然保留。</p></blockquote><h2 id="三、-开启-HTTPS：安全加固">三、 开启 HTTPS：安全加固</h2><p>在域名解析生效后，执行以下操作，Certbot 会自动修改 Nginx 配置并加入 SSL 支持：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo certbot --nginx -d example.com -d www.example.com</span><br><span class="line"></span><br><span class="line"># 测试自动续期（模拟执行）</span><br><span class="line">sudo certbot renew --dry-run</span><br></pre></td></tr></table></figure><h2 id="四、-自动化部署：Git-Hooks-方案">四、 自动化部署：Git Hooks 方案</h2><p>为了实现本地执行 <code>hexo d</code> 就能自动更新服务器文件，我们需要在服务器上配置一个 Git 仓库作为“中转站”。</p><h3 id="1-安全起见：创建专用-git-用户">1. 安全起见：创建专用 git 用户</h3><p>为了避免直接使用 root 账户带来的安全隐患，我们创建一个名为 <code>git</code> 的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m git</span><br><span class="line">sudo passwd git # 设置密码</span><br></pre></td></tr></table></figure><h3 id="2-配置-SSH-免密登录（可选但推荐）">2. 配置 SSH 免密登录（可选但推荐）</h3><p>在本地终端（如 Git Bash）生成秘钥对并将其公钥上传至服务器，后续部署无需反复输入密码。</p><ul><li><strong>本地操作</strong>：在本地计算机上打开Git Bush执行命令: <code>ssh-keygen -t rsa</code>，生成密钥对。运行完后可在<code>C:\Users\用户名.ssh</code>文件下找到<code>id_rsa</code>和<code>id_rsa.pub</code>文件，前者为私钥文件，后者为公钥文件</li><li><strong>服务器操作：</strong><br>在服务器终端先执行<code>makdir -p /home/git/.ssh</code>，后执行<code>cd /home/git/.ssh</code>以及<code>nano authorized_keys</code>，输入本地id_rsa.pub文件内容。粘入公钥内容后按：Ctrl+O （写出 write-out），回车确认文件名（默认显示 authorized_keys），然后按 Ctrl+X 退出 nano。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su - git</span><br><span class="line">makdir -p /home/git/.ssh</span><br><span class="line">cd /home/git/.ssh</span><br><span class="line">nano authorized_keys # 粘贴本地公钥</span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="3-创建-Git-裸库与钩子">3. 创建 Git 裸库与钩子</h3><p><strong>裸库（Bare Repository）</strong> 不包含工作区，仅用于存储版本历史，是实现自动部署的核心。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/git</span><br><span class="line">git init --bare blog.git</span><br><span class="line">chown -R git:git blog.git</span><br></pre></td></tr></table></figure><p>接着，编辑<strong>钩子文件（post-receive）</strong>，当有新代码 push 进来时，自动将其检出到 Web 目录：</p><ol><li><strong>新建文件：</strong> <code>nano /home/git/blog.git/hooks/post-receive</code></li><li><strong>写入以下脚本：</strong></li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># --work-tree 对应 Nginx 配置中的 root 目录</span><br><span class="line"># --git-dir 对应 Git 仓库目录</span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>赋予执行权限并调整目录所有权：</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /home/git/blog.git/hooks/post-receive</span><br><span class="line"># 确保 git 用户对 Web 目录有写入权限</span><br><span class="line">sudo chown -R git:git /var/www/hexo</span><br></pre></td></tr></table></figure><h2 id="五、-本地配置：一键发布">五、 本地配置：一键发布</h2><p>最后一步，修改本地 Hexo 根目录下的 <code>_config.yml</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@你的服务器IP:/home/git/blog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>发布流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>至此可以在浏览器中输入域名来访问博客站点了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;2022年腾讯云搞活动买了五年的服务器，才300多。hexo一直部署在服务器上，比在github或vercel上要快不少。最近想用服务器部署一个项目，用到了node18，发现服务器系统还是centos7，在2024年中旬就不再维护了。</summary>
      
    
    
    
    <category term="分享" scheme="https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="hexo" scheme="https://youngsay.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>2025年终总结</title>
    <link href="https://youngsay.cn/2025/12/14/2025/"/>
    <id>https://youngsay.cn/2025/12/14/2025/</id>
    <published>2025-12-14T08:45:15.000Z</published>
    <updated>2025-12-14T08:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>匆匆，又过了一年，今年是我的本命年，上月刚过了本命年生日，也没有特别的仪式，和往常一样，和往年一样。</p><p>这一年，是我毕业后的第二年，也是工作的第二年，与大学生活渐行渐远，上学时不觉得多么幸福，失去后才懂得珍惜，<strong>我活在幸福里，而我却不知道</strong>。当然，人也会美化过去，包括过去的痛苦。这一年，我换了家公司，继续从事测试开发的工作，算上实习的时间，已经是一名练习时长两年半的测试开发工程师了。工作两年多的时间，一定是有一些改变的，对工作技能的熟悉，balabala，不仅仅是班味更重、身体更差…上学时想找到工作，工作后不想上班，想起朋友和我说的一句话，“生活像一枚钟表，每天都是从12转到12，只要有电就这样一直走下去。”早出晚归，两点一线，我想着也是很多人不想上班的原因，不是讨厌自己的工作，而是缺少对时间的掌控，不能灵活支配自己的时间。<strong>对时间的掌控力，是影响幸福感的关键因素</strong>。此外，社交媒体是情绪放大器，打开社交媒体，有人在游山玩水，有人用心生活，怎么大家都不用上班，更加加剧了不想上班的情绪。</p><p>这一年，我整本读完的有《德米安》《小王子》 《悲喜同源》《软技能：代码之外的生存指南》《金钱心理学》，阅读的目的，一是为了消遣娱乐，一是希望能学到点什么，无论出于哪种目的，我都没做好。90%的书都没能读完，有的内容不感兴趣，有的觉得没什么新观点，比如最近看的《少有人走的路》，感觉书中讲的都是我知道的，重要的是没有亲身实践，做不到知行合一。10%的书可能读完了，但没能有效吸收，为了读而读，像是有人催促一般，迫不及待快点读完，读的过程没有过多思考，读后也没有总结整理，更没有实践。<strong>得到的是信息，而不是知识</strong>。这个时代最不缺的就是信息，每天被大量信息裹挟，“垃圾进，垃圾出”，除了浪费了时间，什么都没得到。</p><p>这一年，我的居住条件有了些改善，从次卧搬到了主卧独卫，这是今年做的比较满意的事。佛教讲“境随心转”，但我还没有那般修行，早上醒来，看到阳光打到床上，心情都会变好一些，一个较好的居住环境对我影响还挺大的。这一年，我的物欲需求趋于稳定，随着生活水平的提升，物欲需求仍像从前那样，这也是我比较欣慰的。真正了解自己的需求，而不是创造需求。明年，我要适当增加对体验的支出，<strong>相比物质消费，体验消费能带来更持久的幸福感</strong>，多年后回想起那次旅行，和朋友谈起那次晚餐，久久回甘。这一年，最爱我的姥姥走了，遗憾没能多陪陪姥姥。看到一句话感到很暖，“死亡，就是从有子女的地方，搬到了有父母的地方“，姥姥一定是想家了。转眼间我都工作了，父母年纪也越来越大了，小时候觉得无所不能的他们渐渐开始需要我拿定注意，但其实我没有做好承担责任的准备。</p><p>就写到这。我不善于规划，一天，一周，一年，就这样稍纵即逝，我有时会反思，心血来潮制定计划，但执行不了几天又和往常一样，就像现在，我写着年终总结，可能会立下几个flag，到明年年终来看，一个也没能实现。一次又一次尝试改变，一次又一次以失败告终，<strong>晚上想了千条路，早上醒来走原路</strong>。我会抱怨工作太忙，没有时间思考，没有时间改变。但一个又一个宁静的深夜，一个又一个空闲的假期，换来的不是自我反思，不是自我改变，而是逃避直面自己，用娱乐填补空虚。我知道要自律，要运动，要学习…但我做不到知行合一。在困难面前我会退缩，责任面前我会逃避，我喜欢做快乐、容易、简单的事。但可能也没那么遭，只要承认自己是个普通人。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;匆匆，又过了一年，今年是我的本命年，上月刚过了本命年生日，也没有特别的仪式，和往常一样，和往年一样。&lt;/p&gt;
&lt;p&gt;这一年，是我毕业后的第二年，也是工作的第二年，与大学生活渐行渐远，上学时不觉得多么幸福，失去后才懂得珍惜，&lt;strong&gt;我活在幸福里，而我却不知道&lt;/str</summary>
      
    
    
    
    <category term="感想" scheme="https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="年终总结" scheme="https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2023年终总结</title>
    <link href="https://youngsay.cn/2024/01/01/2023/"/>
    <id>https://youngsay.cn/2024/01/01/2023/</id>
    <published>2024-01-01T03:03:15.000Z</published>
    <updated>2025-10-10T08:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>一年又过去了，这是博客的第三个年终总结。</p><p>回看了前两年的年终总结，都是那样普通平常，而且前两年赶上了疫情，要么延期开学，要么封校，要么提前放假。与博友们的丰富多彩的生活相比，我就像白活了一样。</p><p>今年与往年有些不同，有了新的身份——实习生，活跃地点也由家和学校转移到了公司、出租屋。</p><p>1-4月，开启人生第一份实习，新鲜又陌生，期待又恐惧。</p><p>5月，担心挂科重回学校，4门必修课，大半学期没听课，最后考的还不错。所以说要活在当下，不要透支烦恼，你所想的种种麻烦大都不会发生，即便发生也都会顺利解决。</p><p>8-10月，秋招。秋招并不顺利，我想这是心态的问题，心态差，做什么都无济于事了。每天只是麻木的做着测评、笔试、面试，事后没有复盘、反思。看似很努力，其实只将一件事重复了一次又一次。</p><p>9月，大四开学，学校组织去外地实训，度过快乐、难忘的两周。一起去海边、聚餐、熬夜看鬼片，这才是大学生活。</p><p>11月，秋招不顺利，二次实习。</p><p>2024年了，虚岁24岁了，我不敢想。</p><p>还记得小学英语课上一个小插曲，老师问大家里的梦想是什么，我说想做policeman，老师听成了postman（其实postman还挺符合我的，现在听到postman，脑子里只有那个调试接口的软件），到现在还印象深刻。当时为什么说policeman，我好像没有过当警察的梦想，可能有过却被我忘了，可能是刚好想起这个单词。</p><p>上高中之后，我的目标渐渐清晰，我想做一个程序员，当时对码农概念还比较单一，只是想做出属于自己的网站，也不懂什么前端、后端，网上找到一些便宜甚至免费的虚拟主机，再找到一些现成的源码，上传上去，就能访问了。当时搭过各种博客（wordpress、emlog、typecho…）、影视网站、论坛（Flarunm、Discuz），甚至还有刷钻的网站。捣鼓这些玩意，就浪费了一天又一天的时间，一无所获却倾尽所有。</p><p>再后来才接触到前端，看到自己写的东西能展示在页面上，乐在其中。上了大学，又接触到了后端。从只会写一些简单的页面，到前后端交互，能写一些逻辑，不知道当时自己有多快乐。</p><p>到了大三、大四，有了就业的压力，好像已经忘了最初的目标。不再沉浸在编程的快乐，而是苦于八股文、算法、找工作…想想初学编程的时候，只是单纯喜欢，没有想过什么钱多钱少，什么大厂小厂，一个小功能实现了，我都能乐一天了。现在呢，想要更好的工作，想要更高的工资，永远不知足。</p><p>与过去的自己相比，我已经成长了。从搬源码，到写一些简单的静态页面，到能够前后端交互，虽然这些并不难，但对比以前的自己，已经进步了。从想做一个码农，到成为了一个码农，我的目标已经实现了。<strong>如果我是当初的我，我一定会非常高兴。即使我是现在的我，也没理由不高兴，对吗？</strong></p><p>2024，保持热爱，找寻自我。不再羡慕他人的精彩，为自己的成长喝彩。人生，才刚刚开始。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一年又过去了，这是博客的第三个年终总结。&lt;/p&gt;
&lt;p&gt;回看了前两年的年终总结，都是那样普通平常，而且前两年赶上了疫情，要么延期开学，要么封校，要么提前放假。与博友们的丰富多彩的生活相比，我就像白活了一样。&lt;/p&gt;
&lt;p&gt;今年与往年有些不同，有了新的身份——实习生，活跃地点</summary>
      
    
    
    
    <category term="感想" scheme="https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="年终总结" scheme="https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://youngsay.cn/2023/01/21/2022/"/>
    <id>https://youngsay.cn/2023/01/21/2022/</id>
    <published>2023-01-21T07:15:15.000Z</published>
    <updated>2025-10-10T08:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得真快啊，今天就是大年三十了，一年又这样过去了。</p><p>没什么可写的，但又想写点什么，毕竟好久没写记录自己的日常了，连”个站商店“也把我网站删除了。与其说是年终总结，不如说是流水账。</p><blockquote><p>《个站商店》给你发了单独的邮件，</p><p>hi 胖虎同学 ：</p><p>很抱歉，你的网站《胖虎同学》未能通过『个站商店』的审核，主要原因是内容非原创，多是技术类或者转载类，这类网站一般比较少人看。等你整改后，欢迎再来哦！</p><p>———— 祝生活愉快！ 邮件来自《个站商店》 2023-01-18 12:51:59</p></blockquote><p>今年也和往年一样，疫情，开学，放假……</p><p>2月28日，开学，开学没几天，疫情严重，在校上网课。5月25日，请假离校，提前过上暑假生活……</p><p>9月5号开始返校，已经是大三的老家伙了，因家里疫情被延期返校，13日回校。开学没几天，疫情严重，在校上网课。11月26日，请假离校，提前过上寒假生活……</p><p>除了开学放假外，今年有两件事可以说说。一件好事，一件坏事。</p><p>一件好事就是找到了实习。12月，我开始准备找实习的事，很幸运在12月30日拿到了实习offer。</p><p>1月5号，去公司报到，开始实习生活。1月21也就是今天，回家过年。这月只工作了11天，而这一周人都走的差不多了，基本上就是摸鱼，所以只工作了5天。</p><p>在这段时间里，感觉挺快乐，是我之前没有体会到的新生活。但也遇到些问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间过得真快啊，今天就是大年三十了，一年又这样过去了。&lt;/p&gt;
&lt;p&gt;没什么可写的，但又想写点什么，毕竟好久没写记录自己的日常了，连”个站商店“也把我网站删除了。与其说是年终总结，不如说是流水账。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《个站商店》给你发了单独的邮件，&lt;/</summary>
      
    
    
    
    <category term="感想" scheme="https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="年终总结" scheme="https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库：事务</title>
    <link href="https://youngsay.cn/2022/11/29/MySQL-transaction/"/>
    <id>https://youngsay.cn/2022/11/29/MySQL-transaction/</id>
    <published>2022-11-29T05:04:41.000Z</published>
    <updated>2022-11-29T05:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务的概念">事务的概念</h3><p><strong>事务</strong>是逻辑上的一组操作，能够将各SQL语句打包执行，<strong>要么全都执行，要么全都不执行</strong>。</p><p>想象我们在操作数据库时，数据库突然挂了，或者多个线程写入数据库时覆盖了彼此的更改……一系列操作都会导致数据库数据的不一致性，基于这些问题，数据库有了事务这一机制。</p><p>拿转账举例，A想要向B转账500元，该操作分为两步：</p><ul><li>A的账户减少500元</li><li>B的账户增加500元</li></ul><p>事务会将这两步打包在一起执行，要么全都执行，要么全都不执行。不会出现A的账户少了500，而B账户没有增加500的情况。</p><h3 id="如何使用事务">如何使用事务</h3><p>①开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br></pre></td></tr></table></figure><p>②执行多条SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A账户减少500</span></span><br><span class="line"><span class="keyword">update</span> accout <span class="keyword">set</span> money<span class="operator">=</span>money<span class="number">-500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">-- B账户增加500</span></span><br><span class="line"><span class="keyword">update</span> accout <span class="keyword">set</span> money<span class="operator">=</span>money<span class="operator">+</span><span class="number">500</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure><p>③回滚或提交：rollback/commit;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>说明：rollback即是全部失败，commit即是全部成功。</p><h3 id="事务的特性">事务的特性</h3><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有四大特性：</p><p>原子性</p><p><strong>原子性</strong>：事务为执行的最小单元，不可再划分，要么全都执行，要么全都不执行。</p><p><strong>一致性</strong>：事务执行前后的数据要保持一致，结果不能出现异常。拿转账举例，转账前后两个账户的总额是不变的。</p><p><strong>持久性</strong>：事务带来的影响是持久的，不会因为数据库故障而产生任何影响。</p><p><strong>隔离性</strong>：并发访问数据库时，各事务之间的数据库是独立的，一个用户的事务不会被其他事务所干扰。</p><p>只有保证事务的原子性、持久性和隔离性，才能保证事务的一致性，所以说原子性、持久性和隔离性是事务的手段，一致性是目的。</p><h3 id="并发事务带来的问题">并发事务带来的问题</h3><p><strong>脏读</strong>：一个事务正在访问数据库并对数据进行修改，而该修改并未提交到数据库，另一个进行此时访问数据库读取数据。而这里访问的数据只是一个中间的数据，不一定是最终的结果，这里读到的数据就是一个“脏数据”，基于“脏数据”做出的操作可能是错误的。</p><p><strong>不可重复读</strong>：在一个事务内多次读取同一数据。在多次读取数据之间，另一个事务访问并修改了该数据，那么再次读取该数据时，发现与之前读取到的数据不一样。在一个事务内两次读取到的数据不一样，称为不可重复读。</p><p><strong>幻读</strong>:一个事务(T1)读取了几行数据，此时另一个事务(T2)插入了一些数据。事务T1再次读取该数据发现多了一些原本不存在的数据，这就是幻读。幻读是不可重复读的特殊情况，不可重复读强调的是数据的更改，幻读强调的是数据的增加。</p><h3 id="事务隔离级别">事务隔离级别</h3><p>SQL标准定义了四个隔离级别，隔离级别越高，并行化就越低。</p><ul><li>read-uncommitted：读取未提交。最低的隔离级别。允许读取未提交的数据，可能导致脏读、不可重复读、幻读。</li><li>read-committed：读取已提交。不能读取未提交的数据，即事务在修改数据时另一个事务不能执行读操作。可以防止脏读，不能避免不可重复读、幻读。</li><li>repeatable-read：可重复读。事务在读取数据时，其他事务不能修改正在读取的数据。因此对同一数据的多次修改结果都是一致的，可以防止脏读、不可重复读，不能避免幻读。</li><li>serializable：串行化。最高的隔离级别。各事务串行执行，相互之间不存在干扰，可以防止脏读、不可重复读和幻读。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务的概念&quot;&gt;事务的概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事务&lt;/strong&gt;是逻辑上的一组操作，能够将各SQL语句打包执行，&lt;strong&gt;要么全都执行，要么全都不执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;想象我们在操作数据库时，数据库突然挂了，或者多个线程写入</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MySQL" scheme="https://youngsay.cn/tags/MySQL/"/>
    
    <category term="事务" scheme="https://youngsay.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库：索引</title>
    <link href="https://youngsay.cn/2022/11/28/MySQL-index/"/>
    <id>https://youngsay.cn/2022/11/28/MySQL-index/</id>
    <published>2022-11-28T13:04:41.000Z</published>
    <updated>2022-11-28T13:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。</p><h3 id="索引的优缺点">索引的优缺点</h3><p>优点：</p><ul><li>提高了查找的效率</li><li>通过创建唯一性索引，确保了每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>索引使用物理文件存储，带来了空间的消耗。</li><li>创建和维护索引需要耗费时间。当数据发生更改时，索引也会动态修改，降低SQL执行效率。</li></ul><h3 id="索引SQL">索引SQL</h3><h4 id="查看索引">查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> 索引名 <span class="keyword">from</span> 表名(列名);</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118307.png" alt="image-20221128161811672"></p><h4 id="创建索引">创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名);</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118347.png" alt="image-20221128162120786"></p><h4 id="删除索引">删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202211282118794.png" alt="image-20221128162440340"></p><h3 id="索引底层的数据结构">索引底层的数据结构</h3><p>索引是一种查找更快的数据结果。</p><p>数组和链表的查找都需要遍历，最先淘汰。</p><p>二叉搜索树最坏情况下会变成单支树，查找的时间复杂度变为O(N)，淘汰。</p><p>AVL树和红黑树使得左右子树高度相对平衡，但数据量太大时，树的高度过高，比较次数过多，即磁盘IO过多，淘汰。</p><p>哈希表查找的时间复杂度是O(1)，是不是可以作为索引的数据结构了呢？NO！哈希表不支持顺序和范围查找，而SQL要经常进行排序和</p><p>范围查询，淘汰。</p><p><strong>目前大多数数据库采用B树或B+树作为索引结构</strong>，在MySQL中，MyISAM 引擎和 InnoDB 引擎都是使用 B+树 作为索引结构。</p><p>B树称为多路平衡查找树，B+树是在B树基础上的变现，二者都是多叉平衡树。</p><h4 id="B树">B树</h4><p><img src="https://cos.youngsay.cn/blog/202211282118366.png" alt="image-20221128203706890"></p><h4 id="B-树">B+树</h4><p><img src="https://cos.youngsay.cn/blog/202211282118609.png" alt="image-20221128203611266"></p><h4 id="区别和联系">区别和联系</h4><ul><li><p>B树N个值，划分为N+1个结点；B+树N个值，划分为N个结点。</p></li><li><p>B树叶子结点相互独立;B+树叶子结点是链式结构，指向相邻结点。</p></li><li><p>B树每个结点既存放key，又存放data；B+树只有叶子结点既存放key，又存放data，其他结点只存key。</p></li><li><p>B树的查找过程是对每个关键字二分查找，可能没有到叶子结点就检索到了；B+树更加稳定，每次查找都是从根节点开始，到叶子结点结束。</p></li></ul><h4 id="索引为什么要用B-树">索引为什么要用B+树</h4><ul><li>每次都是从根节点到叶子结点，IO次数都差不多，查询效率稳定。</li><li>磁盘IO请求数少，查询速度快。</li><li>叶子结点采用链式存储结构，方便数据范围查询。</li><li>非叶子结点只存储key，占用空间小，甚至可以缓存到内存中。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。&lt;/p&gt;
&lt;h3 id=&quot;索引的优缺点&quot;&gt;索引的优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高了查找的效率&lt;/li&gt;
&lt;li&gt;通过创建唯一性索引，确保了每一行数据</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="索引" scheme="https://youngsay.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="MySQL" scheme="https://youngsay.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>socket套接字网络编程</title>
    <link href="https://youngsay.cn/2022/11/22/Java-Socket/"/>
    <id>https://youngsay.cn/2022/11/22/Java-Socket/</id>
    <published>2022-11-22T06:14:41.000Z</published>
    <updated>2022-11-22T06:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。</p><p>socket主要分为三类：流套接字、数据报套接字、原始套接字。我们这里主要介绍前两种：</p><p><strong>流套接字</strong>：使用传输层TCP协议，提供面向连接、可靠的数据传输，面向字节流，有接收缓冲区和发送缓冲区，传输数据大小无限制。</p><p><strong>数据报套接字</strong>：使用传输层UDP协议，提供无连接、不可靠传输，面向数据报，只有接收缓冲区，传输大小受限，一次最多传输64K。</p><p>下面我们来看下Java中是如何使用socket来进行网络编程的。</p><h3 id="数据报套接字">数据报套接字</h3><p>Java数据报套接字编程有两个核心的类，<code>DatagramSocket</code>和<code>DatagramPacket</code>。</p><h4 id="两个核心类">两个核心类</h4><p><code>DatagramSocket</code>用于创建一个数据报套接字，用于发送和接收数据报。主要的构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>创建一个UDP数据报套接字的Socket，绑定到本机任意一个随机端口 （一般用于客户端）</td></tr><tr><td>DatagramSocket(int port)</td><td>创建一个UDP数据报套接字的Socket，绑定到本机指定的端口（一般用 于服务端）</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void receive(DatagramPacket p)</td><td>从此套接字接收数据报（如果没有接收到数据报，会阻塞等待）</td></tr><tr><td>void send(DatagramPacket p)</td><td>从此套接字发送数据报包（不会阻塞等待，直接发送）</td></tr><tr><td>void close()</td><td>关闭此数据报套接字</td></tr></tbody></table><p>方法内的参数类型，就是我们要介绍的另一个核心类：<code>DatagramPacket</code>，该类表示数据报包，用于进程间的发送和接收。主要构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>构造一个数据报包，<strong>用来接收</strong>，接收的数据保存在字节数组buf中，接收指定长度length</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</td><td>构造一个数据报包，<strong>用来发送</strong>，发送的数据为字节数组buf，从offset到长度length，指明目标主机地址address，即IP和端口号</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getAddress()</td><td>获取该数据报发送或接收数据报的计算机的IP地址。</td></tr><tr><td>getSocketAddress()</td><td>获取该数据包发送到或正在从其发送的远程主机的SocketAddress（通常为IP地址+端口号）。</td></tr><tr><td>int getPort()</td><td>获取该数据报发送或接收数据报的端口号</td></tr><tr><td>byte[] getData()</td><td>获取数据报中的数据</td></tr><tr><td>int getLength()</td><td>返回要发送的数据的长度或接收到的数据的长度。</td></tr></tbody></table><h4 id="服务器端">服务器端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UdpServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">        <span class="comment">//创建一个服务器端的数据报套接字，通常指明端口</span></span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;服务器已连接&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//1.接收请求</span></span><br><span class="line">                <span class="comment">//创建数据报包，用来接收客户端发来的请求</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">reqPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//接收数据报，没有数据传来时会阻塞等待</span></span><br><span class="line">                socket.receive(reqPacket);</span><br><span class="line">                <span class="comment">//★从接收的数据报中解析数据，构造成请求字符串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(reqPacket.getData(),<span class="number">0</span>,reqPacket.getLength(),<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">                <span class="comment">//2.构造响应</span></span><br><span class="line">                <span class="comment">//这里没有做处理，发来什么就返回什么。</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> process(req);</span><br><span class="line">                <span class="comment">//创建数据报包，用来发送响应</span></span><br><span class="line">                <span class="comment">//将响应字符串转换成字节数组，指明目的主机地址</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">respPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(resp.getBytes(),resp.getBytes().length,reqPacket.getSocketAddress());</span><br><span class="line">                <span class="comment">//3.发送响应</span></span><br><span class="line">                socket.send(respPacket);</span><br><span class="line">                <span class="comment">//4.打印日志</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>,</span><br><span class="line">                        reqPacket.getAddress().toString(), reqPacket.getPort(), req, resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造响应</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">process</span><span class="params">(String req)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">        <span class="type">UdpServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UdpServer</span>(<span class="number">9090</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中★处要尤为注意：</p><p>构造请求字符串的第三个参数：请求字符串长度，是接收到的数据报的长度，reqPacket.getLength()。一定不要写成reqPacket.getData().length()，这个是字节数组的长度，该代码为1024。</p><h4 id="客户端">客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> port; <span class="comment">//服务器端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ip; <span class="comment">//服务器ip地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UdpClient</span><span class="params">(String ip,<span class="type">int</span> port)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">        <span class="comment">//创建一个客户端的数据报套接字，通常不指明端口</span></span><br><span class="line">        <span class="built_in">this</span>.socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="built_in">this</span>.ip = ip;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="comment">//0.输入请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;请输入请求：&quot;</span>);</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="comment">//1.构造请求</span></span><br><span class="line">                <span class="comment">//创建一个数据报包，用来发送请求★</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">reqPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(req.getBytes(),req.getBytes().length,InetAddress.getByName(ip),port);</span><br><span class="line">                <span class="comment">//2.发送请求</span></span><br><span class="line">                socket.send(reqPacket);</span><br><span class="line">                <span class="comment">//创建接收数据包，用来接收服务器发来的响应</span></span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">respPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//3.接收响应</span></span><br><span class="line">                socket.receive(respPacket);</span><br><span class="line">                <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(respPacket.getData(),<span class="number">0</span>,respPacket.getLength());</span><br><span class="line">                System.out.println(<span class="string">&quot;resp：&quot;</span>+resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException &#123;</span><br><span class="line">        <span class="comment">//参数内为服务器的ip和端口号</span></span><br><span class="line">        <span class="type">UdpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UdpClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中★处：</p><p>构造发送数据包时要传入目的主机的地址，InetAddress.getByName(ip),port分别为主机的ip地址和端口号，除了这样，还可以通过创建socketAddress类来指定主机地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(ip,port);</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">reqPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(req.getBytes(),req.getBytes().length,socketAddress);</span><br></pre></td></tr></table></figure><h3 id="流套接字">流套接字</h3><p>Java流套接字编程也有两个核心的类，<code>ServerSocket</code>和<code>Socket</code>。</p><h4 id="两个核心类-2">两个核心类</h4><p>ServerSockert通常用于创建一个服务器端的流套接字，常用构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建一个服务端流套接字Socket，并绑定到指定端口</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>监听要连接此客户端的套接字，有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待</td></tr><tr><td>void close()</td><td>关闭此套接字</td></tr></tbody></table><p>Socket通常用于常见一个客户端的流套接字，常用构造方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接</td></tr></tbody></table><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InetAddress getInetAddress()</td><td>返回套接字所连接的地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr></tbody></table><h4 id="服务器端-2">服务器端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServer</span> &#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TcpServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一个服务器套接字，指定服务器端口号</span></span><br><span class="line">        server = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//监听客户端并建立连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            processConnection(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConnection</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%s,%d]客户端建立连接\n&quot;</span>,client.getInetAddress(),client.getPort());</span><br><span class="line">        <span class="comment">//创建输入输出流，输入流用来接收客户端传来的数据，输出流用来将数据发给客户端</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> client.getInputStream())&#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream())&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(inputStream);</span><br><span class="line">                    <span class="keyword">if</span>(!scanner.hasNext())&#123;</span><br><span class="line">                        System.out.printf(<span class="string">&quot;[%s,%d]客户端断开连接&quot;</span>,client.getInetAddress(),client.getPort());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//1.接收请求</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                    <span class="comment">//2.构造响应</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> process(req);</span><br><span class="line">                    <span class="comment">//3.返回响应</span></span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line">                    <span class="comment">//★调用println方法，不能是print和write</span></span><br><span class="line">                    printWriter.println(resp);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;req:%s,resp:%s\n&quot;</span>,req,resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//★关闭连接</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">process</span><span class="params">(String req)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">TcpServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpServer</span>(<span class="number">9090</span>);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>★处要尤为注意：</p><ol><li><p>调用的是println方法，不是print也不是write。println方法会为写入的数据后面添加上换行符，而print和write不会。客户端接收数据时是以换行符为结束来获取数据。如果找不到换行符，将一直不能接收响应，造成阻塞。同理，客户端发送请求时也要使用println方法，否则服务器也会接收不到请求而一直阻塞。</p></li><li><p>大家可能会想，为什么这里的client要关闭连接，而server和之前的数据报套接字都不需要关闭连接。关闭连接的前提是不再使用了，对于UDP和ServerSocket，它们是贯穿程序始终的，而这里的client，也就是Socket，每个连接都有一个Socket，断开连接也就不再需要这个Socket了，需要进行释放。</p></li></ol><h4 id="客户端-2">客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TcpClient</span><span class="params">(String ip,<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.ip = ip;</span><br><span class="line">        <span class="comment">//★创建客户端套接字，并将其连接到指定IP地址的指定端口号。</span></span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">Socket</span>(ip,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> client.getInputStream()) &#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> client.getOutputStream())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//1.构造请求</span></span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    <span class="comment">//2.发送请求</span></span><br><span class="line">                    <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(outputStream);</span><br><span class="line">                    <span class="comment">//★调用println方法，不能是print和write</span></span><br><span class="line">                    printWriter.println(req);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    <span class="comment">//3.接收响应</span></span><br><span class="line">                    <span class="type">Scanner</span> <span class="variable">respScan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(inputStream);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">resp</span> <span class="operator">=</span> respScan.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;resp:&quot;</span>+resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">TcpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9090</span>);</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题">问题</h4><p>流套接字的客户端服务器通信还存在一个问题，只能满足一个客户端的通信。其他客户端尝试与服务器连接时，会发生阻塞。观察服务器代码中下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//监听客户端并建立连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        processConnection(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端1与服务器建立连接后，服务器线程执行processConnection代码中的操作，代码中存在while循环，不断地接收客户端1发来的请求，构造响应，返回响应……此时客户端2想要与服务器通信，而服务器线程正在processConnection的while循环中等待客户端1的请求，导致服务器不能与客户端2建立连接。</p><p>TCP每次都需要建立连接，只能支持一对一，也就是端到端的通信。就像打电话一样，同一时间只能接听一个电话，当正在通话时，别的电话是打不进来的。而UDP是无连接的，因此支持一对一、一对多、多对多交互通信。所以我们在数据报套接字时没有出现该问题。</p><p>解决办法也很简单，因为processConnection中的循环未结束导致服务器不能执行accept操作，所以单独创建一个新的线程来完成processConnection操作即可。我们可以用多线程或线程池来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//建立连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                processConnection(client);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他代码不变，只需改动start方法内的代码，为processConnection操作创建新的线程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。&lt;/p&gt;
&lt;p&gt;socket主要分为三类：</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="socket" scheme="https://youngsay.cn/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Java文件和IO流</title>
    <link href="https://youngsay.cn/2022/11/17/Java-IO/"/>
    <id>https://youngsay.cn/2022/11/17/Java-IO/</id>
    <published>2022-11-17T12:14:41.000Z</published>
    <updated>2022-11-17T12:21:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件基础操作">文件基础操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建一个hello的目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dir.exists())&#123;</span><br><span class="line">        dir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在hello目录下创建一个hello.txt文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir+<span class="string">&quot;/hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到文件名</span></span><br><span class="line">    System.out.println(file.getName());</span><br><span class="line">    <span class="comment">//得到文件的绝对路径</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    <span class="comment">//得到文件的规范路径，当路径不规范时，会进行优化(去掉.)</span></span><br><span class="line">    System.out.println(file.getCanonicalPath());</span><br><span class="line">    <span class="comment">//得到父目录名</span></span><br><span class="line">    System.out.println(file.getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体详见：<a href="https://docs.oracle.com/javase/8/docs/api/">File (Java Platform SE 8 ) (oracle.com)</a></p><h3 id="IO流">IO流</h3><p>IO即输入和输出（Input、Output），输入就是将数据读入到内存，输出就是将数据输出到外部存储（如文件、数据库）。数据的输入输出就像水流一样，因此成为IO流。</p><p>IO流的处理方式可分为两种：字节流和字符流。Java中针对IO流的处理有很多类，但最基本的只有4个抽象类。<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code>，前两个是对字节流的输入输出，后两个是对字符流的输入输出。下面我们拿普通文件的读写举例，介绍它们的基本操作。</p><h4 id="字节流">字节流</h4><h5 id="InputStream">InputStream</h5><p>用于对文件进行读操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数。</p><p>常用方法：</p><p><code>read()</code> ：一次读取一字节，返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。返回 <code>-1</code> ，表示读到文件的末尾，读取结束。</p><p><code>read(byte b[ ])</code> : 一次读取多个字节，将输入流字节存储到数组b，返回结果为读取字节长度。返回-1，表示读到文件的末尾，读取结束。</p><p><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>close()</code> ：关闭输入流释放相关的系统资源。</p><ul><li>一次读取一字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readOne</span><span class="params">(File file,FileInputStream fileInputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileInputStream.read();</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次读取多个字节</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readByte</span><span class="params">(File file,FileInputStream inputStream)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> inputStream.read(bytes);</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; read; i++) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)bytes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="OutputStream">OutputStream</h5><p>用于对文件进行写操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数，同时可以指定第二个参数表示是否追加写入(是否清空之前的内容)，true表示追加写入，默认为false。</p><p>在写操作时数据暂时放在缓存区，只有缓存区满后才会真正写入到设备，所以别忘了调用<code>fulsh()</code>，防止数据没有写入设备。</p><p>常用方法：</p><p><code>write(int b)</code> ：将特定字节写入输出流。</p><p><code>write(byte b[ ])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</p><p><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</p><p><code>close()</code> ：关闭输出流释放相关的系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeOne</span><span class="params">(File file, FileOutputStream outputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">        outputStream.write(<span class="number">103</span>);</span><br><span class="line">        outputStream.write(<span class="number">104</span>);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符流">字符流</h4><p>字节是电脑中存储信息的基本单位，那为什么还需要字符流呢？</p><p>当存储信息中有中文时，以字节流来读取会出现乱码。字节流更适用于音频、图片等类型文件，当文件中涉及字符类型时，使用字符流更好。字符流默认编码是<code>unicode</code>。</p><p>常见的字符编码：<code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p><h5 id="Reader">Reader</h5><p>常用方法：</p><p><code>read()</code> : 从输入流读取一个字符。</p><p><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</p><p><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>close()</code> : 关闭输入流并释放相关的系统资源。</p><ul><li>一次读取一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readOne</span><span class="params">(File file,Reader reader)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> reader.read();</span><br><span class="line">            <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print((<span class="type">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次读取多个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readCharacter</span><span class="params">(File file,Reader reader)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> reader.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (read==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,read);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Writer">Writer</h5><p>常用方法：</p><p><code>write(int c)</code> : 写入单个字符。</p><p><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</p><p><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</p><p><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</p><p><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p><p><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</p><p><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</p><p><code>close()</code>:关闭输出流释放相关的系统资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeOne</span><span class="params">(File file,Writer writer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">        writer.write(<span class="string">&quot;我是panghutx&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;文件基础操作&quot;&gt;文件基础操作&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="IO" scheme="https://youngsay.cn/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：线程池</title>
    <link href="https://youngsay.cn/2022/11/14/Java-ThreadPool/"/>
    <id>https://youngsay.cn/2022/11/14/Java-ThreadPool/</id>
    <published>2022-11-14T09:04:41.000Z</published>
    <updated>2022-11-14T10:43:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？</p><p>相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不用销毁，再放进线程池。</p><p>标准库中的线程池（简化版本)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    pool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟实现一个简化版本的线程池：</p><ol><li>描述任务：直接用Runnable接口即可</li><li>组织任务：用到阻塞队列</li><li>描述工作线程：创建Worker类继承Thread，重写run方法，从阻塞队列中取任务，然后执行任务</li><li>组织工作线程：实例化工作线程，加入到线程池，启动线程</li><li>提交任务：往线程池中添加任务（具体是将任务添加到阻塞队列）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreatPool</span> &#123;</span><br><span class="line">    <span class="comment">//描述一个任务</span></span><br><span class="line">    <span class="comment">//组织一个任务</span></span><br><span class="line">    BlockingDeque&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//描述一个线程</span></span><br><span class="line">    <span class="comment">//线程是用来执行任务的，而任务都存放在队列中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="comment">//通过构造方法能够拿到外面的queue</span></span><br><span class="line">        <span class="keyword">private</span> BlockingDeque&lt;Runnable&gt; queue = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(BlockingDeque&lt;Runnable&gt; queue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//从queue中取任务，然后执行任务</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组织线程,创建线程</span></span><br><span class="line">    List&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreatPool</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//创建线程，存放到线程池,执行线程</span></span><br><span class="line">            <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(queue);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交任务到线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sumbit</span><span class="params">(Runnable runnable)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        queue.put(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreatPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreatPool</span>(<span class="number">10</span>);<span class="comment">//线程数10</span></span><br><span class="line">        <span class="comment">//执行1000个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">workId</span> <span class="operator">=</span> i;</span><br><span class="line">            pool.sumbit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务:&quot;</span>+workId+Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？&lt;/p&gt;
&lt;p&gt;相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：定时器</title>
    <link href="https://youngsay.cn/2022/11/14/Java-Timer/"/>
    <id>https://youngsay.cn/2022/11/14/Java-Timer/</id>
    <published>2022-11-14T07:04:41.000Z</published>
    <updated>2022-11-14T07:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。</p><p>下面我们来看一下Java标准库中的定时器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该定时器会在3秒之后输出“hello”。创建一个定时器需要用到Timer类中的核心方法schedule，该方法内有两个参数，一个表示要执行的任务，一个表示任务在多长时间后执行。</p><p>认识了标准库中的定时器后，我们可以自己来模拟实现一个定时器。</p><p>首先，描述一个任务。创建一个MyTask类，类中有两个属性：一个是执行的任务，一个是任务执行时间。这两个属性类似于标准库schedule方法内的两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;MyTask&gt;&#123;</span><br><span class="line">    <span class="comment">//具体要干啥</span></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">    <span class="comment">//啥时候开始干</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(Runnable runnable,<span class="type">long</span> dalay)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">        <span class="built_in">this</span>.time=System.currentTimeMillis()+dalay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(MyTask o)</span> &#123;</span><br><span class="line">        <span class="comment">//时间小的排在前面</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.time-o.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，组织一个任务类。如何组织任务类呢，我们这里用到<strong>优先级阻塞队列</strong>。每个任务的执行时间（指的是在多长时间后执行）不同，根据时间大小来排序，进而优先执行队头任务，因此需要优先级队列。</p><p>最后，我们还需要一个线程不断的去扫描到了时间的任务，然后执行这个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimer</span>&#123;</span><br><span class="line">    <span class="comment">//组织一个任务</span></span><br><span class="line">    <span class="keyword">private</span> PriorityBlockingQueue&lt;MyTask&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(Runnable runnable,<span class="type">long</span> delay)</span>&#123;</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(runnable,delay);</span><br><span class="line">        queue.put(myTask);</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行到时间的任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTimer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//取队首元素</span></span><br><span class="line">                    <span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                    <span class="type">long</span> time=System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span>(time&lt;task.getTime())&#123;</span><br><span class="line">                        <span class="comment">//时间还没到</span></span><br><span class="line">                        queue.put(task);</span><br><span class="line">                        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">                            locker.wait(task.getTime()-time);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//到时间了，执行这个任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟一个定时器，总共分三步。第一步，<s>把冰箱打开</s>描述一个任务，即要执行的任务和任务多长时间后开始执行。第二步，组织一个任务，这里用到了优先级阻塞队列。第三步，利用一个线程扫描任务，执行到时间的任务。</p><p>下面有两个问题需要注意。</p><ol><li>任务类要放进优先级阻塞队列中，优先级阻塞队列根据时间先后进行排序。因此我们的任务类要实现<code>Comparable&lt;MyTask&gt;</code>接口，然后重写比较规则。</li><li>线程扫描任务，会从队头取元素，判断是否到时间了，如果没到，再放回队列。接着继续取元素……如果不加限制，它一直不停的扫描队首元素, 看看是否能执行这个任务，这样会大量消耗CPU。因此我们利用wait来使这个线程等待，时间到后再唤醒。此外当新加入一个任务后我们也需要用notify来唤醒扫描线程，因为可能该任务的时间更小，优先级更高，所以需要重新扫描任务队列。（这也就决定了必须用wait，而不能用sleep，因为sleep不能中途唤醒）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。&lt;/p&gt;
&lt;p&gt;下面我们来看一下Java标准库中的定时器。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程实例：阻塞队列</title>
    <link href="https://youngsay.cn/2022/11/14/Java-BlockingQueue/"/>
    <id>https://youngsay.cn/2022/11/14/Java-BlockingQueue/</id>
    <published>2022-11-14T04:04:41.000Z</published>
    <updated>2022-11-14T04:21:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。</p><p>阻塞队列的一个典型应用常见就是“生产者消费者”模型。毫无疑问，该模型有两个主体：生产者和消费者。生产者线程负责生产产品，将生产好的产品放进阻塞队列。消费者线程负责消费产品，直接从阻塞队列取产品。</p><p>生产者消费者模型具有解耦、平衡速度差异的特点。</p><p>解耦：生产者无需关注是谁在消费产品，消费了多少产品，只需关注生产操作即可；消费者无需关注是谁在生产产品，生产了多少产品，只需关注消费操作即可。</p><p>平衡速度差异：设想11.11，大量用户向服务器发送了大量的支付请求，一次性将这些请求交给服务器处理，服务器可能会hole不住，因此将这些请求都放进阻塞队列，消费者线程从阻塞队列一个一个地来处理请求就好了。这样就起到了“削峰填谷”的作用，平衡了生产者和消费者之间的速度差异。</p><h3 id="标准库中的阻塞队列：">标准库中的阻塞队列：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    BlockingDeque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line">    queue.put(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> queue.take();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BlockingQueue 是一个接口. 真正实现的类是 LinkedBlockingQueue.</li><li>put 方法用于阻塞式的入队列, take 用于阻塞式的出队列.</li><li>BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性</li></ul><h3 id="模拟实现阻塞队列：">模拟实现阻塞队列：</h3><ul><li>循环队列+阻塞等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] elem = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> val)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            <span class="comment">//队列满了，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span>(size==elem.length)&#123;</span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一轮循环，让尾指针指向数组下标为0的位置</span></span><br><span class="line">            <span class="keyword">if</span>(tail==elem.length)&#123;</span><br><span class="line">                tail=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            elem[tail++]=val;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">//唤醒消费者线程的堵塞等待</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker)&#123;</span><br><span class="line">            <span class="comment">//队列空了，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head==elem.length)&#123;</span><br><span class="line">                head=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> elem[head];</span><br><span class="line">            head++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//唤醒生产者线程的堵塞等待</span></span><br><span class="line">            locker.notify();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">        <span class="comment">//生产者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产了：&quot;</span>+i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">take</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费了：&quot;</span>+take);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。&lt;/p&gt;
&lt;p&gt;阻塞队列的一个典型应用常见就是“生产者消费者”模型</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java线程的创建及状态</title>
    <link href="https://youngsay.cn/2022/10/12/Java-Thread/"/>
    <id>https://youngsay.cn/2022/10/12/Java-Thread/</id>
    <published>2022-10-12T13:04:41.000Z</published>
    <updated>2022-11-14T10:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程">什么是线程</h2><p>在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页在播放音乐，一个网页在播放视频，一个网页在浏览博客。每个网页有不同的分工，这些浏览器的每个子任务就是一个线程。</p><p>线程是更轻量的进程，创建一个线程的消耗要低于创建一个进程，且同一进程的不同线程之间可以共享资源，效率更高。通过多线程可以更好地实现并发编程。</p><p><strong>进程vs线程</strong></p><ul><li>进程包含线程，进程是线程的一部分，一个进程中至少包含一个线程。</li><li>进程与进程之间不能共享资源，同一个进程的线程之间可以共享资源。</li><li>进程是系统分配资源的最小单位，线程是系统调度执行的最小单位。</li><li>多进程稳定性高于多线程，一个进程的崩溃不会影响其他线程；多线程下一个线程的崩溃可能影响该进程。</li></ul><h2 id="创建线程">创建线程</h2><p>一个线程至少包含一个进程，<code>main()</code>就是一个线程，我们还可以在里面创建多个线程。</p><p><strong>1.继承<code>Thread</code>类,重写<code>run()</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.创建<code>Thread</code>实例，实现<code>Runnable</code>接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start new thread!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.其他变形</strong></p><ul><li>匿名内部类创建Thread子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Thread 子类对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>匿名内部类创建Runnable子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Runnable 子类对象&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>lambda表达式创建Thread子类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;使用匿名类创建 Thread 子类对象&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Thread方法"><code>Thread</code>方法</h2><p><strong>常见构造方法</strong></p><table><thead><tr><th>构造方法</th></tr></thead><tbody><tr><td><code>Thread()</code>  分配一个新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target)</code>  分配一个新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target, String name)</code>  分配一个新的 <code>Thread</code>对象，name为新线程的名字。</td></tr><tr><td><code>Thread(String name)</code>  分配一个新的 <code>Thread</code>对象，name为新线程的名字。</td></tr></tbody></table><p><strong>启动一个线程.start()</strong></p><p>Thread对象对创建后，并没有启动线程，执行该指令后才会真正创建一个线程。即内核中创建了一个内存控制块PCB。</p><p><strong>中断一个线程</strong></p><p>方法1：自定义变量作为标志位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义变量flag作为标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程正在运行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">//使线程进入休眠状态</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：<code>interrupted()</code>方法中断线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程运行中&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Thread.currentThread().isInterrupted()</code>获取当前线程是否被中断；<code>interrupted()</code>向线程发出中断请求。</p><p>Thread收到通知方式有两种：①当线程因wait/sleep/join等方法处于堵塞状态时，以 <code>InterruptedException </code>异常的形式通知。②<code>isInterrupted()</code>标志位置为true.</p><p><strong>等待一个线程.join()</strong></p><p>执行该指令，会使该线程执行结束后再执行下一线程，即将并发编程变成了串行。比如用某软件下载一部电影，可以边下载边观看，当执行该指令后，就要等下载完后再看了~</p><p><strong>休眠一个线程sleep()</strong></p><p>让线程进入休眠状态，进入休眠状态的指令，他的属性<code>isAlive()</code>为Timed Waiting。线程状态会稍后介绍到。</p><h2 id="线程状态">线程状态</h2><p>注意，这里我们说的是java线程的六种状态。利用<code>isAlive</code>属性可以观察线程的状态，线程有以下6种状态：</p><ul><li>New：新创建的线程，但未执行<code>start()</code>，线程没有存活；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中，如执行<code>wait()</code>方法；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程结束，线程没有存活。</li></ul><h2 id="线程状态转换">线程状态转换</h2><p>线程被创建出来，处于New状态。调用start方法后，处于Runnable状态。当线程获取不到锁时，处于Blocked状态，直到获取到锁后进入Runnable状态。运行的线程调用wait或join方法后会进入Waiting状态，直到唤醒通知后进入Runnable状态。调用带有超时参数的方法后会进入Timed Waiting状态，直到时间到后进入Runnable状态。运行的线程执行完run方法或出现异常后进入Terminated状态。</p><p>与操作系统中的进程状态不同，java没有就绪态。操作系统中，一个进程调用start后并没有直接运行，而是进入就绪态，当获取到cpu时间片后进入运行态。我们可以认为在java中，就绪态和运行态同属于Runnable。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是线程&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全及解决方案</title>
    <link href="https://youngsay.cn/2022/09/26/Thread-safe/"/>
    <id>https://youngsay.cn/2022/09/26/Thread-safe/</id>
    <published>2022-09-26T09:40:41.000Z</published>
    <updated>2022-11-14T04:22:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？</p><h3 id="造成线程不安全的原因">造成线程不安全的原因</h3><ol><li><p>线程的调度</p><p>各线程之间是抢占式执行的，线程的执行顺序是随机的，因此可能会产生各种问题。现在最流行什么？做核酸！如果做核酸是抢占式的，做核酸没有一个顺序，做核酸顺序完全靠运气，这能安全吗！</p></li><li><p>多线程同时修改同一变量</p><p>如果是多线程同时读取同一变量，不涉及修改的操作，是线程安全的。但如果多线程同时修改同一变量，这能不乱吗？想当年家里买了一台电脑，我姐姐要用电脑玩QQ炫舞，我要用电脑玩穿越火线，你争我抢，打的是不可开交。</p></li><li><p>操作指令不是原子的</p><p>例如一条加法指令，其实要执行三条指令，load、add、save，先将内存中的变量加载到寄存器，在寄存器中完成加法操作，再将结果写会内存中。假设线程1完成了load、add操作，线程2完成了load、add、save操作，当线程1再去执行save操作，便将线程2的操作覆盖了，线程2说：线程1真是一个猪队友。</p></li><li><p>内存可见性</p><p>线程1循环进行读操作，线程2看心情进行修改操作。我们知道，读操作是将内存变量加载到寄存器，然后读取寄存器。而线程1循环加载内存中的值到寄存器，线程2又迟迟不修改，线程1说：你当我傻吗？于是线程1干脆去读取寄存器了，这就是编译器的优化。拿做核酸举例，最初是刮嗓子，但日复一日，现在有些已经是刮舌头了，这难道是疫情的优化？大部分情况下是安全的，但也可能会翻车。线程1循环读操作，线程2突然心情不好，很快啊，修改了内存中的值。而线程1却绕过了内存，从寄存器读值，这能安全吗！</p></li></ol><h3 id="解决方案">解决方案</h3><p>针对原因1，线程的调度就是抢占式执行的，我们无能为力。针对原因2，我们可以通过调整代码结构，使不同线程操作不同变量，但我这菜鸡技术，既然能写出一个bug，就能写出无数个bug，一顿调整猛如虎，结果bug乘以5.</p><p>所以我们解决方案寄托在原因3、4上。</p><p>Java中提供了<code>synchronized</code>关键字来对操作上锁。拿上面的加法操作举例，为加法这一方法加上synchronized后，就为该操作上锁了。想象要在卫生间完成加法操作，（不敢想象），小县城来的孩子线程1来执行加法操作，发现卫生间没人，他进来后把门锁上，进行加法操作。又一个小县城的孩子线程2来到卫生间前，也想要做加法操作，发现门锁了，只好等到线程1出来后才能进去，他是等也得等，不等也得等，这样就保证了操作的原子性。</p><p>Java还提供了<code>volatile</code>关键字来解决内存可见性问题，synchronized也可以解决该问题，只不过开销更大。为代码加上volatile后，就能禁止编译器进行优化，线程1无论做多少次循环读操作，都要耐心地从内存中读值，不能直接去读取寄存器中的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？&lt;/p&gt;
&lt;h3 id=&quot;造成线程不安全的原因&quot;&gt;造成线程不安全的原因&lt;/h3&gt;
&lt;ol&gt;
&lt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java单例模式：懒汉模式和饿汉模式</title>
    <link href="https://youngsay.cn/2022/09/21/Java-Singleton/"/>
    <id>https://youngsay.cn/2022/09/21/Java-Singleton/</id>
    <published>2022-09-21T13:04:41.000Z</published>
    <updated>2022-11-14T04:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。</p><p>饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。</p><h3 id="饿汉模式">饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.使用static创建一个实例，并且立即实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//2.为了防止在其他地方不小心new这个Singleton，把方法构造为private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供一个方法，让外面能够拿到唯一实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程中，多个线程对同一数据进行读操作，线程安全。</p><h3 id="懒汉模式">懒汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程中，多个线程对同一对象进行读、写操作，线程不安全。线程不安全出现在首次创建实例时，多个线程同时调用getInstance方法，可能创造出多个实例。</p><p>改进1：</p><p>对getInstance方法加锁，保证操作的原子性，实现线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法性能较差，毕竟线程不安全只出现在首次创建实例时，为getInstance方法加锁后每次都要加锁解锁，所以做如下改进。</p><p>改进2：</p><p>进入getInstance方法后首先判断instance是否为空，即是否为第一次创建实例，是才需要加锁，否则不需要加锁。同时为了避免 “内存可见性” 导致读取的 instance 出现偏差, 因此为instance加上volatile。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.不立即初始化实例，使用时再初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//2.将构造方法设为private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//3.提供方法获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。&lt;/p&gt;
&lt;p&gt;饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。&lt;/p&gt;
&lt;h3 id=&quot;饿汉模式&quot;&gt;饿汉模式&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="多线程" scheme="https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】Thymeleaf模板引擎</title>
    <link href="https://youngsay.cn/2022/06/09/Java-Thymeleaf/"/>
    <id>https://youngsay.cn/2022/06/09/Java-Thymeleaf/</id>
    <published>2022-06-09T11:40:41.000Z</published>
    <updated>2022-10-20T11:58:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。</p><p>下面我们简单了解一下Thymeleaf的语法。</p><h4 id="Thymeleaf常见命令">Thymeleaf常见命令</h4><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>th:text</td><td>在标签体中展示表达式求值结果的文本内容</td></tr><tr><td>th:[HTML标签属性]</td><td>设置任意的 HTML 标签属性的值</td></tr><tr><td>th:if</td><td>当表达式的结果为真时则显示内容，否则不显示</td></tr><tr><td>th:each</td><td>循环访问元素</td></tr></tbody></table><p>Thymeleaf语法有很多，我们这里先简单介绍这四个。th:text和th:if在猜数字小游戏案例已经使用过，这里不再介绍。</p><h5 id="th-属性">th:[属性]</h5><ul><li>HTML模板代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url1&#125;&quot;</span>&gt;</span>胖虎同学<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;$&#123;url2&#125;&quot;</span>&gt;</span>胖虎同学1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/thymeleafUrl.html&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThymeleafUrlServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">//1.创建核心类,用于完成页面渲染</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TemplateEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">    <span class="comment">//2.初始化模板引擎,创建解析器，加载文件，关联</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(context);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.实例化WebContext，关联变量</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req,resp,context);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;url1&quot;</span>,<span class="string">&quot;https://youngsay.cn&quot;</span>);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;url2&quot;</span>,<span class="string">&quot;http://blog.youngsay.cn&quot;</span>);</span><br><span class="line">        <span class="comment">//4.渲染</span></span><br><span class="line">        engine.process(<span class="string">&quot;thymeleafUrl&quot;</span>,webContext,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="th-each">th:each</h5><p>列举游戏战绩：昵称、击杀、死亡、得分</p><ul><li>HTML模板代码：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:each</span>=<span class="string">&quot;person : $&#123;persons&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.kill&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.score&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> kill;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> dead;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> kill, <span class="type">int</span> dead, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.kill = kill;</span><br><span class="line">        <span class="built_in">this</span>.dead = dead;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKill</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/thymeleafEach&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThymeleafEach</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">//创建TemplateEngine对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TemplateEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">    <span class="comment">//初始化模板引擎</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(context);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;損友比过狗友i&quot;</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">80</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马棚管理员&quot;</span>,<span class="number">21</span>,<span class="number">8</span>,<span class="number">130</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;吃枣药丸&quot;</span>,<span class="number">16</span>,<span class="number">5</span>,<span class="number">110</span>));</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req,resp,context);</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;persons&quot;</span>,persons);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        engine.process(<span class="string">&quot;thymeleafEach&quot;</span>,webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletContext">ServletContext</h4><p>观察上篇博客猜数字游戏代码和上面的两段代码，我们发现，每个Servlet都创建了一个TemplateEngine对象并进行初始化，其实这完全没必要，一个webapp中，只创建一个TemplateEngine对象即可。</p><p>这就需要用到ServletContext，它是Servlet程序全局存储信息的空间，每个webapp中只有一个ServlectContext，多个Servlet之间共享一个ServlectContext。通过 HttpServlet.getServletContext() 方法获取到当前webapp 的ServletContext对象。</p><p>下面是ServletContext常见方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void setAttribute(String name, Object obj)</td><td>设置属性(键值对)</td></tr><tr><td>Object getAttribute(String name)</td><td>根据属性名获取属性值, 如果 name 不存在, 返 回 null</td></tr><tr><td>void removeAttribute(String name)</td><td>删除对应的属性</td></tr></tbody></table><p>我们用代码来证明多个一个webapp中多个Servlet类共用一个ServletContext。</p><ul><li>创建一个WriterServlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/writer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取message参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">//2.将message设置到ServletContext</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;message&quot;</span>,message);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//3.返回结果</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;设置成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个ReaderServlet类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/reader&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.读取ServletContext中的message值</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> (String) context.getAttribute(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//2.返回读到的值</span></span><br><span class="line">        resp.getWriter().write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cos.youngsay.cn/blog/202206101502724.gif" alt="展示结果"></p><h4 id="监听器">监听器</h4><p>要想做到一个webapp中只创建一个TemplateEngine对象，除了认识ServletContext，还需要了解监听器。</p><p>使用监听器监听ServletContext的创建，创建好后在ServletContext完成初始化操作，后续的 Servlet 直接从 ServletContext 中获取到engine实例即可，不必每创建一个Servlet都初始化一次。</p><p>首先创建一个监听器类Mylistener，实现ServletContextListener接口，重写contextInitialized方法。在contextInitialized方法内完成初始化等一系列操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//1.通过方法的参数可以获取到ServletContext</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        <span class="comment">//2.创建TemplateEngine类对象engine</span></span><br><span class="line">        <span class="type">TemplateEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">        <span class="comment">//3.创建解析器</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(context);</span><br><span class="line">        <span class="comment">//4.加载文件</span></span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//5.关联engine和解析器</span></span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        <span class="comment">//6.将engine放到ServletContext中,后续直接调用getAttribute获取engine</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;engine&quot;</span>,engine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了MyListener类，之前代码中engine对象的创建和init方法内的初始化操作都可以删掉了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。&lt;/p&gt;
&lt;p&gt;下面我们简单了解一下Thymeleaf的语法。&lt;/p&gt;
&lt;h4 id=&quot;Thymeleaf常见命令&quot;&gt;Thymeleaf常见命令&lt;/h4&gt;
&lt;table&gt;
&lt;thea</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】服务器渲染</title>
    <link href="https://youngsay.cn/2022/06/09/Java-templateEngine/"/>
    <id>https://youngsay.cn/2022/06/09/Java-templateEngine/</id>
    <published>2022-06-09T08:40:41.000Z</published>
    <updated>2022-06-09T08:44:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。<strong>服务器渲染</strong>是将用户传来的数据在服务器端拼接成HTML后传给客户端，而<strong>客户端渲染</strong>是在客户端将服务器传来的数据拼接成HTML。</p><p><img src="https://cos.youngsay.cn/blog/202206091642034.png" alt="页面渲染"></p><h4 id="服务器渲染">服务器渲染</h4><p>这篇博客主要介绍一下服务器渲染。</p><p>我们可以用字符串拼接的方式，将数据拼接成HTML页面。下面我们用字符串拼接的方式完成一个猜数字web版的小游戏。</p><p>首先约定好交互方式。</p><ul><li>GET /guess</li></ul><p>通过get请求，从服务器得到一个页面响应，同时在服务器生成一个1-100的随机数。</p><ul><li>POST /guess</li></ul><p>通过post请求，将用户输入的数提交到服务器，在服务器比较用户输入的数和随机数的大小，将比较结果和次数返回。</p><p>约定好交互方式后，我们创建一个GuessNumServlet类，关联到/guess路径，用doGet方法实现第一个交互接口，doPost方法实现第二个交互接口。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/guess&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuessNumServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//生成一个随机数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="comment">//随机数范围在[1,100]</span></span><br><span class="line">        num = random.nextInt(<span class="number">100</span>)+<span class="number">1</span>; <span class="comment">//得到一个1-100之间的随机数</span></span><br><span class="line">        <span class="comment">//设置响应的类型格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//字符串拼接响应页面</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">html</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        html.append(<span class="string">&quot;&lt;form action=\&quot;guess\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;text\&quot; name=\&quot;guessNum\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;submit\&quot; value=\&quot;确认输入\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/form&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回响应</span></span><br><span class="line">        resp.getWriter().write(html.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置响应格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//得到用户猜的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">guessNum</span> <span class="operator">=</span> Integer.parseInt(req.getParameter(<span class="string">&quot;guessNum&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//比较用户输入的数字和生成的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(guessNum&lt;num)&#123;</span><br><span class="line">            result=<span class="string">&quot;猜小了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(guessNum&gt;num)&#123;</span><br><span class="line">            result=<span class="string">&quot;猜大了&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result=<span class="string">&quot;猜对了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//字符串拼接响应界面</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">html</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        html.append(<span class="string">&quot;&lt;form action=\&quot;guess\&quot; method=\&quot;post\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;text\&quot; name=\&quot;guessNum\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;        &lt;input type=\&quot;submit\&quot; value=\&quot;确认输入\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    &lt;/form&gt;&quot;</span>);</span><br><span class="line">        html.append(<span class="string">&quot;&lt;div&gt;&quot;</span>+result+<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        html.append(<span class="string">&quot;&lt;div&gt;&quot;</span>+<span class="string">&quot;猜的次数：&quot;</span>+count+<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回响应界面</span></span><br><span class="line">        resp.getWriter().write(html.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上段代码，我们发现十分简单的页面拼接起来却如此复杂，代码可读性不高。其实我们有一种更好的方式来完成服务器渲染，那就是<strong>模板引擎</strong>。</p><h4 id="模板引擎">模板引擎</h4><p>上面的代码Java和HTML代码都混在了一起，模板引擎可以将JAVA和HTML代码分离，将HTML放到单独的文件。HTML中需要变动的部分用占位符占位，当服务器计算响应完毕后，将HTML模板中的占位符替换成计算后的内容，返回给客户端。</p><p>Java中有很多模板引擎，这里用的是Thymeleaf 。</p><p>如何使用Thymeleaf，我们上面的猜数字小游戏为例，将上段代码改成模板引擎版本。</p><p><strong>首先需要引入依赖。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.thymeleaf/thymeleaf --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.0</span><span class="number">.12</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>接着创建一个HTML模板</strong>，创建路径是<code>webapps/WEB-INF/templates  </code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;GuessNum&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;guessNum&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;确认输入&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;div th:<span class="keyword">if</span>=<span class="string">&quot;$&#123;!first&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;div th:text=<span class="string">&quot;$&#123;result&#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div th:text=<span class="string">&quot;$&#123;count&#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>有$符号的地方就是一个占位符，最终会被替换成计算好的结果。</p><p><strong>最后创建Servlet类</strong>：<code>GuessNumTemplateEngine</code>。</p><ul><li>创建一个TemplateEngine的类，这个类是服务器渲染的核心类。</li><li>初始化模板引擎：创建一个ServletContextTemplateResolver类的解析器，结合ServletContext使用，用来加载要渲染的文件，然后与TemplateEngine相关联。</li><li>通过WebContext类将模板文件的变量与Java中的变量相关联。</li><li>通过TemplateEngine的process方法完成渲染。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/GuessNum&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuessNumTemplateEngine</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">//核心，用于完成页面的渲染</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TemplateEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> randomNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//对模板引擎初始化</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(<span class="built_in">this</span>.getServletContext());</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        resolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        engine.setTemplateResolver(resolver);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        randomNum = random.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req,resp,getServletContext());</span><br><span class="line">        webContext.setVariable(<span class="string">&quot;first&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        engine.process(<span class="string">&quot;guessNum&quot;</span>,webContext,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//1.获取用户输入的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(req.getParameter(<span class="string">&quot;guessNum&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 2. 和 随机数 进行比较</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; randomNum) &#123;</span><br><span class="line">            result = <span class="string">&quot;猜低了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; randomNum) &#123;</span><br><span class="line">            result = <span class="string">&quot;猜高了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="string">&quot;猜对了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 自增猜的次数</span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//4.返回响应界面</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req,resp,getServletContext());</span><br><span class="line">        context.setVariable(<span class="string">&quot;first&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;result&quot;</span>,result);</span><br><span class="line">        context.setVariable(<span class="string">&quot;count&quot;</span>,count);</span><br><span class="line">        engine.process(<span class="string">&quot;guessNum&quot;</span>,context,resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。&lt;strong&gt;服务器渲染&lt;/strong&gt;是将用户传来的数据在服务器端拼接成HTML后传给客户端，而&lt;strong&gt;客户端渲染&lt;/st</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>【JavaWeb】Servlet上传文件</title>
    <link href="https://youngsay.cn/2022/06/08/Java-uploadFile/"/>
    <id>https://youngsay.cn/2022/06/08/Java-uploadFile/</id>
    <published>2022-06-08T13:40:41.000Z</published>
    <updated>2022-06-08T13:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet支持上传文件操作，在HttpServletRequest类中，通过Part对象的getPart方法便可以获取请求中指定name的文件。</p><p>上传文件分为两个部分，前端部分和后端部分，关于文件操作，这两个部分都很简单，代码量很少。</p><p>各文件路径如下：</p><p><img src="https://cos.youngsay.cn/blog/202206082140961.png" alt="maven各文件路径"></p><p><strong>前端页面</strong>：创建一个html文件，通过form表单的action属性，与后端Servlet相关联，method属性指定方法，上传文件通常为post，通过enctype属性指定编码方式，上传文件为multipart/form-data。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;file&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>后端部分</strong>：创建一个上传文件的类Upload，继承HttpServlet，@WebServlet()注解内容与前端页面form表单的action路径相同(此处有<code>/</code>)，此外还需要<code>@MultipartConfig</code>注解,缺少该注解将无法正确读取文件。 通过Part对象的getPart()方法获取文件，方法内参数为前端界面input中类型为file格式的name属性值。通过write方法可以将文件写入磁盘，方法内参数为磁盘路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Upload</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">Part</span> <span class="variable">part</span> <span class="operator">=</span> req.getPart(<span class="string">&quot;myFile&quot;</span>);</span><br><span class="line">        System.out.println(part.getContentType());</span><br><span class="line">        System.out.println(part.getName());</span><br><span class="line">        System.out.println(part.getSize());</span><br><span class="line">        part.write(<span class="string">&quot;d:/myFile.png&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Servlet支持上传文件操作，在HttpServletRequest类中，通过Part对象的getPart方法便可以获取请求中指定name的文件。&lt;/p&gt;
&lt;p&gt;上传文件分为两个部分，前端部分和后端部分，关于文件操作，这两个部分都很简单，代码量很少。&lt;/p&gt;
&lt;p&gt;各文件</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaWeb" scheme="https://youngsay.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度和空间复杂度</title>
    <link href="https://youngsay.cn/2022/06/04/algorithm-complexity/"/>
    <id>https://youngsay.cn/2022/06/04/algorithm-complexity/</id>
    <published>2022-06-04T13:40:41.000Z</published>
    <updated>2022-06-04T14:22:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何衡量一个算法的好坏？我们可以从时间和空间两个方面入手，也就是时间复杂度和空间复杂度。</p><p>无论是时间复杂度还是空间复杂度，都采用<strong>大O的渐进表示法</strong>。只保留最高阶项，且最高阶项的系数为1.例如一个算法的执行次数是2N^2+M+3,那么该算法的时间复杂度是O（N^2)。</p><h3 id="时间复杂度">时间复杂度</h3><p>时间复杂度的衡量标准也就是算法的执行次数。我们下面用几段代码来练习一下算法时间复杂度的计算。</p><ul><li>冒泡排序的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> array.length; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; end; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (array[i - <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">Swap(array, i - <span class="number">1</span>, i);</span><br><span class="line">sorted = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sorted == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设有N个元素，最坏的情况下需要走N-1趟，每趟排序end-1次。例如有5个元素，N-5，那么需要走4趟，每趟排列次数分别为4,3,2,1。刚好构成等差数列，可以用等差数列求和公式计算执行次数,也就是<code>[(N*（N-1))]/2</code>。</p><p>按照大O的渐进表示法，时间复杂度是O（N^2)。</p><ul><li>二分查找的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> begin + ((end-begin) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (array[mid] &lt; value)</span><br><span class="line">    begin = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &gt; value)</span><br><span class="line">    end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二份查找的好处是每次能去掉一半，第一次是去掉一半还剩一半，第二次去掉一半还剩1/4，第三次去掉一半还剩1/8……如下图所示：</p><p><img src="https://cos.youngsay.cn/blog/202206042220754.png" alt="image-20220604213754161"></p><p>所以二分查找的时间复杂度是O（logN）</p><ul><li>递归求阶乘的时间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> N &lt; <span class="number">2</span> ? N : factorial(N-<span class="number">1</span>) * N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归算法的时间复杂度 = 递归的次数 * 每次递归执行的次数</p><p>递归求阶乘算法递归次数为N，每次递归执行1次，所以时间复杂度是O（N）。</p><ul><li>递归求斐波那契数列</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> N &lt; <span class="number">2</span> ? N : fibonacci(N-<span class="number">1</span>)+fibonacci(N-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归次数，也就是层数为N的二叉树最多的结点个数，(2^N) - 1。</p><p>所以时间复杂度是O（2^N)。</p><h3 id="空间复杂度">空间复杂度</h3><p>空间复杂度的衡量标准是临时占用的存储空间大小。随着计算机的发展，存储空间越来越大，空间复杂度也就不必太过关注。</p><ul><li>递归求阶乘的空间复杂度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> N &lt; <span class="number">2</span> ? N : factorial(N-<span class="number">1</span>)*N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归了N次，开辟了N个栈帧，每个栈帧占用常数的存储空间，所以该算法的空间复杂度是O（N）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何衡量一个算法的好坏？我们可以从时间和空间两个方面入手，也就是时间复杂度和空间复杂度。&lt;/p&gt;
&lt;p&gt;无论是时间复杂度还是空间复杂度，都采用&lt;strong&gt;大O的渐进表示法&lt;/strong&gt;。只保留最高阶项，且最高阶项的系数为1.例如一个算法的执行次数是2N^2+M+3,</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构和算法" scheme="https://youngsay.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】认识String类</title>
    <link href="https://youngsay.cn/2022/06/03/Java-String/"/>
    <id>https://youngsay.cn/2022/06/03/Java-String/</id>
    <published>2022-06-03T03:40:41.000Z</published>
    <updated>2022-06-08T13:43:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建一个Sting">创建一个Sting</h3><p>String有三种构造方法，分别为直接赋值、new String方法构造和字符串数组构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="type">char</span>[] arr=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">String str3=<span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br></pre></td></tr></table></figure><p>String是一种引用类型，内部并不存储字符串本身。</p><h3 id="Sting的存储结构">Sting的存储结构</h3><p>观察下段代码，输出结果是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str11=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str22=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str3=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">System.out.println(str1==str11); <span class="comment">//true</span></span><br><span class="line">System.out.println(str2==str22); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>输出结果分别为true、false。</p><p>之所以出现这样的结果，是字符串的存储方式不同。字符串str1和str11这样的创建方式是将数据存放在字符串常量池，在常量池中，同一个数只有一份。字符串常量池在JVM中是StringTable类，实际是一个固定大小的HashTable。str2和str22是将数据存放在堆上，每new一次就会在堆上开辟一块空间。</p><p>下面这幅图是String内部存储结构的简单示意图。</p><p><img src="https://cos.youngsay.cn/blog/202206031208205.png" alt="Sting内部存储结构"></p><p>总结：String类中两种对象实例化的区别：</p><ul><li>直接赋值：只会开辟一块堆内存空间，并且该字符串对象可以自动保存在对象池中以供下次使用。</li><li>构造方法：会开辟两块堆内存空间，不会自动保存在对象池中，<strong>可以使用intern()方法手工入池</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>).intern();</span><br></pre></td></tr></table></figure><h3 id="Sting的不可变性">Sting的不可变性</h3><p>字符串Sting是不可变的，所以每次字符串“+”加号拼接时都会产生一个新的对象，并不是在原对象的基础上拼接。</p><p>JDK中，String类由final修饰，value字符数组也由final修饰。</p><ul><li>String类被final修饰，表明该类不能被继承。</li><li>value被修饰被final修饰，只是表明不能再引用其他数组，但是引用空间中的值仍能被修改。</li></ul><p>所以，final并不是String对象不可变的原因。</p><p>如何理解 String 类型值的不可变？</p><p><a href="https://www.zhihu.com/question/20618891/answer/114125846">https://www.zhihu.com/question/20618891/answer/114125846</a></p><p>String对象不可变，使用加号进行字符串拼接效率是很低的，每次都会创建一个新对象，中间还会有很多临时变量。可以使用StringBuffer和StingBuilder来进行字符串的修改。</p><h3 id="StringBuffer和StringBuilder"><code>StringBuffer</code>和<code>StringBuilder</code></h3><p>String、StringBuffer、StringBuilder的区别:</p><ul><li>String的内容不可修改，StringBuffer与StringBuilder的内容可以修改.</li><li>StringBuffer与StringBuilder大部分功能是相似的。StringBuffer采用同步处理，属于线程安全操作；而StringBuilder未采用同步处理，属于线程不安全操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line">String str=<span class="string">&quot;panghu&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> str + <span class="string">&quot;tx&quot;</span>;</span><br><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;panghu&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;tx&quot;</span>);</span><br><span class="line"><span class="comment">//转化</span></span><br><span class="line"><span class="comment">//String----&gt;StringBuffer</span></span><br><span class="line">StringBuffer sb1=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">System.out.println(sb1.append(str));</span><br><span class="line"><span class="comment">//StringBuffer---&gt;String</span></span><br><span class="line">String ss= sb.toString();</span><br><span class="line">System.out.println(ss);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;创建一个Sting&quot;&gt;创建一个Sting&lt;/h3&gt;
&lt;p&gt;String有三种构造方法，分别为直接赋值、new String方法构造和字符串数组构造。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaSE" scheme="https://youngsay.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】抽象类和接口</title>
    <link href="https://youngsay.cn/2022/05/24/Java-abstractClass-interface/"/>
    <id>https://youngsay.cn/2022/05/24/Java-abstractClass-interface/</id>
    <published>2022-05-24T09:40:41.000Z</published>
    <updated>2022-06-08T13:43:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类">抽象类</h3><h4 id="什么是抽象类">什么是抽象类</h4><p>被abstract修饰的类就是抽象类。抽象类是类的进一步抽象，抽象类中的方法可以不做具体的实现（抽象方法，由abstract修饰）。抽象类中也可以有普通方法。</p><p>抽象方法不能由static和final修饰，因为抽象方法要被子类重写。</p><p>抽象类中不一定要有抽象方法，但是有抽象方法的类一定是抽象类。</p><p>抽象类不能实例化，但可以引用其子类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//抽象类中也可以有构造方法，也可以有普通方法、属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法，不做具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;正在吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//抽象类不能实例化，但可以引用其子类对象。</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">        <span class="comment">//子类重写eat方法</span></span><br><span class="line">        animal.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：旺旺正在吃狗粮</p><h4 id="为什么需要抽象类">为什么需要抽象类</h4><p>抽象类中的方法可以不做具体实现，为了子类能够继承该抽象类。使用抽象类能够多一层编译器校验，增加了安全性。就像常量用final修饰，不小心修改时编译器会报错提醒。</p><p>像上面的代码main方法中new Dog改成new Animal，编译器就会报错：‘Animal’ is abstract; cannot be instantiated。</p><h3 id="接口">接口</h3><h4 id="什么是接口">什么是接口</h4><p>接口是多个类的公共规范，是一种引用数据类型。接口可以理解为一种功能、特性，类实现某个接口，便可以具备某种功能。</p><p>接口中的方法默认是由public abstract修饰，接口中的属性默认是public final static。建议接口中的方法和属性不加任何修饰符号, 保持代码的简洁性.</p><p>接口不能实例化。</p><p>接口中不能有静态代码块和构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Running</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">//方法不加修饰符，默认为public abstract void run()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flying</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//抽象类中也可以有构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法，不做具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Running</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;正在吃狗粮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现接口中的run方法，必须为public，因为接口中的run方法是public，重写时要分配更高的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;正在扑向他的主人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Flying</span>&#123;</span><br><span class="line">    <span class="comment">//继承父类，需要重写父类的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写父类的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;正在觅食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口，必须实现接口的抽象方法，否则类需设置为抽象类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;正在天空中自由地翱翔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺旺&quot;</span>);</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.run();</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;飞儿&quot;</span>);</span><br><span class="line">        bird.eat();</span><br><span class="line">        bird.fly();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>旺旺正在吃狗粮<br>旺旺正在扑向他的主人<br>飞儿正在觅食<br>飞儿正在天空中自由地翱翔</p><h4 id="为什么需要接口">为什么需要接口</h4><p>Java不允许多重继承，通过接口可以提供多重继承的大部分好处，同时还能避免多重继承的复杂性和低效性。</p><h4 id="接口的使用实例">接口的使用实例</h4><h5 id="Comparable接口">Comparable接口</h5><p>对数组元素按年龄排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写compareTo方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        if(this.age&gt;o.age)&#123;</span></span><br><span class="line"><span class="comment">//            return 1;</span></span><br><span class="line"><span class="comment">//        &#125;else if(this.age&lt;o.age)&#123;</span></span><br><span class="line"><span class="comment">//            return -1;</span></span><br><span class="line"><span class="comment">//        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age-o.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;panghu&quot;</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaofu&quot;</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;daxiong&quot;</span>,<span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jingxiang&quot;</span>,<span class="number">16</span>)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(students);</span><br><span class="line">        System.out.println(Arrays.toString(students));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>[Student{name=‘jingxiang’, age=16}, Student{name=‘xiaofu’, age=18}, Student{name=‘daxiong’, age=19}, Student{name=‘panghu’, age=20}]</p><p>上面代码有一个问题，只能按年龄排序，如果想按姓名排序就要修改compareTo方法，修改后又只能按姓名排序。有没有一种办法，可以实现按不同的属性进行排序。利用比较器可以实现该要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student1</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student1&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student1 o1, Student1 o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student1&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student1 o1, Student1 o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compare1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student1[] students = <span class="keyword">new</span> <span class="title class_">Student1</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student1</span>(<span class="string">&quot;panghu&quot;</span>,<span class="number">20</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student1</span>(<span class="string">&quot;xiaofu&quot;</span>,<span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student1</span>(<span class="string">&quot;daxiong&quot;</span>,<span class="number">19</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student1</span>(<span class="string">&quot;jingxiang&quot;</span>,<span class="number">16</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">AgeComparator</span> <span class="variable">ageComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AgeComparator</span>();</span><br><span class="line">        <span class="type">NameComparator</span> <span class="variable">nameComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">        <span class="comment">//按年龄排序</span></span><br><span class="line">        Arrays.sort(students,ageComparator);</span><br><span class="line">        System.out.println(<span class="string">&quot;按年龄&quot;</span>+Arrays.toString(students));</span><br><span class="line">        <span class="comment">//按姓名排序</span></span><br><span class="line">        Arrays.sort(students,nameComparator);</span><br><span class="line">        System.out.println(<span class="string">&quot;按姓名&quot;</span>+Arrays.toString(students));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>按年龄[Student{name=‘jingxiang’, age=16}, Student{name=‘xiaofu’, age=18}, Student{name=‘daxiong’, age=19}, Student{name=‘panghu’, age=20}]<br>按姓名[Student{name=‘daxiong’, age=19}, Student{name=‘jingxiang’, age=16}, Student{name=‘panghu’, age=20}, Student{name=‘xiaofu’, age=18}]</p><h5 id="Clonable接口">Clonable接口</h5><p>实现Clonable接口需要重写Object类的clone()方法，在方法中使用super关键字调用Object类的clone()方法，然后调用该方法即可实现克隆。</p><ul><li>浅拷贝：仅仅拷贝当前对象本身，不拷贝引用类型。<br><img src="https://cos.youngsay.cn/blog/202206030851091.png" alt="浅拷贝"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String phone;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, p.phone=&quot;</span> + p.phone +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age=<span class="number">20</span>;</span><br><span class="line">        person.p.phone=<span class="string">&quot;xiaomi&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person)person.clone();</span><br><span class="line">        person2.age=<span class="number">10</span>;</span><br><span class="line">        person2.p.phone=<span class="string">&quot;iphone&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Person&#123;age=20, p.phone=iphone&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;age=10, p.phone=iphone&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>深拷贝：不仅拷贝当前对象，还拷贝其引用类型。</p><p><img src="https://cos.youngsay.cn/blog/202206030852161.png" alt="深拷贝"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">tmp</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        tmp.p= (Phone) <span class="built_in">this</span>.p.clone();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, p.phone=&quot;</span> + p.phone +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.age=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        person.p.phone=<span class="string">&quot;xiaomi&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person)person.clone();</span><br><span class="line">        person2.age=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        person2.p.phone=<span class="string">&quot;iphone&quot;</span>;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Person&#123;age=20, p.phone=xiaomi&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;age=10, p.phone=iphone&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;抽象类&quot;&gt;抽象类&lt;/h3&gt;
&lt;h4 id=&quot;什么是抽象类&quot;&gt;什么是抽象类&lt;/h4&gt;
&lt;p&gt;被abstract修饰的类就是抽象类。抽象类是类的进一步抽象，抽象类中的方法可以不做具体的实现（抽象方法，由abstract修饰）。抽象类中也可以有普通方法。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="学习" scheme="https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="JavaSE" scheme="https://youngsay.cn/tags/JavaSE/"/>
    
  </entry>
  
</feed>
