{"meta":{"title":"panghutx's blog","subtitle":null,"description":"我是panghutx，现居中国北京，程序员，测试开发工程师，博客涉及编程、互联网、个人感想等内容。","author":"panghutx","url":"https://youngsay.cn","root":"/"},"pages":[{"title":"友情链接","date":"2026-01-07T16:49:01.816Z","updated":"2025-10-10T09:56:06.000Z","comments":true,"path":"link/index.html","permalink":"https://youngsay.cn/link/index.html","excerpt":"","text":"站点信息 感谢访问本站，欢迎互换友链。 网站正常更新 添加本站友链 123name: panghutx&#x27;s blogavatar: https://offer.youngsay.cn/blog/pumpkin.pngurl: https://youngsay.cn"},{"title":"","date":"2026-01-07T16:49:01.818Z","updated":"2021-03-28T06:28:00.000Z","comments":true,"path":"mylist/index.html","permalink":"https://youngsay.cn/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2026-01-07T16:49:01.813Z","updated":"2022-01-11T00:42:02.000Z","comments":true,"path":"categories/index.html","permalink":"https://youngsay.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2026-01-07T16:49:01.825Z","updated":"2022-01-11T00:40:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://youngsay.cn/tags/index.html","excerpt":"","text":""},{"title":"artitalk","date":"2026-01-07T16:49:01.810Z","updated":"2023-01-25T07:51:32.000Z","comments":true,"path":"artitalk/index.html","permalink":"https://youngsay.cn/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2026-01-07T16:49:01.821Z","updated":"2022-01-05T03:35:32.000Z","comments":true,"path":"search/index.html","permalink":"https://youngsay.cn/search/index.html","excerpt":"","text":""},{"title":"关于","date":"2026-01-07T16:49:01.807Z","updated":"2025-10-10T09:38:08.000Z","comments":true,"path":"about/index.html","permalink":"https://youngsay.cn/about/index.html","excerpt":"","text":"Hi，欢迎来到panghutx’s blog，我是panghutx，现工作在北京，是一名测试开发工程师。 我从21年开始写这个博客，主要记录心得感悟、学习笔记、编程等内容，欢迎留下你的评论。"}],"posts":[{"title":"如何将Hexo部署至服务器","slug":"redeploy-hexo","date":"2026-01-02T13:44:15.000Z","updated":"2026-01-03T01:45:58.000Z","comments":true,"path":"2026/01/02/redeploy-hexo/","link":"","permalink":"https://youngsay.cn/2026/01/02/redeploy-hexo/","excerpt":"","text":"前言 2022年腾讯云搞活动买了五年的服务器，才300多。hexo一直部署在服务器上，比在github或vercel上要快不少。最近想用服务器部署一个项目，用到了node18，发现服务器系统还是centos7，在2024年中旬就不再维护了。服务器上除了博客和大学做的一些垃圾也没什么重要的东西，所以今天直接重装了系统，导致博客打不开，晚上又重新部署了下博客。 上一次部署的时候就没有留痕，这次部署也遇到些问题，所以打算写一篇博客记录一下。 一、 环境准备：安装核心依赖 首先，我们需要安装 Node.js、Git、Nginx 以及用于自动化配置 HTTPS 的 Certbot。以 Ubuntu/Debian 系系统为例： 123456# 添加 Node.js 18 运行源curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -# 更新并安装依赖sudo apt updatesudo apt install -y nodejs git nginx certbot python3-certbot-nginx 为什么用 Certbot？ 以往配置 HTTPS 需要手动生成 CSR、上传验证文件、修改 Nginx 配置，流程极其繁琐。现在只需一行命令，Certbot 就能自动完成证书申请和 Nginx 配置，简直是运维神器。 二、 配置 Nginx：让站点可访问 我们需要为博客创建一个 Nginx 配置文件。 创建配置文件：sudo vim /etc/nginx/sites-available/yourdomain 写入基础配置： 1234567891011121314server &#123; listen 80; server_name example.com www.example.com; # 替换为你的域名 root /var/www/hexo; # 博客文件存放目录 index index.html; location / &#123; try_files $uri $uri/ /index.html; &#125; access_log /var/log/nginx/hexo.access.log; error_log /var/log/nginx/hexo.error.log;&#125; 激活配置： 123456# 创建软链接以激活站点sudo ln -s /etc/nginx/sites-available/yourdomain /etc/nginx/sites-enabled/# 测试配置并重启 Nginxsudo nginx -tsudo systemctl reload nginx 小技巧： 使用 sites-available 和 sites-enabled 的模式是为了方便管理。如果你想临时下线某个站点，只需删除 sites-enabled 里的快捷方式（软链接）即可，源文件依然保留。 三、 开启 HTTPS：安全加固 在域名解析生效后，执行以下操作，Certbot 会自动修改 Nginx 配置并加入 SSL 支持： 1234sudo certbot --nginx -d example.com -d www.example.com# 测试自动续期（模拟执行）sudo certbot renew --dry-run 四、 自动化部署：Git Hooks 方案 为了实现本地执行 hexo d 就能自动更新服务器文件，我们需要在服务器上配置一个 Git 仓库作为“中转站”。 1. 安全起见：创建专用 git 用户 为了避免直接使用 root 账户带来的安全隐患，我们创建一个名为 git 的用户。 12sudo useradd -m gitsudo passwd git # 设置密码 2. 配置 SSH 免密登录（可选但推荐） 在本地终端（如 Git Bash）生成秘钥对并将其公钥上传至服务器，后续部署无需反复输入密码。 本地操作：在本地计算机上打开Git Bush执行命令: ssh-keygen -t rsa，生成密钥对。运行完后可在C:\\Users\\用户名.ssh文件下找到id_rsa和id_rsa.pub文件，前者为私钥文件，后者为公钥文件 服务器操作： 在服务器终端先执行makdir -p /home/git/.ssh，后执行cd /home/git/.ssh以及nano authorized_keys，输入本地id_rsa.pub文件内容。粘入公钥内容后按：Ctrl+O （写出 write-out），回车确认文件名（默认显示 authorized_keys），然后按 Ctrl+X 退出 nano。 123456su - gitmakdir -p /home/git/.sshcd /home/git/.sshnano authorized_keys # 粘贴本地公钥chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 3. 创建 Git 裸库与钩子 裸库（Bare Repository） 不包含工作区，仅用于存储版本历史，是实现自动部署的核心。 123cd /home/gitgit init --bare blog.gitchown -R git:git blog.git 接着，编辑钩子文件（post-receive），当有新代码 push 进来时，自动将其检出到 Web 目录： 新建文件： nano /home/git/blog.git/hooks/post-receive 写入以下脚本： 1234#!/bin/bash# --work-tree 对应 Nginx 配置中的 root 目录# --git-dir 对应 Git 仓库目录git --work-tree=/var/www/hexo --git-dir=/home/git/blog.git checkout -f 赋予执行权限并调整目录所有权： 123chmod +x /home/git/blog.git/hooks/post-receive# 确保 git 用户对 Web 目录有写入权限sudo chown -R git:git /var/www/hexo 五、 本地配置：一键发布 最后一步，修改本地 Hexo 根目录下的 _config.yml 文件： 1234deploy: type: git repository: git@你的服务器IP:/home/git/blog.git branch: master 发布流程： 123hexo cleanhexo ghexo d 至此可以在浏览器中输入域名来访问博客站点了。","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://youngsay.cn/tags/hexo/"}]},{"title":"2025年终总结","slug":"2025","date":"2025-12-14T08:45:15.000Z","updated":"2025-12-14T08:45:12.000Z","comments":true,"path":"2025/12/14/2025/","link":"","permalink":"https://youngsay.cn/2025/12/14/2025/","excerpt":"","text":"匆匆，又过了一年，今年是我的本命年，上月刚过了本命年生日，也没有特别的仪式，和往常一样，和往年一样。 这一年，是我毕业后的第二年，也是工作的第二年，与大学生活渐行渐远，上学时不觉得多么幸福，失去后才懂得珍惜，我活在幸福里，而我却不知道。当然，人也会美化过去，包括过去的痛苦。这一年，我换了家公司，继续从事测试开发的工作，算上实习的时间，已经是一名练习时长两年半的测试开发工程师了。工作两年多的时间，一定是有一些改变的，对工作技能的熟悉，balabala，不仅仅是班味更重、身体更差…上学时想找到工作，工作后不想上班，想起朋友和我说的一句话，“生活像一枚钟表，每天都是从12转到12，只要有电就这样一直走下去。”早出晚归，两点一线，我想着也是很多人不想上班的原因，不是讨厌自己的工作，而是缺少对时间的掌控，不能灵活支配自己的时间。对时间的掌控力，是影响幸福感的关键因素。此外，社交媒体是情绪放大器，打开社交媒体，有人在游山玩水，有人用心生活，怎么大家都不用上班，更加加剧了不想上班的情绪。 这一年，我整本读完的有《德米安》《小王子》 《悲喜同源》《软技能：代码之外的生存指南》《金钱心理学》，阅读的目的，一是为了消遣娱乐，一是希望能学到点什么，无论出于哪种目的，我都没做好。90%的书都没能读完，有的内容不感兴趣，有的觉得没什么新观点，比如最近看的《少有人走的路》，感觉书中讲的都是我知道的，重要的是没有亲身实践，做不到知行合一。10%的书可能读完了，但没能有效吸收，为了读而读，像是有人催促一般，迫不及待快点读完，读的过程没有过多思考，读后也没有总结整理，更没有实践。得到的是信息，而不是知识。这个时代最不缺的就是信息，每天被大量信息裹挟，“垃圾进，垃圾出”，除了浪费了时间，什么都没得到。 这一年，我的居住条件有了些改善，从次卧搬到了主卧独卫，这是今年做的比较满意的事。佛教讲“境随心转”，但我还没有那般修行，早上醒来，看到阳光打到床上，心情都会变好一些，一个较好的居住环境对我影响还挺大的。这一年，我的物欲需求趋于稳定，随着生活水平的提升，物欲需求仍像从前那样，这也是我比较欣慰的。真正了解自己的需求，而不是创造需求。明年，我要适当增加对体验的支出，相比物质消费，体验消费能带来更持久的幸福感，多年后回想起那次旅行，和朋友谈起那次晚餐，久久回甘。这一年，最爱我的姥姥走了，遗憾没能多陪陪姥姥。看到一句话感到很暖，“死亡，就是从有子女的地方，搬到了有父母的地方“，姥姥一定是想家了。转眼间我都工作了，父母年纪也越来越大了，小时候觉得无所不能的他们渐渐开始需要我拿定注意，但其实我没有做好承担责任的准备。 就写到这。我不善于规划，一天，一周，一年，就这样稍纵即逝，我有时会反思，心血来潮制定计划，但执行不了几天又和往常一样，就像现在，我写着年终总结，可能会立下几个flag，到明年年终来看，一个也没能实现。一次又一次尝试改变，一次又一次以失败告终，晚上想了千条路，早上醒来走原路。我会抱怨工作太忙，没有时间思考，没有时间改变。但一个又一个宁静的深夜，一个又一个空闲的假期，换来的不是自我反思，不是自我改变，而是逃避直面自己，用娱乐填补空虚。我知道要自律，要运动，要学习…但我做不到知行合一。在困难面前我会退缩，责任面前我会逃避，我喜欢做快乐、容易、简单的事。但可能也没那么遭，只要承认自己是个普通人。","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"2023年终总结","slug":"2023","date":"2024-01-01T03:03:15.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2024/01/01/2023/","link":"","permalink":"https://youngsay.cn/2024/01/01/2023/","excerpt":"","text":"一年又过去了，这是博客的第三个年终总结。 回看了前两年的年终总结，都是那样普通平常，而且前两年赶上了疫情，要么延期开学，要么封校，要么提前放假。与博友们的丰富多彩的生活相比，我就像白活了一样。 今年与往年有些不同，有了新的身份——实习生，活跃地点也由家和学校转移到了公司、出租屋。 1-4月，开启人生第一份实习，新鲜又陌生，期待又恐惧。 5月，担心挂科重回学校，4门必修课，大半学期没听课，最后考的还不错。所以说要活在当下，不要透支烦恼，你所想的种种麻烦大都不会发生，即便发生也都会顺利解决。 8-10月，秋招。秋招并不顺利，我想这是心态的问题，心态差，做什么都无济于事了。每天只是麻木的做着测评、笔试、面试，事后没有复盘、反思。看似很努力，其实只将一件事重复了一次又一次。 9月，大四开学，学校组织去外地实训，度过快乐、难忘的两周。一起去海边、聚餐、熬夜看鬼片，这才是大学生活。 11月，秋招不顺利，二次实习。 2024年了，虚岁24岁了，我不敢想。 还记得小学英语课上一个小插曲，老师问大家里的梦想是什么，我说想做policeman，老师听成了postman（其实postman还挺符合我的，现在听到postman，脑子里只有那个调试接口的软件），到现在还印象深刻。当时为什么说policeman，我好像没有过当警察的梦想，可能有过却被我忘了，可能是刚好想起这个单词。 上高中之后，我的目标渐渐清晰，我想做一个程序员，当时对码农概念还比较单一，只是想做出属于自己的网站，也不懂什么前端、后端，网上找到一些便宜甚至免费的虚拟主机，再找到一些现成的源码，上传上去，就能访问了。当时搭过各种博客（wordpress、emlog、typecho…）、影视网站、论坛（Flarunm、Discuz），甚至还有刷钻的网站。捣鼓这些玩意，就浪费了一天又一天的时间，一无所获却倾尽所有。 再后来才接触到前端，看到自己写的东西能展示在页面上，乐在其中。上了大学，又接触到了后端。从只会写一些简单的页面，到前后端交互，能写一些逻辑，不知道当时自己有多快乐。 到了大三、大四，有了就业的压力，好像已经忘了最初的目标。不再沉浸在编程的快乐，而是苦于八股文、算法、找工作…想想初学编程的时候，只是单纯喜欢，没有想过什么钱多钱少，什么大厂小厂，一个小功能实现了，我都能乐一天了。现在呢，想要更好的工作，想要更高的工资，永远不知足。 与过去的自己相比，我已经成长了。从搬源码，到写一些简单的静态页面，到能够前后端交互，虽然这些并不难，但对比以前的自己，已经进步了。从想做一个码农，到成为了一个码农，我的目标已经实现了。如果我是当初的我，我一定会非常高兴。即使我是现在的我，也没理由不高兴，对吗？ 2024，保持热爱，找寻自我。不再羡慕他人的精彩，为自己的成长喝彩。人生，才刚刚开始。","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"2022年终总结","slug":"2022","date":"2023-01-21T07:15:15.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2023/01/21/2022/","link":"","permalink":"https://youngsay.cn/2023/01/21/2022/","excerpt":"","text":"时间过得真快啊，今天就是大年三十了，一年又这样过去了。 没什么可写的，但又想写点什么，毕竟好久没写记录自己的日常了，连”个站商店“也把我网站删除了。与其说是年终总结，不如说是流水账。 《个站商店》给你发了单独的邮件， hi 胖虎同学 ： 很抱歉，你的网站《胖虎同学》未能通过『个站商店』的审核，主要原因是内容非原创，多是技术类或者转载类，这类网站一般比较少人看。等你整改后，欢迎再来哦！ ———— 祝生活愉快！ 邮件来自《个站商店》 2023-01-18 12:51:59 今年也和往年一样，疫情，开学，放假…… 2月28日，开学，开学没几天，疫情严重，在校上网课。5月25日，请假离校，提前过上暑假生活…… 9月5号开始返校，已经是大三的老家伙了，因家里疫情被延期返校，13日回校。开学没几天，疫情严重，在校上网课。11月26日，请假离校，提前过上寒假生活…… 除了开学放假外，今年有两件事可以说说。一件好事，一件坏事。 一件好事就是找到了实习。12月，我开始准备找实习的事，很幸运在12月30日拿到了实习offer。 1月5号，去公司报到，开始实习生活。1月21也就是今天，回家过年。这月只工作了11天，而这一周人都走的差不多了，基本上就是摸鱼，所以只工作了5天。 在这段时间里，感觉挺快乐，是我之前没有体会到的新生活。但也遇到些问题。","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"MySQL数据库：事务","slug":"MySQL-transaction","date":"2022-11-29T05:04:41.000Z","updated":"2022-11-29T05:41:08.000Z","comments":true,"path":"2022/11/29/MySQL-transaction/","link":"","permalink":"https://youngsay.cn/2022/11/29/MySQL-transaction/","excerpt":"","text":"事务的概念 事务是逻辑上的一组操作，能够将各SQL语句打包执行，要么全都执行，要么全都不执行。 想象我们在操作数据库时，数据库突然挂了，或者多个线程写入数据库时覆盖了彼此的更改……一系列操作都会导致数据库数据的不一致性，基于这些问题，数据库有了事务这一机制。 拿转账举例，A想要向B转账500元，该操作分为两步： A的账户减少500元 B的账户增加500元 事务会将这两步打包在一起执行，要么全都执行，要么全都不执行。不会出现A的账户少了500，而B账户没有增加500的情况。 如何使用事务 ①开启事务 1start transaction; ②执行多条SQL语句 1234-- A账户减少500update accout set money=money-500 where name = &#x27;A&#x27;;-- B账户增加500update accout set money=money+500 where name = &#x27;B&#x27;; ③回滚或提交：rollback/commit; 1commit; 说明：rollback即是全部失败，commit即是全部成功。 事务的特性 关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有四大特性： 原子性 原子性：事务为执行的最小单元，不可再划分，要么全都执行，要么全都不执行。 一致性：事务执行前后的数据要保持一致，结果不能出现异常。拿转账举例，转账前后两个账户的总额是不变的。 持久性：事务带来的影响是持久的，不会因为数据库故障而产生任何影响。 隔离性：并发访问数据库时，各事务之间的数据库是独立的，一个用户的事务不会被其他事务所干扰。 只有保证事务的原子性、持久性和隔离性，才能保证事务的一致性，所以说原子性、持久性和隔离性是事务的手段，一致性是目的。 并发事务带来的问题 脏读：一个事务正在访问数据库并对数据进行修改，而该修改并未提交到数据库，另一个进行此时访问数据库读取数据。而这里访问的数据只是一个中间的数据，不一定是最终的结果，这里读到的数据就是一个“脏数据”，基于“脏数据”做出的操作可能是错误的。 不可重复读：在一个事务内多次读取同一数据。在多次读取数据之间，另一个事务访问并修改了该数据，那么再次读取该数据时，发现与之前读取到的数据不一样。在一个事务内两次读取到的数据不一样，称为不可重复读。 幻读:一个事务(T1)读取了几行数据，此时另一个事务(T2)插入了一些数据。事务T1再次读取该数据发现多了一些原本不存在的数据，这就是幻读。幻读是不可重复读的特殊情况，不可重复读强调的是数据的更改，幻读强调的是数据的增加。 事务隔离级别 SQL标准定义了四个隔离级别，隔离级别越高，并行化就越低。 read-uncommitted：读取未提交。最低的隔离级别。允许读取未提交的数据，可能导致脏读、不可重复读、幻读。 read-committed：读取已提交。不能读取未提交的数据，即事务在修改数据时另一个事务不能执行读操作。可以防止脏读，不能避免不可重复读、幻读。 repeatable-read：可重复读。事务在读取数据时，其他事务不能修改正在读取的数据。因此对同一数据的多次修改结果都是一致的，可以防止脏读、不可重复读，不能避免幻读。 serializable：串行化。最高的隔离级别。各事务串行执行，相互之间不存在干扰，可以防止脏读、不可重复读和幻读。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://youngsay.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"MySQL","slug":"MySQL","permalink":"https://youngsay.cn/tags/MySQL/"}]},{"title":"MySQL数据库：索引","slug":"MySQL-index","date":"2022-11-28T13:04:41.000Z","updated":"2022-11-28T13:18:48.000Z","comments":true,"path":"2022/11/28/MySQL-index/","link":"","permalink":"https://youngsay.cn/2022/11/28/MySQL-index/","excerpt":"","text":"索引是一种用于快速查找和检索数据的数据结构，类似于图书的目录，通过索引可以更快地找到对应的数据。 索引的优缺点 优点： 提高了查找的效率 通过创建唯一性索引，确保了每一行数据的唯一性。 缺点： 索引使用物理文件存储，带来了空间的消耗。 创建和维护索引需要耗费时间。当数据发生更改时，索引也会动态修改，降低SQL执行效率。 索引SQL 查看索引 1show 索引名 from 表名(列名); 创建索引 1create index 索引名 on 表名(列名); 删除索引 1drop index 索引名 on 表名 索引底层的数据结构 索引是一种查找更快的数据结果。 数组和链表的查找都需要遍历，最先淘汰。 二叉搜索树最坏情况下会变成单支树，查找的时间复杂度变为O(N)，淘汰。 AVL树和红黑树使得左右子树高度相对平衡，但数据量太大时，树的高度过高，比较次数过多，即磁盘IO过多，淘汰。 哈希表查找的时间复杂度是O(1)，是不是可以作为索引的数据结构了呢？NO！哈希表不支持顺序和范围查找，而SQL要经常进行排序和 范围查询，淘汰。 目前大多数数据库采用B树或B+树作为索引结构，在MySQL中，MyISAM 引擎和 InnoDB 引擎都是使用 B+树 作为索引结构。 B树称为多路平衡查找树，B+树是在B树基础上的变现，二者都是多叉平衡树。 B树 B+树 区别和联系 B树N个值，划分为N+1个结点；B+树N个值，划分为N个结点。 B树叶子结点相互独立;B+树叶子结点是链式结构，指向相邻结点。 B树每个结点既存放key，又存放data；B+树只有叶子结点既存放key，又存放data，其他结点只存key。 B树的查找过程是对每个关键字二分查找，可能没有到叶子结点就检索到了；B+树更加稳定，每次查找都是从根节点开始，到叶子结点结束。 索引为什么要用B+树 每次都是从根节点到叶子结点，IO次数都差不多，查询效率稳定。 磁盘IO请求数少，查询速度快。 叶子结点采用链式存储结构，方便数据范围查询。 非叶子结点只存储key，占用空间小，甚至可以缓存到内存中。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://youngsay.cn/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://youngsay.cn/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"socket套接字网络编程","slug":"Java-Socket","date":"2022-11-22T06:14:41.000Z","updated":"2022-11-22T06:49:58.000Z","comments":true,"path":"2022/11/22/Java-Socket/","link":"","permalink":"https://youngsay.cn/2022/11/22/Java-Socket/","excerpt":"","text":"网络编程使计算机不再是一个孤立的个体，而是一个互联的整体，通过网络编程，可实现主机各进程间的数据传输。网络编程的核心就是套接字socket。socket是由系统提供用于网络通信的技术，是基于TCP/IP协议的网络通信的基本操作单元。 socket主要分为三类：流套接字、数据报套接字、原始套接字。我们这里主要介绍前两种： 流套接字：使用传输层TCP协议，提供面向连接、可靠的数据传输，面向字节流，有接收缓冲区和发送缓冲区，传输数据大小无限制。 数据报套接字：使用传输层UDP协议，提供无连接、不可靠传输，面向数据报，只有接收缓冲区，传输大小受限，一次最多传输64K。 下面我们来看下Java中是如何使用socket来进行网络编程的。 数据报套接字 Java数据报套接字编程有两个核心的类，DatagramSocket和DatagramPacket。 两个核心类 DatagramSocket用于创建一个数据报套接字，用于发送和接收数据报。主要的构造方法如下： 方法名 说明 DatagramSocket() 创建一个UDP数据报套接字的Socket，绑定到本机任意一个随机端口 （一般用于客户端） DatagramSocket(int port) 创建一个UDP数据报套接字的Socket，绑定到本机指定的端口（一般用 于服务端） 常用方法如下： 方法名 说明 void receive(DatagramPacket p) 从此套接字接收数据报（如果没有接收到数据报，会阻塞等待） void send(DatagramPacket p) 从此套接字发送数据报包（不会阻塞等待，直接发送） void close() 关闭此数据报套接字 方法内的参数类型，就是我们要介绍的另一个核心类：DatagramPacket，该类表示数据报包，用于进程间的发送和接收。主要构造方法如下： 方法名 说明 DatagramPacket(byte[] buf, int length) 构造一个数据报包，用来接收，接收的数据保存在字节数组buf中，接收指定长度length DatagramPacket(byte[] buf, int offset, int length, SocketAddress address) 构造一个数据报包，用来发送，发送的数据为字节数组buf，从offset到长度length，指明目标主机地址address，即IP和端口号 常用方法如下： 方法名 说明 InetAddress getAddress() 获取该数据报发送或接收数据报的计算机的IP地址。 getSocketAddress() 获取该数据包发送到或正在从其发送的远程主机的SocketAddress（通常为IP地址+端口号）。 int getPort() 获取该数据报发送或接收数据报的端口号 byte[] getData() 获取数据报中的数据 int getLength() 返回要发送的数据的长度或接收到的数据的长度。 服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UdpServer &#123; private static DatagramSocket socket = null; public UdpServer(int port) throws SocketException &#123; //创建一个服务器端的数据报套接字，通常指明端口 socket = new DatagramSocket(port); &#125; public void start()&#123; System.out.println(&quot;服务器已连接&quot;); try &#123; while(true)&#123; //1.接收请求 //创建数据报包，用来接收客户端发来的请求 DatagramPacket reqPacket = new DatagramPacket(new byte[1024],1024); //接收数据报，没有数据传来时会阻塞等待 socket.receive(reqPacket); //★从接收的数据报中解析数据，构造成请求字符串 String req = new String(reqPacket.getData(),0,reqPacket.getLength(),&quot;utf8&quot;); //2.构造响应 //这里没有做处理，发来什么就返回什么。 String resp = process(req); //创建数据报包，用来发送响应 //将响应字符串转换成字节数组，指明目的主机地址 DatagramPacket respPacket = new DatagramPacket(resp.getBytes(),resp.getBytes().length,reqPacket.getSocketAddress()); //3.发送响应 socket.send(respPacket); //4.打印日志 System.out.printf(&quot;[%s:%d] req: %s, resp: %s\\n&quot;, reqPacket.getAddress().toString(), reqPacket.getPort(), req, resp); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //构造响应 private String process(String req) &#123; return req; &#125; public static void main(String[] args) throws SocketException &#123; UdpServer server = new UdpServer(9090); server.start(); &#125;&#125; 代码中★处要尤为注意： 构造请求字符串的第三个参数：请求字符串长度，是接收到的数据报的长度，reqPacket.getLength()。一定不要写成reqPacket.getData().length()，这个是字节数组的长度，该代码为1024。 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243public class UdpClient &#123; private final int port; //服务器端口号 private final String ip; //服务器ip地址 private DatagramSocket socket = null; public UdpClient(String ip,int port) throws SocketException &#123; //创建一个客户端的数据报套接字，通常不指明端口 this.socket = new DatagramSocket(); this.ip = ip; this.port = port; &#125; public void start()&#123; try &#123; while(true)&#123; //0.输入请求 System.out.println(&quot;请输入请求：&quot;); Scanner scanner = new Scanner(System.in); String req = scanner.nextLine(); //1.构造请求 //创建一个数据报包，用来发送请求★ DatagramPacket reqPacket = new DatagramPacket(req.getBytes(),req.getBytes().length,InetAddress.getByName(ip),port); //2.发送请求 socket.send(reqPacket); //创建接收数据包，用来接收服务器发来的响应 DatagramPacket respPacket = new DatagramPacket(new byte[1024],1024); //3.接收响应 socket.receive(respPacket); String resp = new String(respPacket.getData(),0,respPacket.getLength()); System.out.println(&quot;resp：&quot;+resp); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws SocketException &#123; //参数内为服务器的ip和端口号 UdpClient client = new UdpClient(&quot;127.0.0.1&quot;,9090); client.start(); &#125; 代码中★处： 构造发送数据包时要传入目的主机的地址，InetAddress.getByName(ip),port分别为主机的ip地址和端口号，除了这样，还可以通过创建socketAddress类来指定主机地址。 12SocketAddress socketAddress = new InetSocketAddress(ip,port);DatagramPacket reqPacket = new DatagramPacket(req.getBytes(),req.getBytes().length,socketAddress); 流套接字 Java流套接字编程也有两个核心的类，ServerSocket和Socket。 两个核心类 ServerSockert通常用于创建一个服务器端的流套接字，常用构造方法如下： 方法名 说明 ServerSocket(int port) 创建一个服务端流套接字Socket，并绑定到指定端口 常用方法如下： 方法名 说明 Socket accept() 监听要连接此客户端的套接字，有客户端连接后，返回一个服务端Socket对象，并基于该Socket建立与客户端的连接，否则阻塞等待 void close() 关闭此套接字 Socket通常用于常见一个客户端的流套接字，常用构造方法如下： 方法名 说明 Socket(String host, int port) 创建一个客户端流套接字Socket，并与对应IP的主机上，对应端口的进程建立连接 常用方法如下： 方法名 说明 InetAddress getInetAddress() 返回套接字所连接的地址 InputStream getInputStream() 返回此套接字的输入流 OutputStream getOutputStream() 返回此套接字的输出流 服务器端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class TcpServer &#123; ServerSocket server = null; public TcpServer(int port) throws IOException &#123; //创建一个服务器套接字，指定服务器端口号 server = new ServerSocket(port); &#125; public void start() throws IOException &#123; while(true)&#123; //监听客户端并建立连接 Socket client = server.accept(); processConnection(client); &#125; &#125; public void processConnection(Socket client) throws IOException &#123; System.out.printf(&quot;[%s,%d]客户端建立连接\\n&quot;,client.getInetAddress(),client.getPort()); //创建输入输出流，输入流用来接收客户端传来的数据，输出流用来将数据发给客户端 try(InputStream inputStream = client.getInputStream())&#123; try(OutputStream outputStream = client.getOutputStream())&#123; while(true)&#123; Scanner scanner = new Scanner(inputStream); if(!scanner.hasNext())&#123; System.out.printf(&quot;[%s,%d]客户端断开连接&quot;,client.getInetAddress(),client.getPort()); break; &#125; //1.接收请求 String req = scanner.nextLine(); //2.构造响应 String resp = process(req); //3.返回响应 PrintWriter printWriter = new PrintWriter(outputStream); //★调用println方法，不能是print和write printWriter.println(resp); printWriter.flush(); System.out.printf(&quot;req:%s,resp:%s\\n&quot;,req,resp); &#125; &#125; &#125;finally &#123; //★关闭连接 client.close(); &#125; &#125; private String process(String req) &#123; return req; &#125; public static void main(String[] args) throws IOException &#123; TcpServer server = new TcpServer(9090); server.start(); &#125;&#125; ★处要尤为注意： 调用的是println方法，不是print也不是write。println方法会为写入的数据后面添加上换行符，而print和write不会。客户端接收数据时是以换行符为结束来获取数据。如果找不到换行符，将一直不能接收响应，造成阻塞。同理，客户端发送请求时也要使用println方法，否则服务器也会接收不到请求而一直阻塞。 大家可能会想，为什么这里的client要关闭连接，而server和之前的数据报套接字都不需要关闭连接。关闭连接的前提是不再使用了，对于UDP和ServerSocket，它们是贯穿程序始终的，而这里的client，也就是Socket，每个连接都有一个Socket，断开连接也就不再需要这个Socket了，需要进行释放。 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TcpClient &#123; private int port; private String ip; Socket client = null; public TcpClient(String ip,int port) throws IOException &#123; this.port = port; this.ip = ip; //★创建客户端套接字，并将其连接到指定IP地址的指定端口号。 this.client = new Socket(ip,port); &#125; public void start()&#123; try(InputStream inputStream = client.getInputStream()) &#123; try(OutputStream outputStream = client.getOutputStream())&#123; while(true)&#123; //1.构造请求 Scanner scanner = new Scanner(System.in); String req = scanner.next(); //2.发送请求 PrintWriter printWriter = new PrintWriter(outputStream); //★调用println方法，不能是print和write printWriter.println(req); printWriter.flush(); //3.接收响应 Scanner respScan = new Scanner(inputStream); String resp = respScan.next(); System.out.println(&quot;resp:&quot;+resp); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws IOException &#123; TcpClient client = new TcpClient(&quot;127.0.0.1&quot;,9090); client.start(); &#125;&#125; 问题 流套接字的客户端服务器通信还存在一个问题，只能满足一个客户端的通信。其他客户端尝试与服务器连接时，会发生阻塞。观察服务器代码中下面这段代码： 1234567public void start() throws IOException &#123; while(true)&#123; //监听客户端并建立连接 Socket client = server.accept(); processConnection(client); &#125;&#125; 客户端1与服务器建立连接后，服务器线程执行processConnection代码中的操作，代码中存在while循环，不断地接收客户端1发来的请求，构造响应，返回响应……此时客户端2想要与服务器通信，而服务器线程正在processConnection的while循环中等待客户端1的请求，导致服务器不能与客户端2建立连接。 TCP每次都需要建立连接，只能支持一对一，也就是端到端的通信。就像打电话一样，同一时间只能接听一个电话，当正在通话时，别的电话是打不进来的。而UDP是无连接的，因此支持一对一、一对多、多对多交互通信。所以我们在数据报套接字时没有出现该问题。 解决办法也很简单，因为processConnection中的循环未结束导致服务器不能执行accept操作，所以单独创建一个新的线程来完成processConnection操作即可。我们可以用多线程或线程池来解决。 1234567891011121314public void start() throws IOException &#123; while(true)&#123; //建立连接 Socket client = server.accept(); Thread t = new Thread(()-&gt;&#123; try &#123; processConnection(client); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;); t.start(); &#125; 其他代码不变，只需改动start方法内的代码，为processConnection操作创建新的线程。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://youngsay.cn/tags/socket/"}]},{"title":"Java文件和IO流","slug":"Java-IO","date":"2022-11-17T12:14:41.000Z","updated":"2022-11-17T12:21:06.000Z","comments":true,"path":"2022/11/17/Java-IO/","link":"","permalink":"https://youngsay.cn/2022/11/17/Java-IO/","excerpt":"","text":"文件基础操作 1234567891011121314151617181920public static void main(String[] args) throws IOException &#123; //创建一个hello的目录 File dir = new File(&quot;hello&quot;); if(!dir.exists())&#123; dir.mkdirs(); &#125; //在hello目录下创建一个hello.txt文件 File file = new File(dir+&quot;/hello.txt&quot;); if(!file.exists())&#123; file.createNewFile(); &#125; //得到文件名 System.out.println(file.getName()); //得到文件的绝对路径 System.out.println(file.getAbsolutePath()); //得到文件的规范路径，当路径不规范时，会进行优化(去掉.) System.out.println(file.getCanonicalPath()); //得到父目录名 System.out.println(file.getParent());&#125; 具体详见：File (Java Platform SE 8 ) (oracle.com) IO流 IO即输入和输出（Input、Output），输入就是将数据读入到内存，输出就是将数据输出到外部存储（如文件、数据库）。数据的输入输出就像水流一样，因此成为IO流。 IO流的处理方式可分为两种：字节流和字符流。Java中针对IO流的处理有很多类，但最基本的只有4个抽象类。InputStream、OutputStream、Reader、Writer，前两个是对字节流的输入输出，后两个是对字符流的输入输出。下面我们拿普通文件的读写举例，介绍它们的基本操作。 字节流 InputStream 用于对文件进行读操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数。 常用方法： read() ：一次读取一字节，返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。返回 -1 ，表示读到文件的末尾，读取结束。 read(byte b[ ]) : 一次读取多个字节，将输入流字节存储到数组b，返回结果为读取字节长度。返回-1，表示读到文件的末尾，读取结束。 read(byte b[], int off, int len) ：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 close() ：关闭输入流释放相关的系统资源。 一次读取一字节 1234567891011121314151617private static void readOne(File file,FileInputStream fileInputStream) throws IOException &#123; try &#123; fileInputStream = new FileInputStream(file); while(true)&#123; int read = fileInputStream.read(); if(read==-1)&#123; break; &#125; System.out.print((char)read); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; fileInputStream.close(); &#125;&#125; 一次读取多个字节 123456789101112131415161718192021private static void readByte(File file,FileInputStream inputStream)&#123; try &#123; inputStream = new FileInputStream(file); while(true)&#123; byte[] bytes = new byte[1024]; int read = inputStream.read(bytes); if(read==-1)&#123; break; &#125; for (int i = 0; i &lt; read; i++) &#123; System.out.print((char)bytes[i]); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; inputStream.close(); &#125;&#125; OutputStream 用于对文件进行写操作，构造方法内可以是一个文件类型的参数，也可以是一个文件路径(字符串)的参数，同时可以指定第二个参数表示是否追加写入(是否清空之前的内容)，true表示追加写入，默认为false。 在写操作时数据暂时放在缓存区，只有缓存区满后才会真正写入到设备，所以别忘了调用fulsh()，防止数据没有写入设备。 常用方法： write(int b) ：将特定字节写入输出流。 write(byte b[ ]) : 将数组b 写入到输出流，等价于 write(b, 0, b.length) 。 write(byte[] b, int off, int len) : 在write(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 flush() ：刷新此输出流并强制写出所有缓冲的输出字节。 close() ：关闭输出流释放相关的系统资源。 123456789101112131415private static void writeOne(File file, FileOutputStream outputStream) throws IOException &#123; try &#123; outputStream = new FileOutputStream(file); outputStream.write(103); outputStream.write(104); outputStream.flush(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; outputStream.close(); &#125;&#125; 字符流 字节是电脑中存储信息的基本单位，那为什么还需要字符流呢？ 当存储信息中有中文时，以字节流来读取会出现乱码。字节流更适用于音频、图片等类型文件，当文件中涉及字符类型时，使用字符流更好。字符流默认编码是unicode。 常见的字符编码：utf8 :英文占 1 字节，中文占 3 字节，unicode：任何字符都占 2 个字节，gbk：英文占 1 字节，中文占 2 字节。 Reader 常用方法： read() : 从输入流读取一个字符。 read(char[] cbuf) : 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，等价于 read(cbuf, 0, cbuf.length) 。 read(char[] cbuf, int off, int len) ：在read(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 close() : 关闭输入流并释放相关的系统资源。 一次读取一个字符 123456789101112131415161718private static void readOne(File file,Reader reader)&#123; try &#123; reader = new FileReader(file); while(true)&#123; int read = reader.read(); if(read==-1)&#123; break; &#125; System.out.print((char)read); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; reader.close(); &#125;&#125; 一次读取多个字符 123456789101112131415161718192021private static void readCharacter(File file,Reader reader) throws IOException &#123; try &#123; reader = new FileReader(file); char[] buffer = new char[1024]; while(true)&#123; int read = reader.read(buffer); if (read==-1)&#123; break; &#125; String s = new String(buffer,0,read); System.out.println(s); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; reader.close(); &#125;&#125; Writer 常用方法： write(int c) : 写入单个字符。 write(char[] cbuf) ：写入字符数组 cbuf，等价于write(cbuf, 0, cbuf.length)。 write(char[] cbuf, int off, int len) ：在write(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 write(String str) ：写入字符串，等价于 write(str, 0, str.length()) 。 write(String str, int off, int len) ：在write(String str) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 append(CharSequence csq) ：将指定的字符序列附加到指定的 Writer 对象并返回该 Writer 对象。 append(char c) ：将指定的字符附加到指定的 Writer 对象并返回该 Writer 对象。 flush() ：刷新此输出流并强制写出所有缓冲的输出字符。 close():关闭输出流释放相关的系统资源 12345678910private static void writeOne(File file,Writer writer) throws IOException &#123; try &#123; writer = new FileWriter(file); writer.write(&quot;我是panghutx&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; writer.close(); &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://youngsay.cn/tags/IO/"}]},{"title":"多线程实例：线程池","slug":"Java-ThreadPool","date":"2022-11-14T09:04:41.000Z","updated":"2022-11-14T10:43:44.000Z","comments":true,"path":"2022/11/14/Java-ThreadPool/","link":"","permalink":"https://youngsay.cn/2022/11/14/Java-ThreadPool/","excerpt":"","text":"顾名思义，线程池就是存放线程的池子。直接用线程不就好了吗，为什么还需要线程池呢？ 相比进程，线程已经轻量很多了，创建和销毁线程消耗的资源会少很多，但终究还是有消耗的。为了进一步降低消耗，我们需要用到线程池。需要用到线程时不用申请，直接从线程池中取，用完之后也不用销毁，再放进线程池。 标准库中的线程池（简化版本)： 123456789public static void main(String[] args) &#123; ExecutorService pool = Executors.newFixedThreadPool(10); pool.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;hello&quot;); &#125; &#125;);&#125; 模拟实现一个简化版本的线程池： 描述任务：直接用Runnable接口即可 组织任务：用到阻塞队列 描述工作线程：创建Worker类继承Thread，重写run方法，从阻塞队列中取任务，然后执行任务 组织工作线程：实例化工作线程，加入到线程池，启动线程 提交任务：往线程池中添加任务（具体是将任务添加到阻塞队列） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ThreatPool &#123; //描述一个任务 //组织一个任务 BlockingDeque&lt;Runnable&gt; queue = new LinkedBlockingDeque&lt;&gt;(); //描述一个线程 //线程是用来执行任务的，而任务都存放在队列中 static class Worker extends Thread&#123; //通过构造方法能够拿到外面的queue private BlockingDeque&lt;Runnable&gt; queue = null; public Worker(BlockingDeque&lt;Runnable&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; //从queue中取任务，然后执行任务 while(true)&#123; try &#123; Runnable runnable = queue.take(); runnable.run(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //组织线程,创建线程 List&lt;Worker&gt; workers = new LinkedList&lt;&gt;(); public ThreatPool(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; //创建线程，存放到线程池,执行线程 Worker worker = new Worker(queue); workers.add(worker); worker.start(); &#125; &#125; //提交任务到线程 public void sumbit(Runnable runnable) throws InterruptedException &#123; queue.put(runnable); &#125; public static void main(String[] args) throws InterruptedException &#123; ThreatPool pool = new ThreatPool(10);//线程数10 //执行1000个任务 for (int i = 0; i &lt; 1000; i++) &#123; int workId = i; pool.sumbit(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;任务:&quot;+workId+Thread.currentThread().getName()); &#125; &#125;); &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程实例：定时器","slug":"Java-Timer","date":"2022-11-14T07:04:41.000Z","updated":"2022-11-14T07:18:10.000Z","comments":true,"path":"2022/11/14/Java-Timer/","link":"","permalink":"https://youngsay.cn/2022/11/14/Java-Timer/","excerpt":"","text":"定时器是实际开发中常用的组件，例如文章的定时发布，双11的准点抢购活动等。 下面我们来看一下Java标准库中的定时器。 123456789public static void main(String[] args) &#123; Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println(&quot;hello&quot;); &#125; &#125;, 3000);&#125; 该定时器会在3秒之后输出“hello”。创建一个定时器需要用到Timer类中的核心方法schedule，该方法内有两个参数，一个表示要执行的任务，一个表示任务在多长时间后执行。 认识了标准库中的定时器后，我们可以自己来模拟实现一个定时器。 首先，描述一个任务。创建一个MyTask类，类中有两个属性：一个是执行的任务，一个是任务执行时间。这两个属性类似于标准库schedule方法内的两个参数。 1234567891011121314151617181920212223class MyTask implements Comparable&lt;MyTask&gt;&#123; //具体要干啥 private Runnable runnable; //啥时候开始干 private long time; public MyTask(Runnable runnable,long dalay)&#123; this.runnable = runnable; this.time=System.currentTimeMillis()+dalay; &#125; public void run()&#123; runnable.run(); &#125; public long getTime()&#123; return time; &#125; @Override public int compareTo(MyTask o) &#123; //时间小的排在前面 return (int) (this.time-o.time); &#125;&#125; 接下来，组织一个任务类。如何组织任务类呢，我们这里用到优先级阻塞队列。每个任务的执行时间（指的是在多长时间后执行）不同，根据时间大小来排序，进而优先执行队头任务，因此需要优先级队列。 最后，我们还需要一个线程不断的去扫描到了时间的任务，然后执行这个任务。 12345678910111213141516171819202122232425262728293031323334353637class MyTimer&#123; //组织一个任务 private PriorityBlockingQueue&lt;MyTask&gt; queue = new PriorityBlockingQueue&lt;&gt;(); private Object locker = new Object(); public void schedule(Runnable runnable,long delay)&#123; MyTask myTask = new MyTask(runnable,delay); queue.put(myTask); synchronized (locker)&#123; locker.notify(); &#125; &#125; //执行到时间的任务 public MyTimer()&#123; Thread t1 = new Thread(()-&gt;&#123; while(true)&#123; try &#123; //取队首元素 MyTask task = queue.take(); long time=System.currentTimeMillis(); if(time&lt;task.getTime())&#123; //时间还没到 queue.put(task); synchronized (locker)&#123; locker.wait(task.getTime()-time); &#125; &#125;else&#123; //到时间了，执行这个任务 task.run(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); &#125;&#125; 模拟一个定时器，总共分三步。第一步，把冰箱打开描述一个任务，即要执行的任务和任务多长时间后开始执行。第二步，组织一个任务，这里用到了优先级阻塞队列。第三步，利用一个线程扫描任务，执行到时间的任务。 下面有两个问题需要注意。 任务类要放进优先级阻塞队列中，优先级阻塞队列根据时间先后进行排序。因此我们的任务类要实现Comparable&lt;MyTask&gt;接口，然后重写比较规则。 线程扫描任务，会从队头取元素，判断是否到时间了，如果没到，再放回队列。接着继续取元素……如果不加限制，它一直不停的扫描队首元素, 看看是否能执行这个任务，这样会大量消耗CPU。因此我们利用wait来使这个线程等待，时间到后再唤醒。此外当新加入一个任务后我们也需要用notify来唤醒扫描线程，因为可能该任务的时间更小，优先级更高，所以需要重新扫描任务队列。（这也就决定了必须用wait，而不能用sleep，因为sleep不能中途唤醒）","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"多线程实例：阻塞队列","slug":"Java-BlockingQueue","date":"2022-11-14T04:04:41.000Z","updated":"2022-11-14T04:21:38.000Z","comments":true,"path":"2022/11/14/Java-BlockingQueue/","link":"","permalink":"https://youngsay.cn/2022/11/14/Java-BlockingQueue/","excerpt":"","text":"阻塞队列是一种具有阻塞功能的队列，满足队列“先进先出”的特点，是一种线性安全的数据结构。当队列为空时，执行出队操作会进行阻塞，直到队列中有元素为止；当队列已经满了，执行入堆操作会进行阻塞，知道队列有空间为止。 阻塞队列的一个典型应用常见就是“生产者消费者”模型。毫无疑问，该模型有两个主体：生产者和消费者。生产者线程负责生产产品，将生产好的产品放进阻塞队列。消费者线程负责消费产品，直接从阻塞队列取产品。 生产者消费者模型具有解耦、平衡速度差异的特点。 解耦：生产者无需关注是谁在消费产品，消费了多少产品，只需关注生产操作即可；消费者无需关注是谁在生产产品，生产了多少产品，只需关注消费操作即可。 平衡速度差异：设想11.11，大量用户向服务器发送了大量的支付请求，一次性将这些请求交给服务器处理，服务器可能会hole不住，因此将这些请求都放进阻塞队列，消费者线程从阻塞队列一个一个地来处理请求就好了。这样就起到了“削峰填谷”的作用，平衡了生产者和消费者之间的速度差异。 标准库中的阻塞队列： 123456public static void main(String[] args) throws InterruptedException &#123; BlockingDeque&lt;String&gt; queue = new LinkedBlockingDeque&lt;&gt;(); queue.put(&quot;hello&quot;); String s = queue.take(); System.out.println(s);&#125; BlockingQueue 是一个接口. 真正实现的类是 LinkedBlockingQueue. put 方法用于阻塞式的入队列, take 用于阻塞式的出队列. BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性 模拟实现阻塞队列： 循环队列+阻塞等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MyQueue &#123; public int[] elem = new int[10]; public int head; public int tail; public int size; public final Object locker = new Object(); public void put(int val) throws InterruptedException &#123; synchronized (locker)&#123; //队列满了，阻塞等待 if(size==elem.length)&#123; locker.wait(); &#125; //一轮循环，让尾指针指向数组下标为0的位置 if(tail==elem.length)&#123; tail=0; &#125; elem[tail++]=val; size++; //唤醒消费者线程的堵塞等待 locker.notify(); &#125; &#125; public int take() throws InterruptedException &#123; synchronized (locker)&#123; //队列空了，阻塞等待 if(size==0)&#123; locker.wait(); &#125; if(head==elem.length)&#123; head=0; &#125; int ret = elem[head]; head++; size--; //唤醒生产者线程的堵塞等待 locker.notify(); return ret; &#125; &#125; //测试代码 public static void main(String[] args) throws InterruptedException &#123; MyQueue queue = new MyQueue(); //生产者线程 Thread t1 = new Thread(()-&gt;&#123; int i=0; while (true)&#123; try &#123; queue.put(i); System.out.println(&quot;生产了：&quot;+i); i++; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //消费者线程 Thread t2 = new Thread(()-&gt;&#123; while(true)&#123; try &#123; int take = queue.take(); System.out.println(&quot;消费了：&quot;+take); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); t1.start(); t2.start(); &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java线程的创建及状态","slug":"Java-Thread","date":"2022-10-12T13:04:41.000Z","updated":"2022-11-14T10:47:22.000Z","comments":true,"path":"2022/10/12/Java-Thread/","link":"","permalink":"https://youngsay.cn/2022/10/12/Java-Thread/","excerpt":"","text":"什么是线程 在计算机中，一个任务就是一个进程。打开任务管理器，我们可以看见多个进程。如浏览器，QQ。线程是进程的再划分，是进程的一部分。一个进程可以只有一个线程（主线程），也可以有多个线程。拿浏览器举例，打开浏览器的多个网页，一个网页在播放音乐，一个网页在播放视频，一个网页在浏览博客。每个网页有不同的分工，这些浏览器的每个子任务就是一个线程。 线程是更轻量的进程，创建一个线程的消耗要低于创建一个进程，且同一进程的不同线程之间可以共享资源，效率更高。通过多线程可以更好地实现并发编程。 进程vs线程 进程包含线程，进程是线程的一部分，一个进程中至少包含一个线程。 进程与进程之间不能共享资源，同一个进程的线程之间可以共享资源。 进程是系统分配资源的最小单位，线程是系统调度执行的最小单位。 多进程稳定性高于多线程，一个进程的崩溃不会影响其他线程；多线程下一个线程的崩溃可能影响该进程。 创建线程 一个线程至少包含一个进程，main()就是一个线程，我们还可以在里面创建多个线程。 1.继承Thread类,重写run()方法 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new MyThread(); t.start(); // 启动新线程 &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;start new thread!&quot;); &#125;&#125; 2.创建Thread实例，实现Runnable接口 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyRunnable()); t.start(); // 启动新线程 &#125;&#125;class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(&quot;start new thread!&quot;); &#125;&#125; 3.其他变形 匿名内部类创建Thread子类对象 123456Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(&quot;使用匿名类创建 Thread 子类对象&quot;); &#125;&#125;; 匿名内部类创建Runnable子类对象 123456Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;使用匿名类创建 Runnable 子类对象&quot;); &#125;&#125;); lambda表达式创建Thread子类对象 123Thread t4 = new Thread(() -&gt; &#123; System.out.println(&quot;使用匿名类创建 Thread 子类对象&quot;);&#125;); Thread方法 常见构造方法 构造方法 Thread() 分配一个新的 Thread对象。 Thread(Runnable target) 分配一个新的 Thread对象。 Thread(Runnable target, String name) 分配一个新的 Thread对象，name为新线程的名字。 Thread(String name) 分配一个新的 Thread对象，name为新线程的名字。 启动一个线程.start() Thread对象对创建后，并没有启动线程，执行该指令后才会真正创建一个线程。即内核中创建了一个内存控制块PCB。 中断一个线程 方法1：自定义变量作为标志位 123456789101112131415//自定义变量flag作为标志位static volatile boolean flag = false; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread()&#123; @Override public void run() &#123; while(!flag)&#123; System.out.println(&quot;线程正在运行&quot;); &#125; &#125; &#125;; t.start(); Thread.sleep(1000); //使线程进入休眠状态 flag = true;&#125; 方法2：interrupted()方法中断线程 123456789101112131415public class ThreadDemo3 &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t = new Thread()&#123; @Override public void run() &#123; while(!Thread.currentThread().isInterrupted())&#123; System.out.println(&quot;线程运行中&quot;); &#125; &#125; &#125;; t.start(); Thread.sleep(1000); t.interrupt(); &#125;&#125; Thread.currentThread().isInterrupted()获取当前线程是否被中断；interrupted()向线程发出中断请求。 Thread收到通知方式有两种：①当线程因wait/sleep/join等方法处于堵塞状态时，以 InterruptedException 异常的形式通知。②isInterrupted()标志位置为true. 等待一个线程.join() 执行该指令，会使该线程执行结束后再执行下一线程，即将并发编程变成了串行。比如用某软件下载一部电影，可以边下载边观看，当执行该指令后，就要等下载完后再看了~ 休眠一个线程sleep() 让线程进入休眠状态，进入休眠状态的指令，他的属性isAlive()为Timed Waiting。线程状态会稍后介绍到。 线程状态 注意，这里我们说的是java线程的六种状态。利用isAlive属性可以观察线程的状态，线程有以下6种状态： New：新创建的线程，但未执行start()，线程没有存活； Runnable：运行中的线程，正在执行run()方法的Java代码； Blocked：运行中的线程，因为某些操作被阻塞而挂起； Waiting：运行中的线程，因为某些操作在等待中，如执行wait()方法； Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待； Terminated：线程结束，线程没有存活。 线程状态转换 线程被创建出来，处于New状态。调用start方法后，处于Runnable状态。当线程获取不到锁时，处于Blocked状态，直到获取到锁后进入Runnable状态。运行的线程调用wait或join方法后会进入Waiting状态，直到唤醒通知后进入Runnable状态。调用带有超时参数的方法后会进入Timed Waiting状态，直到时间到后进入Runnable状态。运行的线程执行完run方法或出现异常后进入Terminated状态。 与操作系统中的进程状态不同，java没有就绪态。操作系统中，一个进程调用start后并没有直接运行，而是进入就绪态，当获取到cpu时间片后进入运行态。我们可以认为在java中，就绪态和运行态同属于Runnable。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"线程安全及解决方案","slug":"Thread-safe","date":"2022-09-26T09:40:41.000Z","updated":"2022-11-14T04:22:12.000Z","comments":true,"path":"2022/09/26/Thread-safe/","link":"","permalink":"https://youngsay.cn/2022/09/26/Thread-safe/","excerpt":"","text":"安全，已经成为非常重要的社会话题。所谓“安全第一”，“安全无小事”（手动滑稽），同样，多线程中，线程安全也是非常重要的话题。那么是什么原因造成了线程不安全，又如何解决线程不安全呢？ 造成线程不安全的原因 线程的调度 各线程之间是抢占式执行的，线程的执行顺序是随机的，因此可能会产生各种问题。现在最流行什么？做核酸！如果做核酸是抢占式的，做核酸没有一个顺序，做核酸顺序完全靠运气，这能安全吗！ 多线程同时修改同一变量 如果是多线程同时读取同一变量，不涉及修改的操作，是线程安全的。但如果多线程同时修改同一变量，这能不乱吗？想当年家里买了一台电脑，我姐姐要用电脑玩QQ炫舞，我要用电脑玩穿越火线，你争我抢，打的是不可开交。 操作指令不是原子的 例如一条加法指令，其实要执行三条指令，load、add、save，先将内存中的变量加载到寄存器，在寄存器中完成加法操作，再将结果写会内存中。假设线程1完成了load、add操作，线程2完成了load、add、save操作，当线程1再去执行save操作，便将线程2的操作覆盖了，线程2说：线程1真是一个猪队友。 内存可见性 线程1循环进行读操作，线程2看心情进行修改操作。我们知道，读操作是将内存变量加载到寄存器，然后读取寄存器。而线程1循环加载内存中的值到寄存器，线程2又迟迟不修改，线程1说：你当我傻吗？于是线程1干脆去读取寄存器了，这就是编译器的优化。拿做核酸举例，最初是刮嗓子，但日复一日，现在有些已经是刮舌头了，这难道是疫情的优化？大部分情况下是安全的，但也可能会翻车。线程1循环读操作，线程2突然心情不好，很快啊，修改了内存中的值。而线程1却绕过了内存，从寄存器读值，这能安全吗！ 解决方案 针对原因1，线程的调度就是抢占式执行的，我们无能为力。针对原因2，我们可以通过调整代码结构，使不同线程操作不同变量，但我这菜鸡技术，既然能写出一个bug，就能写出无数个bug，一顿调整猛如虎，结果bug乘以5. 所以我们解决方案寄托在原因3、4上。 Java中提供了synchronized关键字来对操作上锁。拿上面的加法操作举例，为加法这一方法加上synchronized后，就为该操作上锁了。想象要在卫生间完成加法操作，（不敢想象），小县城来的孩子线程1来执行加法操作，发现卫生间没人，他进来后把门锁上，进行加法操作。又一个小县城的孩子线程2来到卫生间前，也想要做加法操作，发现门锁了，只好等到线程1出来后才能进去，他是等也得等，不等也得等，这样就保证了操作的原子性。 Java还提供了volatile关键字来解决内存可见性问题，synchronized也可以解决该问题，只不过开销更大。为代码加上volatile后，就能禁止编译器进行优化，线程1无论做多少次循环读操作，都要耐心地从内存中读值，不能直接去读取寄存器中的值。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java单例模式：懒汉模式和饿汉模式","slug":"Java-Singleton","date":"2022-09-21T13:04:41.000Z","updated":"2022-11-14T04:21:24.000Z","comments":true,"path":"2022/09/21/Java-Singleton/","link":"","permalink":"https://youngsay.cn/2022/09/21/Java-Singleton/","excerpt":"","text":"单例模式，就是一个类中只有一个实例。主要有懒汉模式和饿汉模式。 饿汉模式是在类加载的同时就创建实例，而懒汉模式是使用时才创建实例。 饿汉模式 12345678910class Singleton&#123; //1.使用static创建一个实例，并且立即实例化 private static Singleton instance = new Singleton(); //2.为了防止在其他地方不小心new这个Singleton，把方法构造为private private Singleton()&#123;&#125; //3.提供一个方法，让外面能够拿到唯一实例 public static Singleton getInstance() &#123; return instance; &#125;&#125; 在多线程中，多个线程对同一数据进行读操作，线程安全。 懒汉模式 12345678910111213class Singleton&#123; //1.不立即初始化实例，使用时再初始化 private static Singleton1 instance = null; //2.将构造方法设为private private Singleton1()&#123;&#125; //3.提供方法获取实例 public static Singleton1 getInstance() &#123; if(instance==null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 多线程中，多个线程对同一对象进行读、写操作，线程不安全。线程不安全出现在首次创建实例时，多个线程同时调用getInstance方法，可能创造出多个实例。 改进1： 对getInstance方法加锁，保证操作的原子性，实现线程安全。 12345678910111213class Singleton&#123; //1.不立即初始化实例，使用时再初始化 private static Singleton instance = null; //2.将构造方法设为private private Singleton1()&#123;&#125; //3.提供方法获取实例 public static synchronized Singleton getInstance() &#123; if(instance==null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但这种方法性能较差，毕竟线程不安全只出现在首次创建实例时，为getInstance方法加锁后每次都要加锁解锁，所以做如下改进。 改进2： 进入getInstance方法后首先判断instance是否为空，即是否为第一次创建实例，是才需要加锁，否则不需要加锁。同时为了避免 “内存可见性” 导致读取的 instance 出现偏差, 因此为instance加上volatile。 1234567891011121314151617class Singleton&#123; //1.不立即初始化实例，使用时再初始化 private static volatile Singleton1 instance = null; //2.将构造方法设为private private Singleton()&#123;&#125; //3.提供方法获取实例 public static Singleton getInstance() &#123; if(instance==null)&#123; synchronized (Singleton.class)&#123; if(instance==null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"【JavaWeb】Thymeleaf模板引擎","slug":"Java-Thymeleaf","date":"2022-06-09T11:40:41.000Z","updated":"2022-10-20T11:58:12.000Z","comments":true,"path":"2022/06/09/Java-Thymeleaf/","link":"","permalink":"https://youngsay.cn/2022/06/09/Java-Thymeleaf/","excerpt":"","text":"上篇博客中，我们了解了服务器渲染，并用Thymeleaf模板引擎写了一个简单的猜数字小游戏。 下面我们简单了解一下Thymeleaf的语法。 Thymeleaf常见命令 命令 功能 th:text 在标签体中展示表达式求值结果的文本内容 th:[HTML标签属性] 设置任意的 HTML 标签属性的值 th:if 当表达式的结果为真时则显示内容，否则不显示 th:each 循环访问元素 Thymeleaf语法有很多，我们这里先简单介绍这四个。th:text和th:if在猜数字小游戏案例已经使用过，这里不再介绍。 th:[属性] HTML模板代码： 1234&lt;body&gt; &lt;a th:href=&quot;$&#123;url1&#125;&quot;&gt;胖虎同学&lt;/a&gt; &lt;a th:href=&quot;$&#123;url2&#125;&quot;&gt;胖虎同学1&lt;/a&gt;&lt;/body&gt; Servlet代码： 123456789101112131415161718192021222324252627@WebServlet(&quot;/thymeleafUrl.html&quot;)public class ThymeleafUrlServlet extends HttpServlet &#123; //1.创建核心类,用于完成页面渲染 public TemplateEngine engine = new TemplateEngine(); //2.初始化模板引擎,创建解析器，加载文件，关联 public void init()&#123; ServletContext context = getServletContext(); ServletContextTemplateResolver resolver = new ServletContextTemplateResolver(context); resolver.setCharacterEncoding(&quot;utf-8&quot;); resolver.setPrefix(&quot;/WEB-INF/templates/&quot;); resolver.setSuffix(&quot;.html&quot;); engine.setTemplateResolver(resolver); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = getServletContext(); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //3.实例化WebContext，关联变量 WebContext webContext = new WebContext(req,resp,context); webContext.setVariable(&quot;url1&quot;,&quot;https://youngsay.cn&quot;); webContext.setVariable(&quot;url2&quot;,&quot;http://blog.youngsay.cn&quot;); //4.渲染 engine.process(&quot;thymeleafUrl&quot;,webContext,resp.getWriter()); &#125;&#125; th:each 列举游戏战绩：昵称、击杀、死亡、得分 HTML模板代码： 12345678910&lt;body&gt; &lt;ul&gt; &lt;li th:each=&quot;person : $&#123;persons&#125;&quot;&gt; &lt;span th:text=&quot;$&#123;person.name&#125;&quot;&gt;&lt;/span&gt; &lt;span th:text=&quot;$&#123;person.kill&#125;&quot;&gt;&lt;/span&gt; &lt;span th:text=&quot;$&#123;person.dead&#125;&quot;&gt;&lt;/span&gt; &lt;span th:text=&quot;$&#123;person.score&#125;&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; Servlet代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123; public String name; public int kill; public int dead; public int score; public Person(String name, int kill, int dead, int score) &#123; this.name = name; this.kill = kill; this.dead = dead; this.score = score; &#125; public String getName() &#123; return name; &#125; public int getKill() &#123; return kill; &#125; public int getDead() &#123; return dead; &#125; public int getScore() &#123; return score; &#125;&#125;@WebServlet(&quot;/thymeleafEach&quot;)public class ThymeleafEach extends HttpServlet &#123; //创建TemplateEngine对象 public TemplateEngine engine = new TemplateEngine(); //初始化模板引擎 public void init() &#123; ServletContext context = getServletContext(); ServletContextTemplateResolver resolver = new ServletContextTemplateResolver(context); resolver.setPrefix(&quot;/WEB-INF/templates/&quot;); resolver.setSuffix(&quot;.html&quot;); resolver.setCharacterEncoding(&quot;utf-8&quot;); engine.setTemplateResolver(resolver); System.out.println(&quot;初始化成功&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person(&quot;損友比过狗友i&quot;,12,2,80)); persons.add(new Person(&quot;马棚管理员&quot;,21,8,130)); persons.add(new Person(&quot;吃枣药丸&quot;,16,5,110)); ServletContext context = getServletContext(); WebContext webContext = new WebContext(req,resp,context); webContext.setVariable(&quot;persons&quot;,persons); resp.setContentType(&quot;text/html;charset=utf-8&quot;); engine.process(&quot;thymeleafEach&quot;,webContext, resp.getWriter()); &#125;&#125; ServletContext 观察上篇博客猜数字游戏代码和上面的两段代码，我们发现，每个Servlet都创建了一个TemplateEngine对象并进行初始化，其实这完全没必要，一个webapp中，只创建一个TemplateEngine对象即可。 这就需要用到ServletContext，它是Servlet程序全局存储信息的空间，每个webapp中只有一个ServlectContext，多个Servlet之间共享一个ServlectContext。通过 HttpServlet.getServletContext() 方法获取到当前webapp 的ServletContext对象。 下面是ServletContext常见方法： 方法 描述 void setAttribute(String name, Object obj) 设置属性(键值对) Object getAttribute(String name) 根据属性名获取属性值, 如果 name 不存在, 返 回 null void removeAttribute(String name) 删除对应的属性 我们用代码来证明多个一个webapp中多个Servlet类共用一个ServletContext。 创建一个WriterServlet类 1234567891011121314@WebServlet(&quot;/writer&quot;)public class WriterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取message参数 String message = req.getParameter(&quot;message&quot;); ServletContext context = getServletContext(); //2.将message设置到ServletContext context.setAttribute(&quot;message&quot;,message); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //3.返回结果 resp.getWriter().write(&quot;设置成功&quot;); &#125;&#125; 创建一个ReaderServlet类 123456789101112@WebServlet(&quot;/reader&quot;)public class ReaderServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.读取ServletContext中的message值 ServletContext context = getServletContext(); String message = (String) context.getAttribute(&quot;message&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //2.返回读到的值 resp.getWriter().write(message); &#125;&#125; 监听器 要想做到一个webapp中只创建一个TemplateEngine对象，除了认识ServletContext，还需要了解监听器。 使用监听器监听ServletContext的创建，创建好后在ServletContext完成初始化操作，后续的 Servlet 直接从 ServletContext 中获取到engine实例即可，不必每创建一个Servlet都初始化一次。 首先创建一个监听器类Mylistener，实现ServletContextListener接口，重写contextInitialized方法。在contextInitialized方法内完成初始化等一系列操作。 1234567891011121314151617181920@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; //1.通过方法的参数可以获取到ServletContext ServletContext context = sce.getServletContext(); //2.创建TemplateEngine类对象engine TemplateEngine engine = new TemplateEngine(); //3.创建解析器 ServletContextTemplateResolver resolver = new ServletContextTemplateResolver(context); //4.加载文件 resolver.setPrefix(&quot;/WEB-INF/templates/&quot;); resolver.setSuffix(&quot;.html&quot;); resolver.setCharacterEncoding(&quot;utf-8&quot;); //5.关联engine和解析器 engine.setTemplateResolver(resolver); //6.将engine放到ServletContext中,后续直接调用getAttribute获取engine context.setAttribute(&quot;engine&quot;,engine); &#125;&#125; 有了MyListener类，之前代码中engine对象的创建和init方法内的初始化操作都可以删掉了。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://youngsay.cn/tags/JavaWeb/"}]},{"title":"【JavaWeb】服务器渲染","slug":"Java-templateEngine","date":"2022-06-09T08:40:41.000Z","updated":"2022-06-09T08:44:46.000Z","comments":true,"path":"2022/06/09/Java-templateEngine/","link":"","permalink":"https://youngsay.cn/2022/06/09/Java-templateEngine/","excerpt":"","text":"页面渲染，所谓渲染就是将数据和页面相结合，根据用户传送的数据不同，页面渲染后的内容也不同。页面渲染可以在服务器端完成，也可以在客户端完成。服务器渲染是将用户传来的数据在服务器端拼接成HTML后传给客户端，而客户端渲染是在客户端将服务器传来的数据拼接成HTML。 服务器渲染 这篇博客主要介绍一下服务器渲染。 我们可以用字符串拼接的方式，将数据拼接成HTML页面。下面我们用字符串拼接的方式完成一个猜数字web版的小游戏。 首先约定好交互方式。 GET /guess 通过get请求，从服务器得到一个页面响应，同时在服务器生成一个1-100的随机数。 POST /guess 通过post请求，将用户输入的数提交到服务器，在服务器比较用户输入的数和随机数的大小，将比较结果和次数返回。 约定好交互方式后，我们创建一个GuessNumServlet类，关联到/guess路径，用doGet方法实现第一个交互接口，doPost方法实现第二个交互接口。代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@WebServlet(&quot;/guess&quot;)public class GuessNumServlet extends HttpServlet &#123; public int num; public int count; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //生成一个随机数 Random random = new Random(); //随机数范围在[1,100] num = random.nextInt(100)+1; //得到一个1-100之间的随机数 //设置响应的类型格式 resp.setContentType(&quot;text/html;charset=utf-8&quot;); //字符串拼接响应页面 StringBuilder html = new StringBuilder(); html.append(&quot;&lt;form action=\\&quot;guess\\&quot; method=\\&quot;post\\&quot;&gt;\\n&quot; + &quot; &lt;input type=\\&quot;text\\&quot; name=\\&quot;guessNum\\&quot;&gt;\\n&quot; + &quot; &lt;input type=\\&quot;submit\\&quot; value=\\&quot;确认输入\\&quot;&gt;\\n&quot; + &quot; &lt;/form&gt;&quot;); //返回响应 resp.getWriter().write(html.toString()); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置响应格式 resp.setContentType(&quot;text/html;charset=utf-8&quot;); //得到用户猜的数字 int guessNum = Integer.parseInt(req.getParameter(&quot;guessNum&quot;)); String result =&quot;&quot;; //比较用户输入的数字和生成的随机数 if(guessNum&lt;num)&#123; result=&quot;猜小了&quot;; &#125;else if(guessNum&gt;num)&#123; result=&quot;猜大了&quot;; &#125;else &#123; result=&quot;猜对了&quot;; &#125; count++; //字符串拼接响应界面 StringBuilder html = new StringBuilder(); html.append(&quot;&lt;form action=\\&quot;guess\\&quot; method=\\&quot;post\\&quot;&gt;\\n&quot; + &quot; &lt;input type=\\&quot;text\\&quot; name=\\&quot;guessNum\\&quot;&gt;\\n&quot; + &quot; &lt;input type=\\&quot;submit\\&quot; value=\\&quot;确认输入\\&quot;&gt;\\n&quot; + &quot; &lt;/form&gt;&quot;); html.append(&quot;&lt;div&gt;&quot;+result+&quot;&lt;/div&gt;&quot;); html.append(&quot;&lt;div&gt;&quot;+&quot;猜的次数：&quot;+count+&quot;&lt;/div&gt;&quot;); //返回响应界面 resp.getWriter().write(html.toString()); &#125;&#125; 通过上段代码，我们发现十分简单的页面拼接起来却如此复杂，代码可读性不高。其实我们有一种更好的方式来完成服务器渲染，那就是模板引擎。 模板引擎 上面的代码Java和HTML代码都混在了一起，模板引擎可以将JAVA和HTML代码分离，将HTML放到单独的文件。HTML中需要变动的部分用占位符占位，当服务器计算响应完毕后，将HTML模板中的占位符替换成计算后的内容，返回给客户端。 Java中有很多模板引擎，这里用的是Thymeleaf 。 如何使用Thymeleaf，我们上面的猜数字小游戏为例，将上段代码改成模板引擎版本。 首先需要引入依赖。 123456&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf --&gt;&lt;dependency&gt;&lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;&lt;artifactId&gt;thymeleaf&lt;/artifactId&gt;&lt;version&gt;3.0.12.RELEASE&lt;/version&gt;&lt;/dependency&gt; 接着创建一个HTML模板，创建路径是webapps/WEB-INF/templates , 12345678&lt;form action=&quot;GuessNum&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;guessNum&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;确认输入&quot;&gt;&lt;/form&gt;&lt;div th:if=&quot;$&#123;!first&#125;&quot;&gt; &lt;div th:text=&quot;$&#123;result&#125;&quot;&gt;&lt;/div&gt; &lt;div th:text=&quot;$&#123;count&#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 有$符号的地方就是一个占位符，最终会被替换成计算好的结果。 最后创建Servlet类：GuessNumTemplateEngine。 创建一个TemplateEngine的类，这个类是服务器渲染的核心类。 初始化模板引擎：创建一个ServletContextTemplateResolver类的解析器，结合ServletContext使用，用来加载要渲染的文件，然后与TemplateEngine相关联。 通过WebContext类将模板文件的变量与Java中的变量相关联。 通过TemplateEngine的process方法完成渲染。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@WebServlet(&quot;/GuessNum&quot;)public class GuessNumTemplateEngine extends HttpServlet &#123; //核心，用于完成页面的渲染 public TemplateEngine engine = new TemplateEngine(); public int randomNum; public int count; public void init() &#123; //对模板引擎初始化 ServletContextTemplateResolver resolver = new ServletContextTemplateResolver(this.getServletContext()); resolver.setPrefix(&quot;/WEB-INF/templates/&quot;); resolver.setSuffix(&quot;.html&quot;); resolver.setCharacterEncoding(&quot;utf-8&quot;); engine.setTemplateResolver(resolver); System.out.println(&quot;初始化完成&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; Random random = new Random(); randomNum = random.nextInt(100)+1; WebContext webContext = new WebContext(req,resp,getServletContext()); webContext.setVariable(&quot;first&quot;,true); resp.setContentType(&quot;text/html;charset=utf-8&quot;); engine.process(&quot;guessNum&quot;,webContext,resp.getWriter()); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html; charset=utf-8&quot;); //1.获取用户输入的数字 int num = Integer.parseInt(req.getParameter(&quot;guessNum&quot;)); String result = &quot;&quot;; // 2. 和 随机数 进行比较 if (num &lt; randomNum) &#123; result = &quot;猜低了&quot;; &#125; else if (num &gt; randomNum) &#123; result = &quot;猜高了&quot;; &#125; else &#123; result = &quot;猜对了&quot;; &#125; // 3. 自增猜的次数 count++; //4.返回响应界面 WebContext context = new WebContext(req,resp,getServletContext()); context.setVariable(&quot;first&quot;,false); context.setVariable(&quot;result&quot;,result); context.setVariable(&quot;count&quot;,count); engine.process(&quot;guessNum&quot;,context,resp.getWriter()); &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://youngsay.cn/tags/JavaWeb/"}]},{"title":"【JavaWeb】Servlet上传文件","slug":"Java-uploadFile","date":"2022-06-08T13:40:41.000Z","updated":"2022-06-08T13:46:46.000Z","comments":true,"path":"2022/06/08/Java-uploadFile/","link":"","permalink":"https://youngsay.cn/2022/06/08/Java-uploadFile/","excerpt":"","text":"Servlet支持上传文件操作，在HttpServletRequest类中，通过Part对象的getPart方法便可以获取请求中指定name的文件。 上传文件分为两个部分，前端部分和后端部分，关于文件操作，这两个部分都很简单，代码量很少。 各文件路径如下： 前端页面：创建一个html文件，通过form表单的action属性，与后端Servlet相关联，method属性指定方法，上传文件通常为post，通过enctype属性指定编码方式，上传文件为multipart/form-data。 1234&lt;form action=&quot;file&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;myFile&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 后端部分：创建一个上传文件的类Upload，继承HttpServlet，@WebServlet()注解内容与前端页面form表单的action路径相同(此处有/)，此外还需要@MultipartConfig注解,缺少该注解将无法正确读取文件。 通过Part对象的getPart()方法获取文件，方法内参数为前端界面input中类型为file格式的name属性值。通过write方法可以将文件写入磁盘，方法内参数为磁盘路径。 1234567891011121314@MultipartConfig@WebServlet(&quot;/file&quot;)public class Upload extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=utf-8&quot;); Part part = req.getPart(&quot;myFile&quot;); System.out.println(part.getContentType()); System.out.println(part.getName()); System.out.println(part.getSize()); part.write(&quot;d:/myFile.png&quot;); resp.getWriter().write(&quot;上传成功&quot;); &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://youngsay.cn/tags/JavaWeb/"}]},{"title":"时间复杂度和空间复杂度","slug":"algorithm-complexity","date":"2022-06-04T13:40:41.000Z","updated":"2022-06-04T14:22:54.000Z","comments":true,"path":"2022/06/04/algorithm-complexity/","link":"","permalink":"https://youngsay.cn/2022/06/04/algorithm-complexity/","excerpt":"","text":"如何衡量一个算法的好坏？我们可以从时间和空间两个方面入手，也就是时间复杂度和空间复杂度。 无论是时间复杂度还是空间复杂度，都采用大O的渐进表示法。只保留最高阶项，且最高阶项的系数为1.例如一个算法的执行次数是2N^2+M+3,那么该算法的时间复杂度是O（N^2)。 时间复杂度 时间复杂度的衡量标准也就是算法的执行次数。我们下面用几段代码来练习一下算法时间复杂度的计算。 冒泡排序的时间复杂度 123456789101112131415void bubbleSort(int[] array) &#123; for (int end = array.length; end &gt; 0; end--) &#123; boolean sorted = true; for (int i = 1; i &lt; end; i++) &#123; if (array[i - 1] &gt; array[i]) &#123; Swap(array, i - 1, i); sorted = false; &#125; &#125; if (sorted == true) &#123; break; &#125; &#125;&#125; 假设有N个元素，最坏的情况下需要走N-1趟，每趟排序end-1次。例如有5个元素，N-5，那么需要走4趟，每趟排列次数分别为4,3,2,1。刚好构成等差数列，可以用等差数列求和公式计算执行次数,也就是[(N*（N-1))]/2。 按照大O的渐进表示法，时间复杂度是O（N^2)。 二分查找的时间复杂度 1234567891011121314int binarySearch(int[] array, int value) &#123; int begin = 0; int end = array.length - 1; while (begin &lt;= end) &#123; int mid = begin + ((end-begin) / 2); if (array[mid] &lt; value) begin = mid + 1; else if (array[mid] &gt; value) end = mid - 1; else return mid; &#125; return -1;&#125; 二份查找的好处是每次能去掉一半，第一次是去掉一半还剩一半，第二次去掉一半还剩1/4，第三次去掉一半还剩1/8……如下图所示： 所以二分查找的时间复杂度是O（logN） 递归求阶乘的时间复杂度 123long factorial(int N) &#123; return N &lt; 2 ? N : factorial(N-1) * N;&#125; 递归算法的时间复杂度 = 递归的次数 * 每次递归执行的次数 递归求阶乘算法递归次数为N，每次递归执行1次，所以时间复杂度是O（N）。 递归求斐波那契数列 123int fibonacci(int N) &#123; return N &lt; 2 ? N : fibonacci(N-1)+fibonacci(N-2);&#125; 递归次数，也就是层数为N的二叉树最多的结点个数，(2^N) - 1。 所以时间复杂度是O（2^N)。 空间复杂度 空间复杂度的衡量标准是临时占用的存储空间大小。随着计算机的发展，存储空间越来越大，空间复杂度也就不必太过关注。 递归求阶乘的空间复杂度 123long factorial(int N) &#123; return N &lt; 2 ? N : factorial(N-1)*N;&#125; 递归了N次，开辟了N个栈帧，每个栈帧占用常数的存储空间，所以该算法的空间复杂度是O（N）。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://youngsay.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"【JavaSE】认识String类","slug":"Java-String","date":"2022-06-03T03:40:41.000Z","updated":"2022-06-08T13:43:18.000Z","comments":true,"path":"2022/06/03/Java-String/","link":"","permalink":"https://youngsay.cn/2022/06/03/Java-String/","excerpt":"","text":"创建一个Sting String有三种构造方法，分别为直接赋值、new String方法构造和字符串数组构造。 1234567//方法1String str1=&quot;hello&quot;;//方法2String str2=new String(&quot;hello&quot;);//方法3char[] arr=&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;String str3=new String(arr); String是一种引用类型，内部并不存储字符串本身。 Sting的存储结构 观察下段代码，输出结果是什么？ 1234567String str1=&quot;hello&quot;;String str11=&quot;hello&quot;;String str2=new String(&quot;hello&quot;);String str22=new String(&quot;hello&quot;);String str3=&quot;world&quot;;System.out.println(str1==str11); //trueSystem.out.println(str2==str22); //false 输出结果分别为true、false。 之所以出现这样的结果，是字符串的存储方式不同。字符串str1和str11这样的创建方式是将数据存放在字符串常量池，在常量池中，同一个数只有一份。字符串常量池在JVM中是StringTable类，实际是一个固定大小的HashTable。str2和str22是将数据存放在堆上，每new一次就会在堆上开辟一块空间。 下面这幅图是String内部存储结构的简单示意图。 总结：String类中两种对象实例化的区别： 直接赋值：只会开辟一块堆内存空间，并且该字符串对象可以自动保存在对象池中以供下次使用。 构造方法：会开辟两块堆内存空间，不会自动保存在对象池中，可以使用intern()方法手工入池。 1String str2=new String(&quot;hello&quot;).intern(); Sting的不可变性 字符串Sting是不可变的，所以每次字符串“+”加号拼接时都会产生一个新的对象，并不是在原对象的基础上拼接。 JDK中，String类由final修饰，value字符数组也由final修饰。 String类被final修饰，表明该类不能被继承。 value被修饰被final修饰，只是表明不能再引用其他数组，但是引用空间中的值仍能被修改。 所以，final并不是String对象不可变的原因。 如何理解 String 类型值的不可变？ https://www.zhihu.com/question/20618891/answer/114125846 String对象不可变，使用加号进行字符串拼接效率是很低的，每次都会创建一个新对象，中间还会有很多临时变量。可以使用StringBuffer和StingBuilder来进行字符串的修改。 StringBuffer和StringBuilder String、StringBuffer、StringBuilder的区别: String的内容不可修改，StringBuffer与StringBuilder的内容可以修改. StringBuffer与StringBuilder大部分功能是相似的。StringBuffer采用同步处理，属于线程安全操作；而StringBuilder未采用同步处理，属于线程不安全操作。 12345678910111213//字符串拼接String str=&quot;panghu&quot;;String str1 = str + &quot;tx&quot;;//字符串拼接StringBuffer sb = new StringBuffer(&quot;panghu&quot;);sb.append(&quot;tx&quot;);//转化//String----&gt;StringBufferStringBuffer sb1=new StringBuffer();System.out.println(sb1.append(str));//StringBuffer---&gt;StringString ss= sb.toString();System.out.println(ss);","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】抽象类和接口","slug":"Java-abstractClass-interface","date":"2022-05-24T09:40:41.000Z","updated":"2022-06-08T13:43:26.000Z","comments":true,"path":"2022/05/24/Java-abstractClass-interface/","link":"","permalink":"https://youngsay.cn/2022/05/24/Java-abstractClass-interface/","excerpt":"","text":"抽象类 什么是抽象类 被abstract修饰的类就是抽象类。抽象类是类的进一步抽象，抽象类中的方法可以不做具体的实现（抽象方法，由abstract修饰）。抽象类中也可以有普通方法。 抽象方法不能由static和final修饰，因为抽象方法要被子类重写。 抽象类中不一定要有抽象方法，但是有抽象方法的类一定是抽象类。 抽象类不能实例化，但可以引用其子类对象。 123456789101112131415161718192021222324252627282930abstract class Animal &#123; public String name; //抽象类中也可以有构造方法，也可以有普通方法、属性 public Animal(String name) &#123; this.name = name; &#125; //抽象方法，不做具体实现 public abstract void eat();&#125;class Dog extends Animal &#123; public Dog(String name) &#123; super(name); &#125; @Override public void eat() &#123; System.out.println(this.name+&quot;正在吃狗粮&quot;); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; //抽象类不能实例化，但可以引用其子类对象。 Animal animal = new Dog(&quot;旺旺&quot;); //子类重写eat方法 animal.eat(); &#125; &#125; 执行结果：旺旺正在吃狗粮 为什么需要抽象类 抽象类中的方法可以不做具体实现，为了子类能够继承该抽象类。使用抽象类能够多一层编译器校验，增加了安全性。就像常量用final修饰，不小心修改时编译器会报错提醒。 像上面的代码main方法中new Dog改成new Animal，编译器就会报错：‘Animal’ is abstract; cannot be instantiated。 接口 什么是接口 接口是多个类的公共规范，是一种引用数据类型。接口可以理解为一种功能、特性，类实现某个接口，便可以具备某种功能。 接口中的方法默认是由public abstract修饰，接口中的属性默认是public final static。建议接口中的方法和属性不加任何修饰符号, 保持代码的简洁性. 接口不能实例化。 接口中不能有静态代码块和构造方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263interface Running&#123; void run(); //方法不加修饰符，默认为public abstract void run()&#125;interface Flying&#123; void fly();&#125;abstract class Animal &#123; public String name; //抽象类中也可以有构造方法 public Animal(String name) &#123; this.name = name; &#125; //抽象方法，不做具体实现 public abstract void eat();&#125;class Dog extends Animal implements Running &#123; public Dog(String name) &#123; super(name); &#125; @Override public void eat() &#123; System.out.println(this.name+&quot;正在吃狗粮&quot;); &#125; //实现接口中的run方法，必须为public，因为接口中的run方法是public，重写时要分配更高的访问权限 @Override public void run() &#123; System.out.println(this.name+&quot;正在扑向他的主人&quot;); &#125;&#125;class Bird extends Animal implements Flying&#123; //继承父类，需要重写父类的构造方法 public Bird(String name) &#123; super(name); &#125; //重写父类的抽象方法 @Override public void eat() &#123; System.out.println(this.name+&quot;正在觅食&quot;); &#125; //实现接口，必须实现接口的抽象方法，否则类需设置为抽象类 @Override public void fly() &#123; System.out.println(this.name+&quot;正在天空中自由地翱翔&quot;); &#125;&#125;public class Demo1 &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;旺旺&quot;); dog.eat(); dog.run(); Bird bird = new Bird(&quot;飞儿&quot;); bird.eat(); bird.fly(); &#125;&#125; 执行结果： 旺旺正在吃狗粮 旺旺正在扑向他的主人 飞儿正在觅食 飞儿正在天空中自由地翱翔 为什么需要接口 Java不允许多重继承，通过接口可以提供多重继承的大部分好处，同时还能避免多重继承的复杂性和低效性。 接口的使用实例 Comparable接口 对数组元素按年龄排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;class Student implements Comparable&lt;Student&gt; &#123; public String name; public int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; //重写compareTo方法 @Override public int compareTo(Student o) &#123; // if(this.age&gt;o.age)&#123;// return 1;// &#125;else if(this.age&lt;o.age)&#123;// return -1;// &#125;else &#123;// return 0;// &#125; return this.age-o.age; &#125;&#125;public class Compare &#123; public static void main(String[] args) &#123; Student[] students = new Student[]&#123; new Student(&quot;panghu&quot;,20), new Student(&quot;xiaofu&quot;,18), new Student(&quot;daxiong&quot;,19), new Student(&quot;jingxiang&quot;,16) &#125;; Arrays.sort(students); System.out.println(Arrays.toString(students)); &#125;&#125; 执行结果： [Student{name=‘jingxiang’, age=16}, Student{name=‘xiaofu’, age=18}, Student{name=‘daxiong’, age=19}, Student{name=‘panghu’, age=20}] 上面代码有一个问题，只能按年龄排序，如果想按姓名排序就要修改compareTo方法，修改后又只能按姓名排序。有没有一种办法，可以实现按不同的属性进行排序。利用比较器可以实现该要求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Arrays;import java.util.Comparator;class Student1 &#123; public String name; public int age; public Student1(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125;class AgeComparator implements Comparator&lt;Student1&gt; &#123; @Override public int compare(Student1 o1, Student1 o2) &#123; return o1.age-o2.age; &#125;&#125;class NameComparator implements Comparator&lt;Student1&gt; &#123; @Override public int compare(Student1 o1, Student1 o2) &#123; return o1.name.compareTo(o2.name); &#125;&#125;public class Compare1 &#123; public static void main(String[] args) &#123; Student1[] students = new Student1[]&#123; new Student1(&quot;panghu&quot;,20), new Student1(&quot;xiaofu&quot;,18), new Student1(&quot;daxiong&quot;,19), new Student1(&quot;jingxiang&quot;,16) &#125;; AgeComparator ageComparator = new AgeComparator(); NameComparator nameComparator = new NameComparator(); //按年龄排序 Arrays.sort(students,ageComparator); System.out.println(&quot;按年龄&quot;+Arrays.toString(students)); //按姓名排序 Arrays.sort(students,nameComparator); System.out.println(&quot;按姓名&quot;+Arrays.toString(students)); &#125;&#125; 执行结果： 按年龄[Student{name=‘jingxiang’, age=16}, Student{name=‘xiaofu’, age=18}, Student{name=‘daxiong’, age=19}, Student{name=‘panghu’, age=20}] 按姓名[Student{name=‘daxiong’, age=19}, Student{name=‘jingxiang’, age=16}, Student{name=‘panghu’, age=20}, Student{name=‘xiaofu’, age=18}] Clonable接口 实现Clonable接口需要重写Object类的clone()方法，在方法中使用super关键字调用Object类的clone()方法，然后调用该方法即可实现克隆。 浅拷贝：仅仅拷贝当前对象本身，不拷贝引用类型。 1234567891011121314151617181920212223242526272829303132333435363738class Phone&#123; public String phone;&#125;class Person implements Cloneable&#123; public int age; Phone p = new Phone(); @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &quot;, p.phone=&quot; + p.phone + &#x27;&#125;&#x27;; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Person person = new Person(); person.age=20; person.p.phone=&quot;xiaomi&quot;; Person person2 = (Person)person.clone(); person2.age=10; person2.p.phone=&quot;iphone&quot;; System.out.println(person); System.out.println(person2); &#125;&#125;//运行结果：//Person&#123;age=20, p.phone=iphone&#125;//Person&#123;age=10, p.phone=iphone&#125; 深拷贝：不仅拷贝当前对象，还拷贝其引用类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Phone implements Cloneable&#123; public String phone; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;class Person implements Cloneable&#123; public int age; Phone p = new Phone(); @Override protected Object clone() throws CloneNotSupportedException &#123; Person tmp = (Person) super.clone(); tmp.p= (Phone) this.p.clone(); return tmp; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;age=&quot; + age + &quot;, p.phone=&quot; + p.phone + &#x27;&#125;&#x27;; &#125;&#125;public class Demo1 &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Person person = new Person(); person.age=20; person.p.phone=&quot;xiaomi&quot;; Person person2 = (Person)person.clone(); person2.age=10; person2.p.phone=&quot;iphone&quot;; System.out.println(person); System.out.println(person2); &#125;&#125;//运行结果：//Person&#123;age=20, p.phone=xiaomi&#125;//Person&#123;age=10, p.phone=iphone&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"动态内存分配基本使用及常见问题","slug":"C-malloc","date":"2022-04-09T13:23:41.000Z","updated":"2022-04-09T13:28:26.000Z","comments":true,"path":"2022/04/09/C-malloc/","link":"","permalink":"https://youngsay.cn/2022/04/09/C-malloc/","excerpt":"","text":"为什么需要动态内存管理？创建一个数组，我们要为数组指定大小，int arr[10];，这属于静态创建一个数组，数组arr存放在栈上。这样的创建方式有一些局限性，小了呢不够用，大了呢又浪费空间，因此要引入动态内存管理。 动态创建一个数组，不再受元素个数的限制，当元素个数与容量相等时，可以很方便地扩容。 如何动态内存管理，我们来介绍几个函数。 malloc 1void* malloc (size_t size); 参数size为要为空间开辟的字节数，开辟成功后返回值为该空间的首地址，失败则返回NULL.当size为0时，要看编译器如何处理，具体返回什么不确定。 动态开辟内存后，不需要再使用这块空间时，要使用free函数释放内存。，否则会内存泄漏。free释放后这块内存可以再次被分配，但被释放的空间的值没有被改变，它仍然指向相同（无效）的位置。 free专门用来释放动态分配的空间，如果空间为空，不执行任何操作。切记不可以用free来释放静态分配的内存空间。 12345678910111213141516#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int* p =(int*)malloc(40); //动态开辟10字节的空间 if (p == NULL) &#123; //判断是否开辟成功 perror(&quot;malloc&quot;); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; *(p + i) = i; printf(&quot;%d &quot;, *(p + i)); &#125; free(p); //释放p空间 return 0;&#125; calloc 1void* calloc (size_t num, size_t size); 与malloc相似，但是会在开辟后为空间初始化为0.参数num为要分配的元素数，size为每个元素的大小，总的内存空间为num*size个字节。 与malloc用法一致，不在举例。 realloc 1void* realloc (void* ptr, size_t size); 该函数可以为动态空间扩容，参数ptr为要扩容的空间，size为扩容后的内存大小。 扩容成功返回该空间的首地址，失败返回空，所以为空间扩容时先创建一块临时变量指向该空间，为临时变量扩容，扩容成功再让要扩容的空间等于临时变量，以防扩容失败内容丢失。 扩容会遇到两种情况，1种是该块空间后没有额外的空间来扩容，这时会分配一块新空间，将旧空间的内容移到新空间，返回值自然也是新空间的首地址，2是该块空间空间充足，这就可以在该空间后连续扩容，无需再寻找新的空间。 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int* p = (int*)malloc(40); //动态开辟10字节的空间 if (p == NULL) &#123; //判断是否开辟成功 perror(&quot;malloc&quot;); return; &#125; for (int i = 0; i &lt; 10; i++) &#123; *(p + i) = i; printf(&quot;%d &quot;, *(p + i)); &#125; //扩容 int* tmp=(int*)realloc(p, 80); if (tmp != NULL) &#123; //判断是否扩容成功 p = tmp; &#125; for (int i = 10; i &lt; 20; i++) &#123; *(p + i) = i; printf(&quot;%d &quot;, *(p + i)); &#125; free(p); return 0;&#125; 输出结果为0~19，扩容成功。 问题 了解了动态内存分配函数的一些基础使用后，我们来看一些常见的问题。 代码1:这段代码有什么问题？ 1234567891011void GetMemory(char *p)&#123;p = (char *)malloc(100);&#125;void Test(void)&#123;char *str = NULL;GetMemory(str);strcpy(str, &quot;hello world&quot;);printf(str);&#125; p是一个局部变量，是实参的一份临时拷贝，出了GetMemory函数会自动销毁。我们为p开辟了100个字节的空间，出了函数后p销毁，找不到这块空间的首地址，却没对该空间进行内存释放，会造成内存泄漏。 此外str仍是空指针，将“hello world”拷贝到一块空指针，会造成非法访问，程序崩溃。 我们可以试着修改，将传值调用改成传址调用，这样p和str指向了同一块空间，最后别忘了free释放内存。 123456789101112void GetMemory(char *p)&#123;p = (char *)malloc(100);&#125;void Test(void)&#123;char *str = NULL;GetMemory(&amp;str); //传地址strcpy(str, &quot;hello world&quot;);printf(str);free(str); //别忘了释放哦~&#125; 代码2： 1234567891011char *GetMemory(void)&#123;char p[] = &quot;hello world&quot;;return p;&#125;void Test(void)&#123;char *str = NULL;str = GetMemory();printf(str);&#125; p是一个局部变量，是实参的一份临时拷贝，return p返回的是局部变量p的首地址，str收到了这个地址。不巧的是出了GetMemory函数p这块地址就还给了操作系统，所以str找不到这块地址，造成了野指针。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"C语言的结构体及内存对齐","slug":"C-struct","date":"2022-03-31T11:00:41.000Z","updated":"2022-04-02T01:47:16.000Z","comments":true,"path":"2022/03/31/C-struct/","link":"","permalink":"https://youngsay.cn/2022/03/31/C-struct/","excerpt":"","text":"结构体基础 结构体就是一些成员的集合，结构体的每一个成员可以是整型、数组、指针、结构体等不同的类型。 下面是一个简单的结构体结构，包含了类型声明struct Stu、成员、结构体变量s1的声明。 123456struct Stu &#123; //类型 //成员 char name[20]; int age; char sex[10];&#125;s1; //结构体变量 我们可以像上面那样声明一个结构体变量，也可以像下面这样单独声明。 1struct Stu s2; struct是结构体关键字，Stu是结构体标志，两者构成了结构体类型。上面的语句表示为struct Stu类型的结构体声明了一个变量s1。下面是对s1的赋值操作，可以在声明结构体变量的时候直接赋值。 1struct Stu s1 = &#123; &quot;panghutx&quot;,20,&quot;male&quot; &#125;; 在声明结构体时，我们可以对结构体不完全声明。 12345678910struct&#123; int a; char b; double c; &#125; a;struct&#123; int a; char b; double c; &#125; *P; 以上就不完全声明了两个结构体，我们称之为匿名结构体类型。结构体变量a和*p具有相同的成员，但它们是两个完全不同的类型。当我们尝试如下代码时，会出现警告。 1*p = &amp;a; 说到结构体，我们难免提到一个关键字typedef,用于定义新的类型（或类型重命名）。我们在学习链表时可能会看到这样的结构，下面这段代码是对struct Node重命名为Node.而且还在结构体中引用了自己。 12345typedef struct Node&#123;int data;Node* next;&#125;Node; 切记在结构体自引用时不要使用匿名结构体，否则就是在定义新类型的时候引用了新类型，这是错误的。 再看下面的写法，定义了两个新类型，Node和*pNode，Node我们已经知道是对struct Node进行重命名，而*pNode是对struct Node*的重命名。 12345typedef struct Node&#123;int data;Node* next;&#125;Node,*pNode; 结构体内存对齐 结构体的大小不是单纯的各元素相加，因为主流计算机使用的是32bit字长的CPU，那么取4个字节数要比1个高效，所以结构体存在内存对齐。每个编译器都有自己的对齐系数，程序员也可以通过预编译命令来改变默认对齐数。 1#pragma pack(n) //n为修改的对齐系数 对齐规则： ①首个成员放在0ffset（偏移量）为0的位置，其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 ②结构体总大小为各元素最大对齐数的整数倍。 举个例子，计算下面结构体的大小是多少。 123456struct S1&#123;char c1;int i;char c2;&#125;; 假设编译环境默认4字节对齐。 c1是结构体首个元素，直接放到偏移量为0的位置，占1个字节；i自身大小为4字节，默认对齐4字节，因此对齐数就是四字节，将其放到对齐数整数倍的位置，也就是4偏移量的位置。c2自身大小1字节，默认对齐数4，因此对齐数是1，将其放到对齐数整数倍的位置，也就是int的后面。 0~8偏移量，那么该结构体为9个字节，对吗？别忘了规则②，结构体总大小是各元素最大对齐数的整数倍。结构体内最大对齐数的元素是int，对齐数是4，9不是4的整数倍，再开辟3个字节。 综上该结构体大小为12字节。 结构体位段 c语言允许在一个结构体中以位为单位来指定成员长度，利用位段能够节约空间。 1234567struct A&#123;int _a:2;int _b:5;int _c:10;int _d:30;&#125;; A就是1个位段，它的大小为8个字节，想知道为什么是8个字节，要知道它的内存分配。 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段 调试下面代码，我们可以看一下空间是如何开辟的。 123456789101112struct S&#123;char a:3;char b:4;char c:5;char d:4;&#125;;struct S s = &#123;0&#125;;s.a = 10;s.b = 12;s.c = 3;s.d = 4; 我在vs2019环境下调试，和vs2013结果一样。先开辟一字节，从低位开始存数据，存不下时舍弃剩余位，再开辟一字节空间。 以上存储方式只能代表vs环境下，其他环境不确定。要知道，位段的内存分配与内存对齐的实现方式依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"常用的字符串处理函数","slug":"C-string","date":"2022-03-28T08:31:01.000Z","updated":"2022-03-28T08:42:50.000Z","comments":true,"path":"2022/03/28/C-string/","link":"","permalink":"https://youngsay.cn/2022/03/28/C-string/","excerpt":"","text":"字符串处理类 strlen 简单介绍 size_t strlen ( const char * str ); Geting string length. 参数：str，返回值：字符串长度 字符串以\\0作为结束标志，返回\\0之前的字符个数。返回值是size_t（无符号）。 模拟实现 123456789101112131415161718192021222324//方法1：计时器int My_strlen1(char* ps) &#123; int count = 0; while (*ps) &#123; count++; ps++; &#125; return count;&#125;//方法2：指针相减int My_strlen2(char* ps) &#123; char* start = ps; while (*ps) &#123; ps++; &#125; return ps - start;&#125;//方法3：递归int My_strlen3(char* ps) &#123; if (*ps == &#x27;\\0&#x27;) return 0; else return 1+My_strlen3(ps+1);&#125; strcpy 简单介绍 char * strcpy ( char * destination, const char * source ); Copies the C string pointed by source into the array pointed by destination, including the terminating null character (and stopping at that point). 以\\0结束，且将\\0拷贝到目标空间 模拟实现 123456789101112131415161718char* My_strcpy(char* des, char* src) &#123; char* rst = des; while (*src) &#123; *des = *src; des++; src++; &#125; *des = *src; return rst;&#125;//改进char* My_strcpy1(char* des, char* src) &#123; char* rst = des; while (*des++ = *src++) &#123; ; &#125; return rst;&#125; strcat 简单介绍 char * strcat ( char * destination, const char * source ); Concatenate strings. 模拟实现 123456789101112char* My_strcat(char* des, char* src) &#123; char* ret = des; //找到des的&#x27;\\0&#x27; while (*des) &#123; des++; &#125; //字符串拷贝 while (*des++ = *src++) &#123; ; &#125; return ret;&#125; strcmp 简单介绍 int strcmp ( const char * str1, const char * str2 ); Compare two strings. 模拟实现 123456789101112131415int My_strcmp(const char* str1, const char* str2) &#123; while (*str1 == *str2) &#123; if (*str1 == &#x27;\\0&#x27;) &#123; return 0; &#125; str1++; str2++; &#125; if (*str1 &gt; *str2) &#123; return 1; &#125; else&#123; return -1; &#125;&#125; strstr 简单介绍 const char * strstr ( const char * str1, const char * str2 ); 模拟实现 12345678910111213141516171819const char* My_strstr(const char* str1, const char* str2) &#123; const char* ps1 = str1; const char* ps2 = str2; const char* cur = str1; while (*ps1) &#123; ps1 = cur; while (*ps1 == *ps2 &amp;&amp; *ps1 &amp;&amp; *ps2) &#123; ps1++; ps2++; &#125; if (*ps2 == &#x27;\\0&#x27;) &#123; return cur; &#125; cur++; ps2 = str2; &#125; return NULL;&#125;//*ps1和*ps2不相等时，要重新找ps2在ps1中的位置，ps2复原，ps1继续找下一位（也就是cur的下一位）。 内存操作类 memcpy 简单介绍 void * memcpy ( void * destination, const void * source, size_t num ); Copy block of memory. 模拟实现 123456789void* My_memcpy(void* des, void* src, size_t count) &#123; void* ret = des; while (count--) &#123; *(char*)des = *(char*)src; des = (char*)des + 1; src = (char*)src + 1; &#125; return ret;&#125; memmove 简单介绍 void * memmove ( void * destination, const void * source, size_t num ); Move block of memory,allowing the destination and source to overlap. 模拟实现 1234567891011121314151617181920void* My_memmove(void* des, void* src, size_t count) &#123; if (des &lt; src) &#123; //从前向后拷贝 while (count--) &#123; *(char*)des = *(char*)src; des = (char*)des + 1; src = (char*)src + 1; &#125; &#125; else &#123; //从后向前拷贝 des = (char*)des + count - 1; src = (char*)src + count - 1; while (count--) &#123; *(char*)des = *(char*)src; des = (char*)des - 1; src = (char*)src - 1; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"c语言操作符练习总结","slug":"C-operator2","date":"2022-03-07T02:49:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2022/03/07/C-operator2/","link":"","permalink":"https://youngsay.cn/2022/03/07/C-operator2/","excerpt":"","text":"sizeof()的坑🕳 123456789101112131415#include &lt;stdio.h&gt;int i;int main()&#123; i--; if (i &gt; sizeof(i)) &#123; printf(&quot;&gt;\\n&quot;); &#125; else &#123; printf(&quot;&lt;\\n&quot;); &#125; return 0; &#125; 观察上端代码，思考一下输出结果是什么？ 首先定义了一个全局变量，全局变量没有赋值，默认值为0；然后i–；i变成了-1.你也许会说sizeof(-1),-1是int类型的，占4个字节，-1&lt;4,结果不就是&lt;吗！其实不然，结果是&gt;,-1大于4？数学是体育老师教的！ 原因在于sizeof()的返回值是无符号整型，也就是unsigned int，两数比较时，编译器会将左侧的值也转换成无符号整数，-1在内存中存储的是全1，即11111111111111111111111111111111，无符号嘛，会认为这是一个很大的数，所以最后输出了&gt;. 所以当一个数与sizeof()直接比较时，就要小心咯，可能会有意想不到的结果。 运算符优先级 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a, b, c; a = 5; c = ++a; b = ++c, c++, ++a, a++; b += a++ + c; printf(&quot;a = %d b = %d c = %d\\n:&quot;, a, b, c); return 0;&#125; 观察上段代码，输出结果是什么?很烦这种代码，虽然没什么意义，但既然错了，还是记录下吧。主要考察操作符的优先级和结合性。主要说两点，一是逗号表达式的优先级最低，所以b= ++c , c++ , ++a , a++;先算b=++a，然后再算逗号后面的操作。二是+=操作符的优先级也很低，所以在b += a++ + c中先计算a++ +c,再将结果加上b后赋值给b。 二进制中1的个数 求二进制中1的个数，有很多方法。 方法一：利用按位与&amp;和移位&gt;&gt;运算符。一个数按位与&amp;1，可以求得这个数二进制的最低位。只求最低位哪行啊，我要的是所有位上1的个数，结合移位运算符，(n&gt;&gt;1)&amp;1,得到的就是第二位，(n&gt;&gt;2)&amp;1,得到的就是第三位，一直到31，得到一次加一次，就得到了二进制中所有的1. 1234567891011int main()&#123; int n = 0; int i = 0; int count = 0; scanf(&quot;%d&quot;,&amp;n); for (i = 0; i &lt; 32; i++) &#123; if ((n &gt;&gt; i) &amp; 1) count++; &#125; printf(&quot;%d&quot;, count);&#125; 方法二：利用%和/运算符，比如1987，1987%10，得到了后一位7，1987/10%10，得到了8，1987/100%10，得到了9，1987%1000/10，得到了1。十进制/10%10，二进制自然就/2%2。值得注意的是数的类型要定义为unsigned int，否则该方法只适用于正整数。 12345678910111213141516int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); int count = 0; unsigned int tmp = n; while (tmp) &#123; if (tmp % 2) &#123; count++; &#125; tmp = tmp / 2; &#125; printf(&quot;%d&quot;, count);&#125; 方法三：利用表达式n=n&amp;(n-1),计算表达式执行的次数，n为0时结束循环。如下图所示： 1234567891011int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); int count = 0; while (n) &#123; n = n &amp; (n - 1); count++; &#125; printf(&quot;%d&quot;, count);&#125; 两个数二进制不同位的个数 有了上道题的基础，这道题就迎刃而解了。 思路一：默认最低位是第0位，n&gt;&gt;i&amp;1可以求得第i位的二进制数，如果两数不等，计数器加一即可。 123456789101112int main()&#123; int a = 0; int b = 0; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); int i = 0; int count = 0; for (i = 0; i &lt; 32; i++) &#123; if ((a &gt;&gt; i &amp; 1) != (b &gt;&gt; i &amp; 1)) count++; &#125; printf(&quot;%d&quot;, count);&#125; 思路二：利用异或^运算符，两数异或，相同位为0，不同位为1。对异或后的数求二进制中1的个数，便得到了二进制中不同位的个数。 123456789101112131415int main()&#123; int a = 0; int b = 0; scanf_s(&quot;%d %d&quot;, &amp;a, &amp;b); //1.两数异或 int c = a ^ b; int count = 0; //2.求二进制中1d while (c) &#123; c = c &amp; (c - 1); count++; &#125; printf(&quot;%d&quot;, count);&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"浮点数在内存中的存储","slug":"C-IEEE754","date":"2022-03-04T03:31:01.000Z","updated":"2022-03-31T06:27:30.000Z","comments":true,"path":"2022/03/04/C-IEEE754/","link":"","permalink":"https://youngsay.cn/2022/03/04/C-IEEE754/","excerpt":"","text":"观察下面的代码，输出结果是什么呢？ 1234567891011int main()&#123;int n = 9;float *pFloat = (float *)&amp;n;printf(&quot;n的值为：%d\\n&quot;,n);printf(&quot;*pFloat的值为：%f\\n&quot;,*pFloat);*pFloat = 9.0;printf(&quot;num的值为：%d\\n&quot;,n);printf(&quot;*pFloat的值为：%f\\n&quot;,*pFloat);return 0;&#125; 以整数存储，以整数取出，结果相同；以浮点数存储，以浮点数取出，结果也相同。 以整数存储，以浮点数取出，结果不同；以浮点数存储，以整数取出，结果也不同。 由此可见，整数和浮点数在内存中的存储是不同的。 下面我们看一下浮点数的存储规则，浮点数在内存中的表示是由IEEE（电气与电子工程协会）规定好的。 任何一个二进制浮点数，可以表示成 (-1)^S表示符号位，s为0浮点数是正数，s为-1浮点数是负数；M表示有效数字，范围在[1,2);2^E表示指数位。 这样看很难理解，我们举例说明。 float a = -5.0f，浮点数-5.0，用二进制表示为-101.0，写成科学计数法的形式：-1.010*2^2，s=1，M=1.010，E=2 表示好之后，我们将它存入内存。IEEE 754规定，对于32位的单精度浮点数，最高位是符号位S，占1位，然后是指数位E，占8位，最后是有效数字M，占23位；对于双精度浮点数，占位分别为1，11，52，我们这里主要介绍float的存储。 ![单精度浮点数在内存中的存储]( 关于存储，E和M有一些特殊规定： M范围是[1，2），所以保存时干脆省略1，比如-5.0的M是1.010，保存时直接写成010，后面再加20个0，凑够23位。即01000000000000000000. E是无符号整数，但科学计数法E可能有负数，所以存入内存时，8位E加上127，11位E加上1023加以修正，比如-5.0的E是2，保存时加上127就是129，即10000001. 所以浮点数-5.0在内存中的存储是11000000101000000000000000000，用16进制表示就是0xc0a00000 以上是关于浮点数存储的规则，下面是从内存中取出的规则。如何取出，分3种情况，全看E。 ①E不全为0或不全为1时，怎样存储的，就怎样取出。存储时M省略了1，取出是再加上1，存储时E加了127修正，取出时再减去127。 ②E全为0，E=1-127=-126，M不再加上1，而是还原成0.xxxxx； ③E全为1，这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s） 关于E取出的规则，简单了解下就好。 我们了解了IEEE标准之后，知道了浮点数在内存中的存储规则，下面来看一下上面那段代码。 第一个printf语句打印的是整数，整数存储，整数打印，结果当然是9； 第二个printf语句是以浮点数打印，结果是0.000000，以整数存储，以浮点数取出，结果必然不同。9以整数存储，二进制就是00000000000000000000000000001001，S=0，E=00000000，M=00000000000000000001001，以浮点数取出，因为E全为0，所以取出时E=1-127=-126，M忽略1，还原成0.00000000000000000001001，所以结果就是(-1)^0 * 0.00000000000000000001001 * 2^-126,也就是0.000000. 第三个printf语句是以整数打印，以浮点数存储，以整数取出，结果必然不同。9.0以浮点数存储，二进制就是1001.0，科学计数法表示为1.0010*2^3,其中S=1，E=3，M=1.0010，根据存储规则，存入内存中时，E=3+127=130，即10000010，M忽略1，结果为0010，凑够23位，即00100000000000000000000，占位比S:E:M=1:8:23,最终结果是01000001000100000000000000000000。以浮点数存储后，以整型打印，会将其视为整数，最高位是符号位0，正数原码反码补码一样，最终结果是1,091,567,616 第四个printf语句打印的是浮点数，以浮点数存储，以浮点数打印，结果是9.0； 好了，说了这么多，一言以蔽之：整数和浮点数在内存中的存储规则不同，导致输出结果不同。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"倒置字符串，我爱中国，中国爱我。","slug":"C-reverse","date":"2022-02-28T02:31:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2022/02/28/C-reverse/","link":"","permalink":"https://youngsay.cn/2022/02/28/C-reverse/","excerpt":"","text":"描述：将一句话的单词进行倒置，标点不倒置。比如 I like China. 经过函数后变为：China. like I 有些时候，主语和宾语位置互换词义不会改变。比如，一件衣服穿两天，两天穿一件衣服。北京是首都，首都是北京。如果你已经读完了这段话，恭喜你已经浪费了几秒钟，这和这道编程题没什么关系…… 思路：我们可以两次使用字符串逆序，第一次先将字符串整体逆序，第二次将单个单词再逆序。逆序字符串，无非是找到字符串的起始位置和结束位置，也就是左下标和右下标，当左下标地址小于右下标地址时，互换两个下标位置的字符串。关键在于寻找起始位置和结束位置，例如字符串arr，第一次字符串整体逆序，起始位置就是字符串的首地址arr，结束位置就是起始位置+字符串长度-1.第二次逆序每个单词，起始位置就是每个单词的起始位置，结束位置是空格或字符串0的前一位置。逆序每个单词要注意何时进行逆序，遍历整个字符串，当arr[i]的元素为空格或字符串0时，进行单词的逆序。 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;string.h&gt;void reverse(char* start, char* end)&#123; char tmp; while (start &lt; end) &#123; tmp = *start; *start = *end; *end = tmp; start++; end--; &#125;&#125;int main()&#123; char arr[100] = &#123; 0 &#125;; gets(arr); int len = strlen(arr); int i = 0; //先将字符串整体翻转 reverse(arr, arr + len - 1); char* a = arr; for (i = 0; i &lt;=len; i++) &#123; if (arr[i] == &#x27; &#x27; || arr[i] == &#x27;\\0&#x27;) &#123; reverse(a, arr + i-1);//空格之前的再一次翻转，两次翻转正好 a = (arr + i + 1); &#125; &#125; printf(&quot;%s&quot;, arr); return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"多种方法求两个正整数的最大公约数和最小公倍数","slug":"C-LCM","date":"2022-02-27T10:31:01.000Z","updated":"2022-02-27T10:33:34.000Z","comments":true,"path":"2022/02/27/C-LCM/","link":"","permalink":"https://youngsay.cn/2022/02/27/C-LCM/","excerpt":"","text":"鲁迅说过：“求解最大公约数和最小公倍数有很多方法”，公约数，就是几个数共有的约数，最大公约数，就是公约数中最大的那个数，公倍数，就是几个数共有的倍数，最小公倍数，就是公倍数中最小的那个数。虽然看起来是句废话，其实它就是废话……下面我们看一下求解最大公约数和最小公倍数的几种方法。 求任意两个正整数的最大公约数 最大公约数（Greatest Common Divisor，GCD），先说约数，a能被b整除，b就是a的约数，几个数共有的约数就是这几个数的公约数，公约数中最大的那个数就是最大公约数。举个例子，4和20的公约数有1，2，4，最大公约数是4。可见两个数的最大公约数必不大于两数中最小的那个。 思路一：如果求出最大公约数，穷举法从小到大（从1到两数中较小的一个）遍历，然后输出最大的那个，这样做比较麻烦，不妨我们从大到小（从两数中较小的一个到1）遍历，第一个能同时整除两个数的那个即为所求。 123456789101112131415161718192021222324int main()&#123; int a = 0; int b = 0; int tmp = 0; int i = 0; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); //a中存储较大的那个数，b存储小数，当a&lt;b时交换两数 if (a &lt; b) &#123; tmp = a; a = b; b = tmp; &#125; //从b到1遍历，找最大公约数 for (i = b; i &gt; 1; i--) &#123; //同时整除两个数的那个数即为所求，找到后break结束遍历 if (a % i == 0 &amp;&amp; b % i == 0) &#123; break; &#125; &#125; printf(&quot;%d&quot;, i); return 0; &#125; 思路二：我们可以用辗转相除法求最大公约数，例如15和20两个数，15%20=15，20%15=5，15%5=0，两数相除，将除数当作下个算式的被除数，余数当作除数，如此往复，当余数为0时，最后一个算式的除数5就是15和20的最大公约数。我可能说的有些复杂了，看代码就懂了，还有这一思路的妙处是不用判断两数的大小。 123456789101112131415int main()&#123; int a = 0; int b = 0; int c = b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); //辗转相除，余数为0跳出循环 while (a % b != 0) &#123; c = a % b; a = b; b = c; &#125; printf(&quot;%d&quot;, b);&#125; 求任意两个正整数的最小公倍数 最小公倍数（Least Common Multiple，LCM），若a能被b整除，a就是b的倍数，对于两个整数来说，两数共有倍数中最小的一个便是最小公倍数。 思路一：我们可以借助最大公约数求最小公倍数。两数乘积除以最大公约数便是最小公倍数。若a和b的最大公约数是c，那么最小公倍数便是a*b/c，最大公约数的求法如上，这一思路这里不再列出代码。 思路二：两个数的最小公倍数就是能被两数整除的那个最小的数（废话文学），如果较大的数能被较小的数整除，那么较大的数就是两数的最小公倍数，否则要从较大的数开始，一次向上遍历，知道找出能同时被两数整除的那个数。举个例子，5和25，25能被5整除，25就是5和25的最小公倍数；5和7，较大的数7不能被5整除，7一直加1，变成8，9，10……，35，知道35，35能被5和7整除，35便是5和7的最小公倍数。废话有点多了，上代码。 1234567891011121314151617181920212223int main()&#123; int a = 0; int b = 0; int tmp = 0; int i = 0; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); //a存放两数中较大的那个，b存放小数 if (a &lt; b) &#123; tmp = a; a = b; b = tmp; &#125; //从最大数开始向上计数 for (i = a; i &gt; 0; i++) &#123; //找出最小公倍数，退出循环 if (i % a == 0 &amp;&amp; i % b == 0) &#123; break; &#125; &#125; printf(&quot;%d&quot;, i);&#125; 思路三：众所周知，5和7的最小公倍数是35，35能被5和7同时整除（又是一句废话），看下面这个算式：5*i%7=0，5*i的结果既能被5整除，也能被7整除，所以5*i便是5和7的最小公倍数。 123456789101112int main()&#123; int a = 0; int b = 0; int i = 1; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); while (a * i % b) &#123; i++; &#125; printf(&quot;%d&quot;, a * i); return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"Visual Studio环境下一段有趣的代码","slug":"C-Traps-Pitfalls","date":"2022-02-26T13:00:41.000Z","updated":"2022-02-26T13:28:20.000Z","comments":true,"path":"2022/02/26/C-Traps-Pitfalls/","link":"","permalink":"https://youngsay.cn/2022/02/26/C-Traps-Pitfalls/","excerpt":"","text":"1234567891011int main()&#123; int i = 0; int arr[10] = &#123; 0 &#125;; for (i = 0; i &lt;= 12; i++) &#123; arr[i] = 0; printf(&quot;youngsay.cn\\n&quot;); &#125; return 0;&#125; 观察这段代码，运行会有何效果？ 你可能会说，既然越界访问了，那不就报错了？其实不然，运行发现，程序没有报错，一直死循环。 注意：该段代码依赖环境，vs编译器，debug模式，x86平台下才有这样的效果。 为什么陷入了死循环，这要从栈区的使用习惯开始说起。静态变量，函数形参都存放到栈中，而栈是从高地址开始存放。**栈区的使用习惯是先使用高地址处的空间。**我们还知道，**数组随着下标变大，地址是由低到高变化的。**所以上段代码在栈中的内存布局，如下图所示。 vs编译器，debug模式，x86平台下，i和数组arr间刚好空了2个下标的空间。所以i和arr[12]指向了同一块地址，不信我们可以调试看一下i和arr[12]的地址。 当i自增到12，执行arr[12]=0时，因为共用同一块空间，i也变成了0，0&lt;12,再一次进入了循环，如此往复便陷入了死循环。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"C语言实现简单的扫雷游戏","slug":"sweep-mine","date":"2022-02-09T10:22:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2022/02/09/sweep-mine/","link":"","permalink":"https://youngsay.cn/2022/02/09/sweep-mine/","excerpt":"","text":"《扫雷》是一款大众类的益智小游戏，游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。 这篇博客教大家用C语言制作一个简易版扫雷游戏，和之前的井字棋大同小异。 我们准备三个文件,分别为game.c,test.c,game.h game.c文件用来写实现游戏功能的各个函数代码,test.c文件写游戏的总流程,game.h文件用来声明函数和初始值. 先看test.c，由menu()``game()``main()三个函数组成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&quot;game.h&quot;menu()&#123; printf(&quot;--------------------\\n&quot;); printf(&quot;-----1.开始游戏-----\\n&quot;); printf(&quot;-----2.退出游戏-----\\n&quot;); printf(&quot;--------------------\\n&quot;);&#125;game()&#123; //棋盘——后台 char mine[ROWS][COLS] = &#123; 0 &#125;; //棋盘——玩家 char show[ROWS][COLS] = &#123; 0 &#125;; //初始化棋盘 init_arr(mine, ROWS, COLS,&#x27;0&#x27;); init_arr(show, ROWS, COLS, &#x27;*&#x27;); //打印棋盘 display_arr(show, ROW, COL); //display_arr(mine, ROW, COL); //放炸弹 set_mine(mine, ROW, COL); //排雷 set_coordinate(mine, show, ROW, COL); &#125;int main()&#123; srand((unsigned int)time(NULL)); int input = 0; do &#123; menu(); printf(&quot;请输入选项&gt;\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case 1: game(); break; case 2: printf(&quot;退出游戏\\n&quot;); break; default: printf(&quot;输入错误，请重新输入\\n&quot;); break; &#125; &#125; while (1);&#125; 下面是game.h头文件,文件内是头文件的引用,数据的初始化,游戏函数的定义 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROWS 11#define COLS 11#define ROW 9#define COL 9#define MINE 10//初始化棋盘void init_arr(char arr[ROWS][COLS], int rows, int cols,char set);//打印棋盘void display_arr(char arr[ROWS][COLS], int row, int col);//放炸弹void set_mine(char arr[ROWS][COLS], int row, int col);//排雷void set_coordinate(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col); 我们定义了两个棋盘，一个用来放雷（玩家看不到），一个用来展示玩家选定的位置四周的地雷数。如果是9x9的棋盘，当玩家选择边界位置（如1 1），程序检索其四周的地雷会造成越界访问，所以将棋盘做成11x11，但只打印9x9给玩家。 下面是game.c文件，我们来看下各个函数是如何实现的。 首先是初始化棋盘init_arr 12345678910void init_arr(char arr[ROWS][COLS], int rows, int cols,char set)&#123; int i = 0; int j = 0; for (i = 0; i &lt; rows; i++) &#123; for (j = 0; j &lt; cols; j++) &#123; arr[i][j] = set; &#125; &#125;&#125; 形参有4个，分别是棋盘，行数，列数，放置的元素。便利整个棋盘，将棋盘初始化。mine棋盘初始化为0，表示不是地雷，1表示地雷；show棋盘初始化为*，展示给玩家。 接着是打印棋盘display_arr 12345678910111213141516171819void display_arr(char arr[ROWS][COLS], int row, int col)&#123; int i = 0; int j = 0; //打印一个列号【列号就是单独的一行】 for (i = 0; i &lt;= row; i++) &#123; printf(&quot;%d &quot;, i); &#125; printf(&quot;\\n&quot;); for (i = 1; i &lt;= row; i++) &#123; //打印一个行号【行号就是单独的一列】 printf(&quot;%d &quot;, i); for (j = 1; j &lt;= col; j++) &#123; printf(&quot;%c &quot;, arr[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 传入的参数的棋盘，行数，列数，注意这里的行数列数都是9，与初始化不同。为了方便玩家操作，我们在棋盘上标上对应的行数和列数，如下图所示。 接下来布置地雷set_mine 123456789101112131415void set_mine(char arr[ROWS][COLS], int row, int col)&#123; int x = 0; int y = 0; int count = 0; while ( count &lt; MINE) &#123; x = rand() % row + 1; y = rand() % col + 1; if (arr[x][y] == &#x27;0&#x27;) &#123; arr[x][y] = &#x27;1&#x27;; count++; &#125; &#125;&#125; MINE是10，当count&lt;10,生成1-9的随机数，如果坐标位置是0，将该位置置为地雷，count++，直到地雷数为10。 最后是排雷set_coordinate 12345678910111213141516171819202122232425262728293031323334353637383940414243int howmuch_mine(char mine[ROWS][COLS],int x,int y)&#123; return mine[x][y + 1] + mine[x - 1][y + 1] + mine[x - 1][y] + mine[x - 1][y - 1] + mine[x][y - 1] + mine[x + 1][y - 1] + mine[x + 1][y] + mine[x + 1][y + 1] - 8 * &#x27;0&#x27;;&#125;//排雷void set_coordinate(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)&#123; int x = 0; int y = 0; int counts = 0; while (counts&lt;(ROW*COL-MINE)) &#123; printf(&quot;输入坐标&gt;\\n&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (x &gt;=1 || x&lt;=col &amp;&amp; y &gt;&gt;1 || y&lt;=col) &#123; if (show[x][y] == &#x27;*&#x27;) &#123; if (mine[x][y] == &#x27;1&#x27;) &#123; printf(&quot;很遗憾，你被炸了！\\n&quot;); display_arr(mine, ROW, COL); break; &#125; else &#123; //计算炸弹数 int count = howmuch_mine(mine, x, y); show[x][y] = count + &#x27;0&#x27;; display_arr(show, ROW, COL); counts++; &#125; &#125; else &#123; printf(&quot;坐标已被占用，请重新输入\\n&quot;); &#125; &#125; else &#123; printf(&quot;坐标非法，请重新输入&quot;); &#125; &#125; if (counts == (ROW * COL - MINE)) &#123; printf(&quot;恭喜你，排雷成功\\n&quot;); display_arr(mine, ROW, COL); &#125; &#125; 输入坐标，判断坐标的合法性，当坐标合法时，如果坐标处是地雷，结束游戏。如果坐标处不是地雷，将show棋盘坐标处的*改成炸弹数，这里需要计算炸弹数，单独写成howmuch_mine函数。函数逻辑是将mine棋盘坐标处四周的元素（8个）相加，无外乎就是字符0或1，再减去8x字符‘0’，这样结果就是地雷个数。 游戏怎样终止呢，排雷成功的条件是什么？9x9的棋盘，10个地雷，理应排71次，将排雷流程写入while语句，定义次数counts，当counts小于71，进入循环，成功排雷1次counts+1，如此往复。跳出while循环后，如果counts为71，排雷成功，打印地雷棋盘mine。 大概思路就是这样，一个简单的扫雷游戏就做好了，哪里有错误欢迎评论区指出。","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"C语言实现简单的井字棋游戏","slug":"Tic-Tac-Toe","date":"2022-01-25T14:42:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2022/01/25/Tic-Tac-Toe/","link":"","permalink":"https://youngsay.cn/2022/01/25/Tic-Tac-Toe/","excerpt":"","text":"井字棋，英文名叫Tic-Tac-Toe，是一种在3*3格子上进行的连珠游戏，和五子棋类似，由于棋盘一般不画边框，格线排成井字故得名。 想必大家小时候都玩过井字棋,今天分享大家一个用C语言做简单的井字棋游戏的教程,通过井字棋游戏,既能回忆起童年的美好,也能熟悉简单的C语言语法. 游戏演示： 我们准备三个文件,分别为game.c,test.c,game.h game.c文件用来写实现游戏功能的各个函数代码,test.c文件写游戏的总流程,game.h文件用来声明函数和初始值. 先来看test.c文件 文件内有三个函数,分别为菜单,游戏,主函数. 1234567void menu()&#123; printf(&quot;-----------------------\\n&quot;); printf(&quot;--------1.开始游戏-----\\n&quot;); printf(&quot;--------2.退出游戏-----\\n&quot;); printf(&quot;-----------------------\\n&quot;);&#125; 菜单很简单,就是开始游戏和退出游戏.我们可以在主函数中switch-case语句实现,输入1开始游戏,输入2退出游戏,其他输入均提示重新输入. 123456789101112131415161718192021int main()&#123; menu(); srand((unsigned int)time(NULL)); int input = 0; do &#123; printf(&quot;请输入选项\\n&quot;); scanf(&quot;%d&quot;, &amp;input); switch (input) &#123; case 1: game(); break; case 2: break; default: break; &#125; &#125; while (input);&#125; 玩家输入1后进入游戏函数,游戏函数内对函数进行调用,函数的声明放在game.h头文件,定义放在game.c源文件. 1234567891011121314151617181920212223242526272829303132333435void game()&#123; char rst = 0; char board[ROW][COL] = &#123; 0 &#125;; //初始化棋盘 InitBoard(board,ROW,COL); //打印棋盘 DisplayBoard(board, ROW, COL); while (1) &#123; //玩家下棋 player_move(board, ROW, COL); DisplayBoard(board, ROW, COL); //判断输赢 rst = isWinner(board,ROW,COL); if (rst != &#x27;C&#x27;) &#123; break; &#125; //电脑下棋 computer_move(board, ROW, COL); DisplayBoard(board, ROW, COL); rst = isWinner(board, ROW, COL); if (rst != &#x27;C&#x27;) &#123; break; &#125; &#125; if (rst == &#x27;*&#x27;) &#123; printf(&quot;恭喜你，赢得了胜利！\\n&quot;); &#125; else if (rst == &#x27;#&#x27;) &#123; printf(&quot;很遗憾，你输了！\\n&quot;); &#125; else &#123; printf(&quot;平局了\\n&quot;); &#125; 我们来简单说一下我们要实现的功能.首先,要初始化一个棋盘,我们可以用用三行三列的数组.玩家开始游戏,要将空棋盘显示给玩家,这时我们要打印棋盘.接着玩家下棋,输入坐标,将坐标处放上棋子,我们用*代表玩家的棋子,玩家下好后电脑下棋,用#代表电脑.当玩家或电脑先实现三个棋子连在一起,游戏结束. 下面是game.h头文件,文件内时头文件的引用,数据的初始化,游戏函数的定义 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROW 3#define COL 3//初始化棋盘的void InitBoard(char board[ROW][COL], int row, int col);//打印棋盘void DisplayBoard(char board[ROW][COL],int row,int col);//玩家下棋void player_move(char board[ROW][COL], int row, int col);//电脑下棋void computer_move(char board[ROW][COL], int row, int col);//判断输赢char isWinner(char board[ROW][COL], int row, int col); 下面是game.c文件的各个函数的定义 首先是初始化棋盘,便利3x3的数组,将数组内的元素置为空格字符 12345678910//初始化棋盘的void InitBoard(char board[ROW][COL], int row, int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; board[i][j] = &#x27; &#x27;; &#125; &#125;&#125; 接着是打印棋盘,打印棋盘很简单,但为了美观要将棋盘打印为井字,所以要花一些巧思 123456789101112131415161718192021222324252627//打印棋盘void DisplayBoard(char board[ROW][COL],int row,int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; printf(&quot; %c &quot;, board[i][j]); if (j &lt; col - 1) &#123; printf(&quot;|&quot;); &#125; &#125; printf(&quot;\\n&quot;); if (i &lt; row - 1) &#123; for (j = 0; j &lt; col; j++) &#123; printf(&quot;---&quot;); if (j &lt; col - 1) &#123; printf(&quot;|&quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; &#125;&#125; 接着是玩家下棋,当玩家输入的坐标小于1或大于3的,提示坐标非法,当坐标合法且该位置没有棋子将该坐标放上棋子* 123456789101112131415161718192021//玩家下棋void player_move(char board[ROW][COL], int row, int col) &#123; int x = 0; int y = 0; while (1) &#123; printf(&quot;玩家下棋&gt;\\n&quot;); scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (x&lt;1 || x&gt;row || y&lt;1 || y&gt;col) &#123; printf(&quot;坐标非法\\n&quot;); &#125; else &#123; if (board[x - 1][y - 1] == &#x27; &#x27;) &#123; board[x - 1][y - 1] = &#x27;*&#x27;; break; &#125; &#125; &#125; &#125; 下面是电脑下棋,使用rand()和srand()生成随机值,rand()%row生成的值是0-2,+1后就是1-3,纵坐标同理,如果坐标处没有棋子放上棋子# 12345678910111213141516//电脑下棋void computer_move(char board[ROW][COL], int row, int col) &#123; int x = 0; int y = 0; printf(&quot;电脑下棋\\n&quot;); while(1) &#123; x = rand() % row; y = rand() % col; if(board[x][y] == &#x27; &#x27;) &#123; board[x][y] = &#x27;#&#x27;; break; &#125; &#125;&#125; 最关键一步就是判断输赢,判断输赢无非就是行,列和对角线.除了输赢,还有平局,isPeace函数是用来判断平局,遍历棋盘,如果有至少一处为空,继续游戏,如果棋盘满了则为平局.返回* 玩家赢,返回# 电脑赢,返回Q 平局,返回C 继续. 123456789101112131415161718192021222324252627282930313233343536373839404142434445int isPeace(char board[ROW][COL], int row, int col) &#123; int i = 0; for (i = 0; i &lt; row; i++) &#123; int j = 0; for (j = 0; j &lt; col; j++) &#123; if (board[i][j] == &#x27; &#x27;) &#123; return 0; &#125; &#125; return 1; &#125;&#125;//判断输赢char isWinner(char board[ROW][COL], int row, int col)&#123; //判断行 int i = 0; for (i = 0; i &lt; row; i++) &#123; if (board[i][0] == board[i][1] &amp;&amp; board[i][1] == board[i][2] &amp;&amp; board[i][1] != &#x27; &#x27;) &#123; return board[i][1]; &#125; &#125; //判断列 int j = 0; for (j = 0; j &lt; col; j++) &#123; if (board[0][j] == board[1][j] &amp;&amp; board[1][j] == board[2][j] &amp;&amp; board[1][j] != &#x27; &#x27;) &#123; return board[1][j]; &#125; &#125; //判断对角线 if (board[0][0] == board[1][1] &amp;&amp; board[0][0] == board[2][2] &amp;&amp; board[0][0] != &#x27; &#x27;) &#123; return board[1][1]; &#125; if (board[0][2] == board[1][1] &amp;&amp; board[0][2] == board[2][0] &amp;&amp; board[0][2] != &#x27; &#x27;) &#123; return board[1][1]; &#125; //判断平局 if (isPeace(board, row, col) == 1) &#123; return &#x27;Q&#x27;; &#125; else &#123; return &#x27;C&#x27;; &#125;&#125; 以上就是一个用c语言制作简单的井字棋的介绍.代码和逻辑都很简单,只需要一些基础的c语言知识便可实现.技术有限,哪里有请指正,任何问题欢迎评论区留言交流.","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"【C语言】分支和循环语句常见问题","slug":"C-branch-loop","date":"2022-01-16T06:33:41.000Z","updated":"2022-01-23T12:10:20.000Z","comments":true,"path":"2022/01/16/C-branch-loop/","link":"","permalink":"https://youngsay.cn/2022/01/16/C-branch-loop/","excerpt":"","text":"分支语句 if-else语句 12345678910111213#include &lt;stdio.h&gt;int main()&#123; int a = 0; int b = 2; if (a == 1) if (b == 2) printf(&quot;hello\\n&quot;); else printf(&quot;panghu\\n&quot;); return 0;&#125;//输出结果： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; int a = 0; int b = 2; if (a == 1) if (b == 2) printf(&quot;hello\\n&quot;); else printf(&quot;胖虎\\n&quot;); else printf(&quot;panghu\\n&quot;); return 0;&#125;//输出结果：panghu 观察上面两段代码，输出结果分别是什么？ 由此可知：else的匹配规则：else总是与离它最近的未匹配的if匹配，与缩进无关。 switch-case语句 switch()括号内是整形表达式。 case后接整型常量表达式。 12345678910111213141516171819int i = 0;scanf(&quot;%d&quot; , &amp;i);switch (i) &#123;case 1:case 2:case 3:case 4:case 5: printf(&quot;工作日\\n&quot;); break;case 6:case 7: printf(&quot;休息日\\n&quot;); break;default: printf(&quot;输入错误&quot;); break;&#125;return 0; 思考下面代码，输出结果是什么？ 123456789101112131415161718192021222324252627282930int main()&#123; int n = 1; int m = 2; switch (n) &#123; case 1: m++; case 2: n++; case 3: switch (n) &#123;//switch允许嵌套使用 case 1: n++; case 2: m++; n++; break; &#125; case 4: m++; break; default: break; &#125; printf(&quot;m = %d, n = %d\\n&quot;, m, n); return 0;&#125;//5 3 循环语句 continue比较 1234567int i = 1;while (i &lt; 10) &#123; if (i == 5) continue; printf(&quot;%d&quot;, i); i++;&#125; 观察上端代码，打印结果是什么？ 结果为1234，然后死循环。 continue是结束本次循环，进入下次循环。当i=5时进入if语句，然后跳出，然后再进入，以此往复。 再看下面的代码： 123456int i = 0;for (i = 1; i &lt; 10; i++) &#123; if (i == 5) continue; printf(&quot;%d&quot;, i);&#125; 结果是12346789，与while循环相比，这次遇到continue跳出本次循环后能够让i自增，不会进入死循环。 getchar()和putchar() 缓存区问题： char arr[20] = &#123; 0 &#125;; printf(&quot;请输入密码\\n&quot;); scanf(&quot;%s&quot; , arr); printf(&quot;请确认密码 Y/N\\n&quot;); int ch = getchar(); if ('Y' == ch) &#123; printf(&quot;确认成功\\n&quot;); &#125; else &#123; printf(&quot;确认失败\\n&quot;); &#125; 当我输入1234时，还没等确认，直接提示确认失败。 原因是当我输入1234后会按回车换行，也就是\\n，此时缓存区会存在\\n，getchar()会从缓存区取出\\n，ch=\\n，不等于Y，弹出确认失败。 如何解决这种问题？ **方法1：**在scanf语句后面加上getchar()来取出\\n，这样ch再访问缓存区就为空了。但这样也有弊端，例如当我输入1234 abcd时又出现错误了。 原因是输入格式%s只读取空格之前的内容，而getchar()只能读取一个字符，所以ch再次读取时发现缓存区还有其他字符且不是Y，提示确认失败·。 方法2： 12345678910111213141516char arr[20] = &#123; 0 &#125;;printf(&quot;请输入密码\\n&quot;);scanf(&quot;%s&quot; , arr);int tmp = 0;while ((tmp = getchar()) != &#x27;\\n&#x27;) &#123; ;&#125;printf(&quot;请确认密码 Y/N\\n&quot;);int ch = getchar();if (&#x27;Y&#x27; == ch) &#123; printf(&quot;确认成功\\n&quot;);&#125;else &#123; printf(&quot;确认失败\\n&quot;);&#125; 用while循环，多次读取，直到缓存区为空，跳出循环。 赋值和判断 观察下面代码，该代码循环几次？ 12345int i = 0;int k = 0;for (i = 0, k = 0; k = 0; i++, k++) k++;return 0; 循环0次。为什么呢？原因是判断部分写成了k=0，=为赋值，使得条件为假，不进入for循环，代码执行0次。 循环的应用： 12345678//非递归求5的阶乘int i = 1;int sum = 0;int rst = 1;for (i = 1; i &lt;= 5; i++) &#123; rst = rst * i;&#125;printf(&quot;%d&quot;, rst); 123456789//求1!+2!+……+5！之和int i = 1;int sum = 0;int rst = 1;for (i = 1; i &lt;= 5; i++) &#123; rst = rst * i; sum += rst;&#125;printf(&quot;%d&quot;, sum); strcmp() C 库函数 int strcmp(const char *str1, const char *str2) 把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 该函数返回值如下： 如果返回值小于 0，则表示 str1 小于 str2。 如果返回值大于 0，则表示 str1 大于 str2。 如果返回值等于 0，则表示 str1 等于 str2。 因此比较两个字符串值是否相同时，不能用==，应该用strcmp()函数。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main ()&#123; char str1[15]; char str2[15]; int ret; strcpy(str1, &quot;abcdef&quot;); strcpy(str2, &quot;ABCDEF&quot;); ret = strcmp(str1, str2); if(ret &lt; 0) &#123; printf(&quot;str1 小于 str2&quot;); &#125; else if(ret &gt; 0) &#123; printf(&quot;str1 大于 str2&quot;); &#125; else &#123; printf(&quot;str1 等于 str2&quot;); &#125; return(0);&#125; rand()和srand() rand():Generates a pseudorandom number. 生成一个伪随机值 int rand( void ); 123printf(&quot;%d\\n&quot;,rand());printf(&quot;%d\\n&quot;, rand());printf(&quot;%d\\n&quot;, rand()); 运行上段代码，会发现每次运行结果都一样，这不是我们理想中的随机值。 Use the srand function to seed the pseudorandom-number generator before calling rand. 我们可以用srand()来使伪随机值变化。Sets a random starting point. void srand( unsigned int seed ); 我们可以用时间作为参数，只要每次播种的时间不同，那么生成的种子就不同，最终的随机数也就不同。 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main() &#123; int a; srand((unsigned)time(NULL)); a = rand(); printf(&quot;%d\\n&quot;, a); return 0;&#125; C语言随机数生成教程，C语言rand和srand用法详解 (biancheng.net)","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"【JavaSE】类和对象","slug":"Java-class-object","date":"2022-01-14T03:40:41.000Z","updated":"2022-05-12T08:27:10.000Z","comments":true,"path":"2022/01/14/Java-class-object/","link":"","permalink":"https://youngsay.cn/2022/01/14/Java-class-object/","excerpt":"","text":"类的成员：字段、方法、代码块、内部类和接口等 字段 1234class Person&#123; public int age; public String name; public String sex; age，name，sex这些类中方法外的变量，是字段、属性、成员变量（3种称呼均可） 123456789public class TestDemo &#123; public static void main(String[] args) &#123; //类的实例化 Person person=new Person(); System.out.println(person.name);//null System.out.println(person.age);//0 &#125;&#125; 对象的字段如果没有初始化，访问时会被设置成默认值。 默认值规则 对于各种数字类型, 默认值为 0. 对于 boolean 类型,默认值为 false. 对于引用类型(String, Array, 以及自定制类), 默认值为 null 12Exception in thread &quot;main&quot; java.lang.NullPointerException at TestDemo.main(TestDemo.java:15) 对null进行访问，会出现空指针异常。 方法 123456789101112131415161718192021222324class Person &#123; //字段、成员变量、属性 public int age; public String name; public String sex; //方法 //构造方法 public Person(String name) &#123; this.name = name; &#125; public void study() &#123; System.out.println(this.name+&quot;正在学习&quot;); &#125;&#125;public class TestDemo &#123; public static void main(String[] args) &#123; //类的实例化 Person person=new Person(&quot;panghutx&quot;); person.study(); &#125;&#125; 代码中的study()就是一个方法，和之前学到的方法（c语言为函数没什么区别） public Person(String name) &#123; this.name = name; &#125; 上段代码是一个构造方法 构造方法是一种特殊方法, 使用关键字new实例化新对象时会被自动调用, 用于完成初始化操作。局部变量必须初始化，否则会编译失败，而成员变量无需初始化，原因在于构造方法为各成员进行了初始化。 语法规则：方法名与类名一致，没有返回值，支持重载 1234567891011//不带参数的构造方法public Person()&#123; System.out.println(&quot;I am the constructor method of zero Parameter &quot;);&#125;//带有3个参数的构造方法public Person(String name,int age,String sex)&#123; this.name=name; this.age=age; this.sex=sex; System.out.println(&quot;I am the constructor method of three Parameters &quot;);&#125; 123//类的实例化Person person1=new Person();Person person2=new Person(&quot;panghutx&quot;,12,&quot;male&quot;); 输出结果为 123I am the constructor method of zero Parameter I am the constructor method of three Parameters 代码块 使用&#123;&#125;定义的一段代码.分为本地代码块、实例代码块和静态代码块，定义在方法中的代码块是本地代码块，定义在类中的代码块是实例代码块（也叫构造代码块），由static修饰的是静态代码块。 构造代码块 构造代码块(实例代码块)：定义在类中的代码块(不加修饰符)。构造代码块一般用于初始化实例成员变量。 实例代码块优先于构造函数执行。 静态代码块 使用static定义的代码块。一般用于初始化静态成员属性。 静态代码块不管生成多少个对象，其只会执行一次，且是最先执行的。 12345678910111213141516171819202122232425262728293031323334353637class Person&#123; private String name;//实例成员变量 private int age; private String sex; private static int count = 0;//静态成员变量 由类共享数据 方法区 public Person()&#123; System.out.println(&quot;I am Person init()!&quot;); &#125; //实例代码块 &#123; this.name = &quot;bit&quot;; this.age = 12; this.sex = &quot;man&quot;; System.out.println(&quot;I am instance init()!&quot;); &#125; //静态代码块 static &#123; count = 10;//只能访问静态数据成员 System.out.println(&quot;I am static init()!&quot;); &#125; public void show()&#123; System.out.println(&quot;name: &quot;+name+&quot; age: &quot;+age+&quot; sex: &quot;+sex); &#125; &#125; public class Main &#123; public static void main(String[] args) &#123; Person p1 = new Person(); Person p2 = new Person();//静态代码块是否还会被执行？ &#125; &#125; 执行结果： 12345I am static init()!I am instance init()!I am Person init()!I am instance init()!I am Person init()! static关键字 static修饰属性、方法、类、代码块 static修饰属性 static修饰的属性不与对象绑定，所有类共享，只有一份，存在于方法区。 访问方法：类名.static属性 123456789101112131415161718192021class TestDemo&#123; public int a; public static int count;&#125;public class Main&#123; public static void main(String[] args) &#123; TestDemo t1 = new TestDemo(); t1.a++; TestDemo.count++; System.out.println(t1.a); System.out.println(TestDemo.count); System.out.println(&quot;============&quot;); TestDemo t2 = new TestDemo(); t2.a++; TestDemo.count++; System.out.println(t2.a); System.out.println(TestDemo.count); &#125;&#125; 输出结果： 1234511============12 static修饰方法 static修饰的方法无需创建对象，可以由类直接调用，调用方法：类名.方法。静态方法只能访问静态变量，不能访问非静态变量。 123456789101112131415class TestDemo&#123; public int a; public static int count; public static void change() &#123; count = 100; //a = 10; error 不可以访问非静态数据成员 &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; TestDemo.change()；//无需创建实例对象 就可以调用 System.out.println(TestDemo.count); &#125;&#125; 注意：this和super两个关键字不能在静态上下文中使用(this 是当前实例的引用, super是当前实例父类实例的引用, 也是和当前实例相关). this关键字 this关键字代表当前对象的引用，不是当前对象。 一个对象的产生分为两步： ①为对象分配内存②调用合适的构造方法 对象的产生需要调用合适的构造方法，在构造方法内部可以使用this，对象还没有产生我们就已经使用了this，恰恰说明this不代表当前对象。 this的用法： this():调用构造方法，该语句必须是构造方法中的第一条语句，否则会编译失败。 this.data:调用当前对象的属性 this.func():调用当前对象的方法","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】数组的定义和使用","slug":"Java-array","date":"2022-01-12T14:40:41.000Z","updated":"2022-05-10T12:21:16.000Z","comments":true,"path":"2022/01/12/Java-array/","link":"","permalink":"https://youngsay.cn/2022/01/12/Java-array/","excerpt":"","text":"一维数组 一维数组的定义 123int[] arr=&#123;1,2,3,4,5&#125;; //静态创建int[] arr1=new int[]&#123;1,2,3,4,5&#125;; //动态创建int[] arr2=new int[5]; 一维数组的遍历 method 1： 123for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]);&#125; method 2： 123for (int x:arr) &#123; System.out.print(x);&#125; method 3： 1System.out.println(Arrays.toString(arr)); 理解引用 int[] arr=new int[]&#123;1,2,3&#125;创建一个数组，变量arr是一个引用类型，里面只保存了一个整数（数组的起始内存地址），指向&#123;1，2，3&#125;的存储地址。 引用，本质上就是存放了一个地址。当数组作为方法的参数时，其实是将数组的首地址作为参数，通过首地址便可以找到数组中的每一个元素。这样的好处是避免了整个数组的拷贝，可以节省内存。 初识JVM内存区域划分 虚拟机栈：重点存储局部变量表，int[] arr这样的引用类型就存储在这里，每次方法执行时，会创建一个栈帧，方法结束后会自动销毁，栈帧内的数据也会一同销毁。 堆：JVM管理的最大内存区域，new创建的对象都存储在这里，如new int[]&#123;1，2，3&#125;。程序开始运行，堆创建，程序运行结束，堆销毁。 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量等数据，字节码文件就保存在方法区。 二维数组 二维数组的定义 123int[][] array=&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;int[][] array1=new int[][]&#123;&#123;7,8,9&#125;,&#123;10,11,12&#125;&#125;;int[][] array2=new int[2][3]; 二维数组的遍历 method 1： 123456for (int i = 0; i &lt; array.length; i++) &#123; for (int j = 0; j &lt; array[i].length; j++) &#123; System.out.print(array[i][j]+&quot; &quot;); &#125; System.out.println();&#125; method 2： 123456for ( int[] x:array) &#123; for ( int y:x) &#123; System.out.print(y); &#125; System.out.println();&#125; method 3： 1System.out.println(Arrays.deepToString(array)); 数组练习 数组拷贝 1public static int[] copyOf(int[] original,int newLength) original - 要复制的数组 newLength - 要返回的副本的长度 1public static int[] copyOfRange(int[] original,int from,int to) original - 要从中复制范围的数组 from - 要复制的范围的初始索引（包括） to - 要复制的范围的最终索引（不包括） 12345678int[] arr=&#123;1,2,3,4,5&#125;;int[] arr2=Arrays.copyOf(arr,arr.length);System.out.println(Arrays.toString(arr2)); //&#123;1，2，3，4，5&#125;arr[0]=100;System.out.println(Arrays.toString(arr2)); //&#123;1，2，3，4，5&#125;System.out.println(Arrays.toString(arr)); //&#123;100，2，3，4，5&#125;int[] arr3=Arrays.copyOfRange(arr,1,3); // 拷贝[1,3)范围内的数组System.out.println(Arrays.toString(arr3)); //&#123;2，3&#125; 数组排序（冒泡排序） 1234567891011121314151617181920public static void main(String[] args) &#123; int[] arr=&#123;11,2,31,14,5&#125;; bubbleSort(arr); System.out.println(Arrays.toString(arr));&#125;public static void bubbleSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; boolean flg=false; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j]&gt;arr[j+1])&#123; int tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; flg=true; &#125; &#125; if(flg==false) break; &#125;&#125; 数组排序（偶数在前，奇数在后） 123456789101112131415161718192021222324public static void main(String[] args) &#123; int[] arr=&#123;1,2,3,4,5&#125;; transform(arr); System.out.println(Arrays.toString(arr));&#125;public static void transform(int[] arr)&#123; int left=0; int right=arr.length-1; while(left&lt;right)&#123; while(left&lt;right&amp;&amp;arr[left]%2==0)&#123; left++; &#125; //遇到奇数了 while(left&lt;right&amp;&amp;arr[right]%2!=0)&#123; right--; &#125; //遇到偶数了 if(left&lt;right)&#123; int tmp=arr[left]; arr[left]=arr[right]; arr[right]=tmp; &#125; &#125;&#125; 查找指定数组元素（二分查找） 12345678910111213141516public int binarySearch(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right)&#123; //每次范围缩小一半 int mid = (left+right)/2; if(nums[mid]&lt;target)&#123; //范围缩小到右半部分 left = mid + 1; &#125;else if(nums[mid]&gt;target)&#123; //范围缩小到左半部分 right = mid -1; &#125;else &#123; return mid; //找到了，返回下标 &#125; &#125; return -1;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【C语言】基础语法的简单概括","slug":"C-prime-knowledge","date":"2022-01-08T01:33:41.000Z","updated":"2022-01-23T12:10:06.000Z","comments":true,"path":"2022/01/08/C-prime-knowledge/","link":"","permalink":"https://youngsay.cn/2022/01/08/C-prime-knowledge/","excerpt":"","text":"数据类型 为了更加丰富地表达生活中的各种值，C语言中有不同的数据类型。每个数据类型有其占用空间的大小。我们用sizeof可以获取某个数据类型所占用空间的字节数。 下面这段代码： 1234567printf(&quot;%d&quot;, sizeof(char));printf(&quot;%d&quot;, sizeof(short));printf(&quot;%d&quot;, sizeof(int));printf(&quot;%d&quot;, sizeof(long));printf(&quot;%d&quot;, sizeof(long long));printf(&quot;%d&quot;, sizeof(float));printf(&quot;%d&quot;, sizeof(double)); 在vs2019运行时，输出结果是：1244848 在linux平台运行时，结果是：1248848 对比发现，long在不同的编译器结果不同。c语言并没有规定long的大小，只是规定了sizeof(long)&gt;=sizeof(int)。 变量的作用域和生命周期 作用域：变量作用的范围。变量在哪里可以使用，哪里就是它的作用域。 局部变量的作用域是变量所在的局部范围；全局变量的作用域是整个工程。 生命周期：变量由创建到销毁这一时间段 局部变量的生命周期是：局部变量的作用域；全局变量的生命周期是：整个程序。 常量 字面常量 const修饰的常变量 123const double pi = 3.14;pi = 6.66;//报错信息：表达式必须是可修改的左值 由const修饰的变量只是不可以再次修改，但本质仍是变量。 define定义的标识符常量 12#define MAX 100printf(&quot;max = %d\\n&quot;, MAX); 枚举常量 123456789101112enum MyEnum&#123; MALE, FAMALE, SECRET&#125;;int main()&#123; printf(&quot;%d&quot;, MALE); //0 printf(&quot;%d&quot;, FAMALE); //1 printf(&quot;%d&quot;, SECRET); //2&#125; 字符串 12345678int main()&#123; char arr1[] = &quot;hello&quot;; char arr2[] = &#123; &#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27; &#125;; printf(&quot;%s\\n&quot;, arr1); printf(&quot;%s\\n&quot;, arr2);&#125; 字符串的结束标志是一个\\0的转义字符。在计算字符串长度的时候\\0不算作字符串内容。printf输出内容是\\0之前的内容，arr2找不到\\0出现了乱码，用strlen计算长度时也会出现随机值。 转义字符 下段代码的输出结果是什么？ 1printf(&quot;%d\\n&quot;, strlen(&quot;c:\\test\\628\\test.c&quot;)); 输出结果是14。 \\t-----&gt;水平制表符 \\62—&gt;将8进制数数字62转换成10进制数字50 注： \\ddd中ddd表示1-3位八进制数字，范围是0-7，所以上题中是\\62，不是\\628 \\xdd中dd表示2个十六进制数字。 如: 12printf(&quot;%c\\n&quot;, &#x27;\\x31&#x27;); //1//将16进制数字31转换为10进制数字49，ascii码值代表的字符为 ‘1’ 关键字 123auto break case char const continue default do double else enum extern float for goto if int long register return short signedsizeof static struct switch typedef union unsigned void volatile while define 定义标识符常量 12345678910#include&lt;stdio.h&gt;#define N 5int main()&#123; int arr[N] = &#123;0,1,2,3,4&#125;; int i = 0; for (i = 0; i &lt; N; i++) &#123; printf(&quot;%d&quot;, arr[i]); &#125;&#125; 定义宏 1234567#define MAX(a,b)(a)&gt;(b)?(a):(b)int main()&#123; int x = 10; int y = 20; printf(&quot;%d&quot;, MAX(x,y)); //20&#125; static static是用来修饰变量和函数的 修饰局部变量-称为静态局部变量 修饰全局变量-称为静态全局变量 修饰函数-称为静态函数 修饰局部变量 观察下面两段代码 1234567891011121314#include&lt;stdio.h&gt;void add() &#123; static int b = 0; b++; printf(&quot;%d&quot;, b); //12345&#125;int main()&#123; int i = 0; for (i = 0; i &lt; 5; i++) &#123; add(); &#125; return 0;&#125; 1234567891011121314#include&lt;stdio.h&gt;void add() &#123; int b = 0; b++; printf(&quot;%d&quot;, b); //11111&#125;int main()&#123; int i = 0; for (i = 0; i &lt; 5; i++) &#123; add(); &#125; return 0;&#125; 对比发现，static修饰局部变量改变了变量的生命周期，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。 static修饰局部变量时，改变了局部变量的存储位置，将局部变量由堆区存储到静态区。 修饰全局变量和函数 一个全局变量（函数）被static修饰，使得这个全局变量（函数）只能在本源文件内使用，不能在其他源文件内使 用。 全局变量（函数）具有外部链接属性，可以用extern外部引用，但被static修饰后，外部链接变成了内部链接，只能在当前源文件内部使用。 typedef 类型重命名：使类型名简单化，书写更方便 1234567//将类型unsigned int重命名为uint_32，下次可以直接使用类型uint_32typedef unsigned int uint_32;int main()&#123; unsigned int a = 0; uint_32 b = 0;&#125; 结构体 123456789101112131415161718192021//定义结构体类型struct MyStruct&#123; char name[20]; int age; char sex[6];&#125;;//dvoid stu(struct MyStruct* ps) &#123; printf(&quot;%s,%d,%s&quot;, ps-&gt;name, ps-&gt;age, ps-&gt;sex);&#125;int main()&#123; //结构体实例化 struct MyStruct stu1 = &#123;&quot;菜鸟小胖p&quot;,20,&quot;保密&quot;&#125;; struct MyStruct stu2 = &#123; &quot;小明&quot;,101,&quot;男&quot; &#125;; //打印结构体 printf(&quot;%s,%d,%s\\n&quot;, stu1.name, stu1.age, stu1.sex); //函数打印结构体 stu(&amp;stu2);&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"2021年度总结","slug":"2021","date":"2022-01-01T09:24:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2022/01/01/2021/","link":"","permalink":"https://youngsay.cn/2022/01/01/2021/","excerpt":"","text":"2022年来了，我又长大了一岁。 过去这一年，有快乐有失落，有收获有遗憾。 伤感的话不再说，遗憾的事不再提，新的一年继续好好生活。 等等，在好好生活之前还是写一下年终总结吧，虽然今天已经是2022年…… 回顾过去的这一年，**每一天都很平常，有时很快乐，有时会难过，也许有成长，难免有遗憾。**就在这平凡的一天又一天中，平凡的我又长大了一岁。 我没有写日记的习惯，很多事过去了就过去了，也许以后就再也不会想起。比如现在我想写一个年度总结，我不知道写些什么。好在有这样一个博客，或多或少能留存一些当时的记忆。 2021年3月29日，新博客建成，发布第一篇博客： 新学期，新博客，新开始! 在此之前也搭建过其他博客，总是写着写着感觉没啥意思，最终都删库跑路了。这是我持续时间最长的博客，我会一直让它活下去（希望别被打脸）。 回看第一篇博客，感慨万千。当时写到“我想学计算机相关专业，但无奈被调剂到了应用物理”，现在我已经是计算机科学与技术专业的学生了，2021/9/17 收到了转专业成功的消息，这个可以算是今年很开心的一件事。当时我提到“一直对编程感兴趣，尤其是前端”，现在我已经俩月没学前端了，2021/11/6 发的vue那篇笔记应该是我最后一次学习前端，也是刚开始接触vue。现在专业课开了Python和C语言，所以就把js先搁置了。最初学的时候就不扎实，现在再回看当时的笔记已经很陌生了。 2021年6月2号，在听讲座后不久，发布了： 讲座，机会，关系! 这是听完学长讲座后不久写的一篇博客。学长是我原来学院信科专业的学生，考上了北理工研究生，讲座期间在字节跳动实习，现在怎样我也不知道了。当时我还加了他的微信，至今也没发过消息……学长的讲座对我影响很大，在听完他讲座后的一段时间学习很积极，但劲头持续时间不长（捂脸）。 2021年7月21日，放暑假两周后发布： 暑假，目的论，自卑情结 这篇博客是看了《被人讨厌的勇气》的读后感，对我有些许启发。我惰性很强，自制力很差，如果我再胸无大志的话，便是个完完全全快乐的人。但我又有燕雀之志（虽无鸿鹄之志，但也有些小追求），所以有时会很焦虑，只能做半个快乐的人。我因为自制力差，经常沉迷于网络而浪费很多时间，但我又有些追求，时而积极，时而消极。积极时我经常为过去的消极而懊悔，为失去了的宝贵时间而焦虑，但积极一阵后便又迎来了消极，周而复始，反反复复。 2021年9月6日：大二上开学，2021年12月24日，本学期结束。 这学期自我感觉良好，比以往更加充实快乐。 回顾这一年，当时的很多想法已经变了，当时的很多困惑现在已不再困惑，当时认为天大的事现在看来也许都不叫事。最后引用余华的一句话来结束本篇博客，“没有什么比时间更具有说服力了，因为时间无需通知我们就可以改变一切”。","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"}]},{"title":"【JavaSE】方法及递归的使用","slug":"Java-method","date":"2021-11-23T05:05:41.000Z","updated":"2022-01-23T12:10:42.000Z","comments":true,"path":"2021/11/23/Java-method/","link":"","permalink":"https://youngsay.cn/2021/11/23/Java-method/","excerpt":"","text":"初识方法 Java中的方法类似于c语言中的函数 观察下面代码，体会方法的好处。 123456789101112//求两个数的最大值public static int maxTwoNum(int a,int b) &#123; return a&gt;b ? a : b;&#125;//求三个数的最大值public static int maxThreeNum(int a,int b,int c) &#123; int max=maxTwoNum(a,b); return maxTwoNum(max,c);&#125;public static void main(String[] args) &#123; int a=10,b=23,c=4; System.out.println(maxThreeNum(a,b,c)); 灵活使用方法，可以减少重复代码，使代码更简单。 实参、形参的关系 Java当中只有按值传递 分析如下代码：交换两个整型变量 12345678910111213public static void swap(int x,int y)&#123; int tmp=x; x=y; y=tmp;&#125;public static void main5(String[] args) &#123; //交换两个整型变量的错误演示 int a=10; int b=20; swap(a,b); System.out.println(a); System.out.println(b);&#125; 输出结果为10 20，没有完成两数的交换。对于基础类型来说, 形参相当于实参的拷贝. 即 传值调用 1234567891011public static void swap1(int[] arr)&#123; int tmp=arr[0]; arr[0]=arr[1]; arr[1]=tmp;&#125;public static void main(String[] args) &#123; //交换两个整数的正确方法 int[] arr=&#123;10,20&#125;; swap1(arr); System.out.println(Arrays.toString(arr));&#125; 解决方案：传引用类型参数，如数组。 练习：求n个阶乘之和 123456789101112131415161718192021public static int add(int n) &#123; int j=1; int sum=0; for(j=1;j&lt;=n;j++)&#123; sum += factor(j); &#125; return sum;&#125;public static int factor(int j)&#123; int i=1; int rst=1; for(i=1;i&lt;=j;i++)&#123; rst *= i; &#125; return rst;&#125;public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int num=scan.nextInt(); System.out.println(add(num));&#125; 方法的重载（overload）： 同一个方法名字, 提供不同版本的实现, 称为方法重载 方法名相同 返回值不做要求 参数列表不同（参数个数或参数类型不同） 同一个类当中 123456789public static int sum(int a,int b) &#123; return a+b;&#125;public static double sum(double a,double b) &#123; return a+b;&#125;public static void main(String[] args) &#123; System.out.println(sum(4,6));&#125; 面试题：重载和重写的区别 方法的递归 一个方法在执行过程中调用自身, 就称为 “递归”。 递归把大问题化解成小问题，求解递归问题，要找到终止条件和递归公式。 求n的阶乘 12345678910public static int factor(int n) &#123; if(n==1)&#123; return 1; &#125;else &#123; return n * factor(n - 1); &#125;&#125;public static void main(String[] args) &#123; System.out.println(factor(4));&#125; 求n个阶乘之和 12345678910111213141516public static int factor(int i)&#123; if(i==1)&#123; return 1; &#125;else&#123; return i*factor(i-1); &#125;&#125;public static void main(String[] args) &#123; int sum=0; Scanner scan = new Scanner(System.in); int num=scan.nextInt(); for (int i = 1; i &lt; num; i++) &#123; sum+= factor(i); &#125; System.out.println(sum);&#125; 按顺序打印一个数字的每一位(例如 1234 打印出 1 2 3 4) 123456789public static void func(int n) &#123; if(n&gt;9)&#123; func(n/10); &#125; System.out.print(n%10+&quot; &quot;);&#125;public static void main(String[] args) &#123; func(123);&#125; 递归求 1 + 2 + 3 + … + 10 12345678910public static int sum(int n) &#123; if (n==1) &#123; return 1; &#125; else &#123; return n+sum(n-1); &#125;&#125;public static void main(String[] args) &#123; System.out.println(sum(10));&#125; 写一个递归方法，输入一个非负整数，返回组成它的数字之和. 例如，输入 1729, 则应该返回1+7+2+9， 它的和是19 123456789public static int func(int n) &#123; if(n&gt;9)&#123; return n%10+func(n/10); &#125; return n;&#125;public static void main(String[] args) &#123; System.out.println(func(5211));&#125; 求斐波那契数列的第N项： 1234567public static int fib(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fib(n - 1) + fib(n - 2);&#125; 不建议用递归实现斐波那契数列，建议用循环。 1234567891011121314public static int func(int n) &#123; int n1=1; int n2=1; int n3=1; for(int i=3;i&lt;=n;i++) &#123; n3=n1+n2; n1=n2; n2=n3; &#125; return n3;&#125;public static void main(String[] args) &#123; System.out.println(func(1));&#125; 思考递归：横向思考，不要展开递归的代码 代码执行：纵向执行","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】程序逻辑控制练习","slug":"Java-logic-control","date":"2021-11-20T08:55:41.000Z","updated":"2022-01-23T12:10:38.000Z","comments":true,"path":"2021/11/20/Java-logic-control/","link":"","permalink":"https://youngsay.cn/2021/11/20/Java-logic-control/","excerpt":"","text":"输入1-7，输出工作日或休息日 1234567891011121314151617Scanner scan = new Scanner(System.in);switch(scan.nextInt()) &#123; case 1: case 2: case 3: case 4: case 5: System.out.println(&quot;工作日&quot;); break; case 6: case 7: System.out.println(&quot;休息日&quot;); break; default: System.out.println(&quot;输入错误&quot;); break;&#125; switch 中的值只能是 整数|枚举|字符|字符串，long、double、float、boolean不能作为switch参数的类型。 判断一个数是否为素数（3种方法） 1234567891011121314Scanner scan = new Scanner(System.in);int num=scan.nextInt();int i=1;for(i=2;i&lt;num;i++) &#123; //方法2：i&lt;=num/2 //方法3：i&lt;=Math.sqrt(num); if(num%i==0) &#123; System.out.println(num+&quot;不是素数&quot;); break; &#125;&#125;if(i&gt;=num)&#123; System.out.println(num+&quot;是素数&quot;);&#125; 打印100以内的所有素数 123456789101112int j=0;for(j=2;j&lt;=100;j++) &#123; int i=1; for(i=2;i&lt;j;i++)&#123; if(j%i==0)&#123; break; &#125; &#125; if(i==j)&#123; System.out.println(j+&quot;是素数&quot;); &#125;&#125; 输出1000-2000之间的所有闰年 12345int year=1000;for(year=1000;year&lt;=2000;year++) &#123; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; System.out.println(year+&quot;是闰年&quot;); &#125; 输出乘法口诀表 12345678int i=1;int j=1;for(i=1;i&lt;=9;i++) &#123; //i--行数 for(j=1;j&lt;=i;j++)&#123; //j--列数 列数的多少取决于第一行 第一行有一列，第二行有两列，…… System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;&quot;); &#125; System.out.println();&#125; 求两个数的最大公约数 1234567891011Scanner scan = new Scanner(System.in);int a=scan.nextInt();int b=scan.nextInt();int c=b;while(a%b!=0) &#123; c=a%b; a=b; b=c;&#125;System.out.println(a+&quot;和&quot;+b+&quot;的最大公约数是&quot;+c);&#125; 计算1/1-1/2+1/3……+1/99-1/100的值 12345678int flag=1;int j=1;double sum=0;for(j=1;j&lt;=100;j++) &#123; sum += 1.0/j*flag; flag=-flag;&#125;System.out.println(sum); 编写程序数一下1到100的所有整数中出现多少个数字9 12345678int i=1;int count=0;for(i=1;i&lt;=100;i++)&#123; if(i%10==9||i/10==9) &#123; count++; &#125;&#125;System.out.println(count); 求出0~999之间的所有”水仙花” 123456int i=100; for(i=100;i&lt;1000;i++) &#123; if(Math.pow(i%10,3)+Math.pow(i/10%10,3)+Math.pow(i/100%10,3)==i) &#123; System.out.println(i); &#125; &#125; 改进：求出1-6位数的自幂数 附：其他位数的自幂数名字 一位自幂数：独身数；三位自幂数：水仙花数；四位自幂数：四叶玫瑰数；五位自幂数：五角星数；六位自幂数：六合数 12345678910111213141516171819int i=1;for(i=1;i&lt;=9999999;i++) &#123; int count=0; int temp=i; int sum=0; //p while (temp!=0) &#123; count++; temp=temp/10; &#125; temp=i; while(temp!=0)&#123; sum += Math.pow(temp%10,count); temp=temp/10; &#125; if(sum==i)&#123; System.out.println(sum); &#125;&#125; 编写代码模拟三次密码输入场景，最多输入3次 123456789101112131415Scanner scan =new Scanner(System.in);String input = scan.next();int count=2;for(count=2;count&gt;0;count--) &#123; if(input.equals(&quot;zzz123&quot;))&#123; //🔺不能用= System.out.println(&quot;密码正确，登陆成功&quot;); break; &#125;else &#123; System.out.println(&quot;输入错误，你还有&quot;+count+&quot;次机会&quot;); &#125; input = scan.next();&#125;if(count&lt;=0)&#123; System.out.println(&quot;三次均输错，退出程序&quot;);&#125; 输入一个数，输出该数二进制中1的个数： 12345678910Scanner scan = new Scanner(System.in);int num=scan.nextInt();int count=0;int i=0;for(i=0;i&lt;32;i++) &#123; if(((num&gt;&gt;i)&amp;1)==1)&#123; count++; &#125;&#125;System.out.println(num+&quot;二进制中1的个数为：&quot;+count); 改进： 12345678Scanner scan =new Scanner(System.in);int n = scan.nextInt();int count=0;while(n!=0)&#123; n=n&amp;(n-1); count++;&#125;System.out.println(count);","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"【JavaSE】数据类型与运算符","slug":"Java-data-type","date":"2021-11-20T03:27:41.000Z","updated":"2022-04-23T06:05:10.000Z","comments":true,"path":"2021/11/20/Java-data-type/","link":"","permalink":"https://youngsay.cn/2021/11/20/Java-data-type/","excerpt":"","text":"初识Java 第一个java程序 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld&quot;); &#125;&#125; 一个java文件中，只能有一个public类，且类名要与文件相同。 类存在于源文件里面；方法存在于类中；语句存在于方法中。 类名要采用大驼峰形式（首字母均大写）命名。 面试问题： main方法为什么是static：main方法是程序的入口，如果不是静态的话，要启动就必须创建一个实例，但是main是程序入口，创建一个实例又得从main开始。如果一个方法不是静态的，则要先实例化该类，比如要这样 test t=new test(); 然后才能调用 t.main(); 而这对于运行一个程序的主函数来说是不现实的，所以比如把main函数定义为static，使t.main()可以直接被调用。 String[] args的作用是什么：运行时命令行参数，例如我运行时输入这条指令：java HelloWorld panghutx is a stupid bird，会将panghutx、is、a、stupid、bird存入args这个字符串数组。 如何运行java程序 大致过程就是，我们写好的.java文件（源文件）被编译器编译后变成.class文件（字节码），然后被JVM的类加载器加载到内存，通过字节码校验器去做一些校验，校验通过后交由解释器将字节码文件解释成计算机能够识别的机器指令。 面试问题：双亲委派模型、类加载器 JDK Java开发工具 ；JRE Java运行环境 ；JVM Java虚拟机 12345678910class zzz &#123; public static void main(String[] args) &#123; System.out.println(&quot;zzz&quot;); &#125;&#125;public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;HelloWorld&quot;); &#125;&#125; Java中，一个类就会生成一个字节码文件。 为何这样设置？为了方便使用，如果需要HelloWorld这个类，就加载对应的字节码文件。 变量和类型 变量均存储在内存中。 变量 整形 12int i=10; //定义一个整形变量System.out.println(i); 一个int变量占4个字节。 什么是字节? 字节是计算机中表示空间大小的基本单位. 计算机使用二进制表示数据. 我们认为 8 个二进制位(bit) 为一个字节(Byte). 我们平时的计算机为 8GB 内存, 意思是 8G 个字节. 其中 1KB = 1024 Byte, 1MB = 1024 KB, 1GB = 1024 MB. 所以 8GB 相当于 80 多亿个字节 12System.out.println(Integer.MAX_VALUE); // 2147483647System.out.println(Integer.MIN_VALUE); // -2147483648 4 个字节表示的数据范围是 -2^31 -&gt; 2^31-1 , 也就大概是 -21亿 到 +21亿 1234int maxValue = Integer.MAX_VALUE;System.out.println(maxValue+1); // -2147483648int minValue = Integer.MIN_VALUE;System.out.println(minValue-1); // 2147483647 如果运算的结果超出了 int 的最大范围, 就会出现溢出的情况。 图：int的取值范围 长整型 long占8个字节，取值范围是-2^63—2^63-1 1234long num=10L;System.out.println(num);System.out.println(Long.MAX_VALUE);System.out.println(Long.MIN_VALUE); 初始化长整型变量是记得在数字后面加上L 双精度浮点型 double占8个字节，浮点数在内存中的存储与整形不同，不能单纯用2^n表示其取值范围，且浮点数的存储会存在精度误差。 12double num = 1.1;System.out.println(num * num) // 1.2100000000000002 单精度浮点型 float占4个字节，初始化时要在数字后面加上f 12float num = 1.0f; // 写作 1.0F 也可以System.out.println(num); 字符型 char在java中占2个字节 1char ch=&#x27;A&#x27;; Java 中使用单引号 + 单个字母 的形式表示字符字面值. 计算机中的字符本质上是一个整数. 在 C 语言中使用 ASCII 表示字符, 而 Java 中使用 Unicode 表示字符. 因此一个字符占用两个字节, 表示的字符种类更多, 包括中文. 使用一个汉字表示一个字符时，报错是要用javac -encoding UTF-8 文件名.java 字节型 byte占1个字节，范围大小是-128–&gt;127 byte类型相加减时会进行整形提升，要用int保存。 短整型 short占2个字节，范围大小是-2^15-2^15-1，范围较小，一般不使用。 布尔型 boolean只有两种取值，true或false。Java中的布尔型和整形不能相互转换，不能用1或0表示布尔型。 字符串型 String占8个字节，Java 使用 双引号 + 若干字符 的方式表示字符串字面值。 1String s = &quot;胖虎同学&quot;; 使用+可以进行字符串的拼接，任何类型的变量与字符串进行拼接时，都会转换成字符串。 123int a=20;int b=21;System.out.println(&quot;&quot;+a+b); //2021 总结 常量 12final int a = 10;a = 20; // 编译出错. 提示 无法为最终变量a分配值 常量不能在程序运行过程中发生修改。 类型转换 不同数字类型的变量之间赋值, 表示范围更小的类型能隐式转换成范围较大的类型 如果需要把范围大的类型赋值给范围小的, 需要强制类型转换, 但是可能精度丢失。不相关的类型不能进行类型转换。 将一个字面值常量进行赋值的时候, Java 会自动针对数字范围进行检查. 总结 运算符 算术运算符 +-*/% 1234System.out.println(5/2); // 2System.out.println(5.0/2); //2.5System.out.println((double)5/2); //2.5System.out.println((double)(5/2)); // 2.0 12345System.out.println(5%2); // 1System.out.println(-5%2); //-1System.out.println(5%-2); //1System.out.println(-5%-2); //-1//正负看被除数 Java中，不仅仅可以对 int 求模, 也能对 double 来求模。 值得注意的是，下图中i=10，而c语言是11。 增量运算符 += -= *= %= 可以自动进行类型转换 关系运算符 == != &lt; &gt; &lt;= &gt;= 关系运算符表达式返回值都是布尔值。 逻辑运算符 &amp;&amp; || ! Java中，逻辑非！只能作用于布尔值 123int a=10;int b=20;System.out.println(!a &lt; b); 位运算符 &amp; | ~ ^ 移位运算符 &gt;&gt; &lt;&lt; &gt;&gt;&gt; 无符号右移 &gt;&gt;&gt;：最右侧位不要了, 最左侧补 0. 123int a = 0xffffffff;System.out.printf(&quot;%x\\n&quot;, a &gt;&gt;&gt; 1);// 运行结果(注意, 是按十六进制打印的) 7fffffff 左移 1 位, 相当于原数字 * 2. 左移 N 位, 相当于原数字 * 2 的N次方 右移 1 位, 相当于原数字 / 2. 右移 N 位, 相当于原数字 / 2 的N次方 由于计算机计算移位效率高于计算乘除, 当某个代码正好乘除 2 的N次方的时候可以用移位运算代替","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"}]},{"title":"c语言：指针误区总结","slug":"c-pointer","date":"2021-11-13T03:31:01.000Z","updated":"2022-02-25T07:06:44.000Z","comments":true,"path":"2021/11/13/c-pointer/","link":"","permalink":"https://youngsay.cn/2021/11/13/c-pointer/","excerpt":"","text":"4个二进制位可以表示一个16进制数字 1111 --&gt;f 指针类型的意义： 指针类型决定了：指针解引用的权限有多大（整型指针解引用访问4个字节，字符型指针解引用只能访问1个字节） 指针类型决定了，指针走一步，能走多远（步长） 例题1： 123456 int a = 0x11223344;char* pc = &amp;a;*pc = 0; //只改变一个字节int* pa = &amp;a;*pa = 0;//改变了四个字节 char* 的指针解引用就只能访问一个字节，而 int* 的指针的解引用能访问四个字节。 例题2： 1234567int arr[10] = &#123; 0 &#125;;int* p = arr;char* pc = arr;printf(&quot;%p\\n&quot;, p);printf(&quot;%p\\n&quot;, p + 1);//加了4，因为int4字节printf(&quot;%p\\n&quot;, pc);printf(&quot;%p\\n&quot;, pc + 1);//加了1，因为char1字节 野指针：指针指向的位置是不可知的 为什么出现野指针： 指针使用时未初始化： 12int* p;//未初始化，地址是随机的*p = 10;//非法访问内存 指针越界： 12345678910//越界访问int arr[10] = &#123; 0 &#125;;int* p = arr;int i = 0;for (i = 0; i &lt;= 10; i++)&#123; *p = i; p++;&#125; 指针指向的空间释放： 12345678910111213int* test()&#123; int a = 10; return &amp;a;&#125;int main()&#123; int*p = test(); *p = 20; return 0;&#125; 退出test函数后空间释放，找不到指针p的地址。 总结：如何规避野指针？ 1.指针初始化 2.小心指针越界 3.指针指向空间释放即设置NULL 4.指针使用之前检查有效性 指针的运算： 指针±整数： 12345678int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;int* p = arr; //元素1的地址int* pend = arr + 9; //元素10的地址while (p &lt; pend)&#123; printf(&quot;%d\\n&quot;, *p); p++;&#125; 指针-指针： 123456789int main()&#123; int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; char c[5]; printf(&quot;%d\\n&quot;, &amp;arr[9] - &amp;c[0]);//err，两个指针指向不同空间 printf(&quot;%d\\n&quot;, &amp;arr[9] - &amp;arr[0]);//这个输出9 return 0;&#125; 两指针相减的前提是指针指向同一块空间，指针-指针得到的是两个指针之间元素的个数 例题：求字符串长度： 12345678910111213141516171819//1.strlen()函数//2.递归//3.int my_strlen(char* str)&#123; char* start = str; while (*str != &#x27;\\0&#x27;) &#123; str++; &#125; return str - start;&#125;int main()&#123; int len = my_strlen(&quot;abc&quot;);//这里&quot;abc&quot;传入的只有首字母a的地址 printf(&quot;%d\\n&quot;, len); return 0;&#125; 指针和数组： 123456789int main()&#123; int arr[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int* p = arr; int i = 0; for (i = 0; i &lt; 10; i++) &#123; printf(&quot;&amp;arr[%d]=%p &lt;==&gt; *(p+%d)=%p\\n&quot;,i,&amp;arr[i],i,p+i);&#125; arr[i]=*(p+i) =*(arr+i); &amp;arr[i]=p+i=arr+i; 1arr[2] &lt;==&gt; *(arr+2) &lt;==&gt; *(p+2) &lt;==&gt; *(2+p) &lt;==&gt; *(2+arr) == 2[arr] 二级指针： 12345678int main()&#123; int a = 3; int* pa = &amp;a; int** ppa = &amp;pa; //ppa就是一个二级指针，用来存放指针pa，而指针pa也是一个指针，用来存放a。 printf(&quot;%d,%d,%d\\n&quot;, a,*pa,**ppa);//结果均为3&#125; 禁止套娃！！！","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"Vue笔记：指令","slug":"vue1","date":"2021-11-06T11:25:01.000Z","updated":"2021-11-06T12:44:36.000Z","comments":true,"path":"2021/11/06/vue1/","link":"","permalink":"https://youngsay.cn/2021/11/06/vue1/","excerpt":"","text":"什么是vue 构建用户界面 用vue往html里填充数据 框架 框架是一套现成的解决方案，只能遵守框架规范写自己的业务功能 vue的特性 数据驱动视图 数据的变化会驱动视图自动更新 双向数据绑定 在网页中，form表单负责采集数据，Ajax负责提交数据 js数据的变化，会被自动渲染到页面上 页面上表单采集的数据发生变化时，会被vue自动获取到，更新到js数据中 数据驱动视图和双向数据绑定的底层原理是MVVM（Mode数据源、View视图、ViewModel就是vue实例 vue的基本使用 1234567891011121314151617&lt;body&gt; &lt;!-- 希望vue控制div，把数据填充到div内部 --&gt; &lt;div id=&quot;app&quot;&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt; &lt;!-- 1.导入Vue库文件，在window全局就有了vue这个构造函数 --&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 2.创建Vue的实例对象 --&gt; &lt;script&gt; const vm = new Vue(&#123; //el属性是固定写法，表示当前vm实例要控制页面上的那个区域，接受的值是一个选择器 el: &#x27;#app&#x27;, //date对象就是要渲染到页面的数据 data: &#123; username: &#x27;胖虎&#x27; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; vue指令 1.内容渲染指令 12345v-text：会覆盖元素内部原有指令，只能渲染纯文本内容&#123;&#123;&#125;&#125; :插值表达式,内容占位符，不会覆盖原有内容，只能渲染纯文本内容，不能用在元素的属性节点v-html:把带标签的指令渲染成html内容 2.属性绑定指令 v-bind: 可简写为:为元素属性动态绑定值 在使用v-bind属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，如： 123&lt;div :title=&quot;&#x27;box&#x27; + index&quot;&gt; 这是一个div&lt;/div&gt; 在 &#123;&#123;&#125;&#125;插值表达式和v-bind指令中可以使用js语法 3.事件绑定指令 v-on:可简写为@，为元素绑定事件 1234567&lt;button @click=&#x27;add&#x27;&gt;+1&lt;/button&gt;methods: &#123; add()&#123; this.count+=1; &#125; 如果默认对象事件e被覆盖，可以手动传递$event 1234567&lt;button @click=&#x27;add(1,$event)&#x27;&gt;+1&lt;/button&gt;methods: &#123; add(n,e)&#123; this.count+=1; &#125; 事件修饰符 在事件处理函数中调用event.preventDefault()和event.stopPropagation()很常见，为了更方便对事件触发进行控制，vue提供了事件修饰符概念。 .prevent：组织默认行为（链接跳转、表单提交） .stop：阻止事件冒泡 1234567&lt;a href=&quot;http:www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;百度一下&lt;/a&gt;methods: &#123; btn()&#123; console.log(&quot;hhh&quot;); &#125;&#125; 4.双向绑定指令 v-model ：input输入框、textarea、select，v-model 会根据控件类型自动选取正确的方法来更新元素。 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p&gt;input 元素：&lt;/p&gt; &lt;input v-model=&quot;message&quot; placeholder=&quot;编辑我……&quot;&gt; &lt;p&gt;消息是: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;胖虎&#x27;, &#125;&#125;)&lt;/script&gt; v-model指令修饰符 .number：自动将用户的输入值转为数值类型 .trim：自动过滤用户输入的首尾空白字符 5.条件渲染指令 v-if：每次动态创建或移除元素，实现元素的显示和隐藏 v-show：动态为元素添加或移除display:none样式，来实现元素的显示和隐藏 6.列表渲染指令 v-for：用来辅助开发者基于一个数组来循环渲染一个列表结构。v-for 指令需要使用 item in list 形式的特殊语法 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;th&gt;索引&lt;/th&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item,index) in list&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123;index&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;data: &#123; list:[ &#123;id:1, name:&#x27;胖虎&#x27;&#125;, &#123;id:2 ,name:&#x27;大熊&#x27;&#125;, &#123;id:3 ,name:&#x27;小夫&#x27;&#125; ]&#125;,","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://youngsay.cn/tags/Vue-js/"}]},{"title":"Python笔记：条件、循环及其他语句","slug":"python5","date":"2021-11-03T11:25:01.000Z","updated":"2021-11-05T11:40:52.000Z","comments":true,"path":"2021/11/03/python5/","link":"","permalink":"https://youngsay.cn/2021/11/03/python5/","excerpt":"","text":"Python基础教程（第三版）第5章：条件、循环及其他语句 print() end='' //不换行 sep='' //自定义分隔符 123print(&quot;my name is&quot;,end=&#x27;&#x27;)print(&quot;panghu&quot;) //打印结果：my name is panghuprint(&quot;I&quot;,&quot;love&quot;,&quot;you&quot;,sep=&quot;!&quot;) //I!love!you import 当你确定要导入模块中的一切时，可使用from somemodule import *如果有两个模块，都包某一函数时，可使用as 12import math as foobarprint(foobar.sqrt(4)) //2.0 序列解包 1234values=1,2,3x,y,z=valuesprint(values) //(1,2,3)print(z) //3 *元素符：分配多余的值 12345values=1,2,3,4x,*y,z=valuesprint(x) // 1print(y) //[2,3]print(z) //4 条件语句中的布尔值 在Python的条件语句中，不止False``0表示假，None &quot;&quot; () [] &#123;&#125;都表示假 循环中的else子句 python中的break、continue和c语言中的功能一样。 break 语句可以跳出 for 和 while 的循环体。 continue 语句被用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 1234567n = 5while n &gt; 0: n -= 1 if n == 2: break print(n)print(&#x27;循环结束。&#x27;) 输出结果为 12343循环结束。 当将break换成continue时，输出结果是 123454310循环结束。 以上和c语言没什么不同，python循环语句有一点与c不同。 循环语句可以有else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。 打印100以内的素数： 12345678910num=[];i=2for i in range(2,100): j=2 for j in range(2,i): if(i%j==0): break else: num.append(i)print(num) 比较运算符 x is y x和y是同一个对象 x is not y x和y是不同的对象 x in y x是容器（如序列）y的成员 x not in y x不是容器（如序列）y的成员 1234x=y=[1,2,3]z=[1,2,3]print(x==z) //Trueprint(x is z) // False ==用来检查两个对象是否相等，而is用来检查两个对象是否相同（是同一个对象）。 遍历字典 123d = &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;for key in d: print(key, &#x27;corresponds to&#x27;, d[key]) 12for key, value in d.items(): print(key, &#x27;corresponds to&#x27;, value) zip() 一个很有用的并行迭代工具是内置函数zip，它将两个序列“缝合”起来，并返回一个由元组组成的序列。返回值是一个适合迭代的对象，要查看其内容，可使用list将其转换为列表。 123name=[&quot;panghu&quot;,&quot;daxiong&quot;,&quot;jiqimao&quot;]age=[20,21,22]print(list(zip(name,age))) //[(&#x27;panghu&#x27;, 20), (&#x27;daxiong&#x27;, 21), (&#x27;jiqimao&#x27;, 22)]","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://youngsay.cn/tags/Python/"}]},{"title":"ECMAScript 6入门","slug":"es6","date":"2021-10-31T04:25:01.000Z","updated":"2021-10-31T12:55:56.000Z","comments":true,"path":"2021/10/31/es6/","link":"","permalink":"https://youngsay.cn/2021/10/31/es6/","excerpt":"","text":"let var和let声明变量的区别： let声明的变量是块级变量，只存在{}内。 1234if(true)&#123; let a=0;&#125;console.log(a); 会出现Uncaught ReferenceError: a is not defined的报错，而在{}内打印console.log(a)而不会报错。 let声明的变量没有变量提升 12console.log(a);let a=0; 如上代码会报错Uncaught ReferenceError: Cannot access 'a' before initialization let声明的变量会出现暂时死区 在{}外用var声明变量，{}内用let声明一个相同的变量，{}外用var声明的变量便没有意义。 12345var a=10;if(true)&#123; console.log(a); let a=20;&#125; 如上代码依旧会报错Uncaught ReferenceError: Cannot access 'a' before initialization const 具有块级作用域 1234 if (true) &#123; const a = 10; &#125;console.log(a) // a is not defined 声明变量要赋值 1const PI; 未初始化会报错Uncaught SyntaxError: Missing initializer in const declaration 常量赋值后，简单数据类型值不能修改，复杂数据类型地址不能更改。 1234const a = [];a.push(&#x27;Hello&#x27;); // 可执行a.length = 0; // 可执行a = [&#x27;Dave&#x27;]; // 报错 解构赋值 数组结构 1234let [a,b,c]=[1,2,3];console.log(a); //1console.log(b); //2console.log(c); //3 对象结构 1234567let obj=&#123; name:&#x27;panghu&#x27;, age:20&#125;;let &#123;name,age&#125;=obj;console.log(name); //panghuconsole.log(age); //20 箭头函数=&gt; 12345const sum=(n1,n2)=&gt;&#123; n1+n2;&#125;const result=sum(10,20);console.log(result); 当键头后的{}内只有一个表达式，可去掉{}；当()里的参数只有一个，可去掉()。 123const al=v=&gt;alert(v) //al是函数名，v是函数形参const result=al(20)console.log(result); 剩余参数 12345sum=(a,...b)=&gt;&#123; console.log(a); //3 console.log(b); //[4,5]&#125;sum(3,4,5); 1234let students = [&#x27;胖虎&#x27;, &#x27;张三&#x27;, &#x27;李四&#x27;];let [s1, ...s2] = students; console.log(s1); // &#x27;胖虎&#x27; console.log(s2); // [&#x27;张三&#x27;, &#x27;李四&#x27;]","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"c语言：操作符误区总结","slug":"c-operator","date":"2021-10-24T14:31:01.000Z","updated":"2022-01-23T12:10:10.000Z","comments":true,"path":"2021/10/24/c-operator/","link":"","permalink":"https://youngsay.cn/2021/10/24/c-operator/","excerpt":"","text":"左移操作符：&lt;&lt; 左边丢弃，右边补0 12345678int main()&#123; int a = 2; //把a的二进制位向左移动一位 int b = a &lt;&lt; 1; printf(&quot;b = %d\\n&quot;, b);//输出为4 return 0;&#125; 右移操作符：&gt;&gt; 1.算术右移：右边丢弃，左边补原符号位 2.逻辑右移：右边丢弃，左边补0 1234567#include&lt;stdio.h&gt;int main()&#123; int a = -3; int b = a &gt;&gt; 1; printf(&quot;%d&quot;, b); //输出为-2&#125; 负数在内存中存放的是二进制的补码。 原码：直接根据数值写出的二进制序列 反码：符号位不变，其他位按位取反 补码：反码+1 以-3为例： 原码：10000000000000000000000000000011 反码：11111111111111111111111111111100 补码：11111111111111111111111111111101 异或：^ 同为0，异为1 练习：a=3，b=5，交换a、b两个数的值 方法1：创建中间变量 1234567891011#include&lt;stdio.h&gt;int main()&#123; int a = 3; int b = 5; int temp = 0; temp = a; a = b; b = temp; printf(&quot;a=%d,b=%d&quot;, a, b); //a=5,b=3&#125; 方法2：加减运算（数值太大可能溢出） 123456789int main()&#123; int a = 3; int b = 5; a = a + b; b = a - b; a = a - b; printf(&quot;a=%d,b=%d&quot;, a, b);&#125; 方法三：异或运算 12345678910#include&lt;stdio.h&gt;int main()&#123; int a = 3; int b = 5; a = a ^ b; b = a ^ b; a = a ^ b; printf(&quot;a=%d,b=%d&quot;, a,b);&#125; 同值异或值为0，任何值异或0都是值本身。a^a=0 0^a=a 单目运算符： sizeof也是单目运算符，可以计算变量所占空间的大小，单位是字节。 123456int a = 5;int arr[5] = &#123; 0 &#125;;printf(&quot;%d\\n&quot;, sizeof(a));//4 printf(&quot;%d\\n&quot;, sizeof(int));//4 printf(&quot;%d\\n&quot;, sizeof(arr));//20 sizeof(数组名)printf(&quot;%d\\n&quot;, sizeof(int [5]));//20 sizeof(数组类型) sizeof()，括号内可以说变量名，也可以是变量类型，如果是变量名可以去掉小括号，如sizeof a 思考一下下面这段代码，两次输出是什么？ 1234short s = 5;int a = 10;printf(&quot;%d\\n&quot;, sizeof(s = a + 2));printf(&quot;%d\\n&quot;, s); 输出结果是2、5。s的类型是short，sizeof(short)结果必然是2，而sizeof括号里的表达式不参与运算，所以s仍未5。 前置和后置： 1234int a = 10;int b = a++;//后置++，先使用，再++printf(&quot;%d\\n&quot;, a);//11printf(&quot;%d\\n&quot;, b);//10 1234int a = 10;int b = ++a;//前置++，先++，后使用printf(&quot;%d\\n&quot;, a);//11printf(&quot;%d\\n&quot;, b);//11 指针大小永远是4字节或8字节 123456789101112131415161718void test1(int arr[])//相当于int *arr&#123; printf(&quot;%d\\n&quot;, sizeof(arr));//4&#125;void test2(char ch[])//相当于char *arr&#123; printf(&quot;%d\\n&quot;, sizeof(ch));//4&#125;int main()&#123; int arr[10] = &#123; 0 &#125;; char ch[10] = &#123; 0 &#125;; printf(&quot;%d\\n&quot;, sizeof(arr));//40 printf(&quot;%d\\n&quot;, sizeof(ch));//10 test1(arr); test2(arr); return 0;&#125; 结构成员访问操作符：. -&gt; . 结构体.成员名 -&gt; 结构体指针-&gt;成员名 12345678910111213141516#include&lt;stdio.h&gt;struct students&#123; //结构体的成员（变量） char name[10]; int age;&#125;;int main()&#123; struct students a = &#123; &quot;胖虎&quot;,20 &#125;; struct students *pb = &amp;a; //说明pb是struct students类型的指针 //结构体变量名.成员名 printf(&quot;姓名：%s，年龄：%d\\n&quot;, a.name,a.age); //结构体指针-&gt;成员名 printf(&quot;姓名：%s，年龄：%d&quot;, pb-&gt;name,pb-&gt;age);&#125; 整型提升： C的整型算术运算总是至少以缺省整型类型的精度来进行的。 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。 12345678910111213141516171819int main()&#123; char a = 3; //0000000000000000000000000000011 (int a) //00000011 --a //0000000000000000000000000000011 (a的整型提升) char b = 127; //0000000000000000000000001111111 (int b) //01111111 --b //0000000000000000000000001111111 (b的整型提升) //0000000000000000000000010000010 int c //10000010 --c //1111111111111111111111110000010 补码 (c的整型提升) //1000000000000000000000001111101 反码 //1000000000000000000000001111110 原码 char c = a + b; printf(&quot;%d&quot;, c); return 0;&#125; 整形提升是按照变量的数据类型的符号位来提升的 1234567891011121314151617//负数的整形提升char c1 = -1;变量c1的二进制位(补码)中只有8个比特位：1111111因为 char 为有符号的 char所以整形提升的时候，高位补充符号位，即为1提升之后的结果是：11111111111111111111111111111111//正数的整形提升char c2 = 1;变量c2的二进制位(补码)中只有8个比特位：00000001因为 char 为有符号的 char所以整形提升的时候，高位补充符号位，即为0提升之后的结果是：00000000000000000000000000000001//无符号整形提升，高位补0 总结：char和short类型，在参与表达式运算时达不到整型长度，会发生整型提升。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"c语言：数组误区总结","slug":"c-array","date":"2021-10-22T12:31:01.000Z","updated":"2022-01-23T12:10:24.000Z","comments":true,"path":"2021/10/22/c-array/","link":"","permalink":"https://youngsay.cn/2021/10/22/c-array/","excerpt":"","text":"创建数组时，数组的长度必须用常量表达式进行定义，较好的方法是用宏来定义数组。 12#define N 10;int arr[N]; 但在C99中的变长数组，也可以使用非常量表达式。 关于字符数组的初始化，使用方法2初始化数组会在末尾自动创建\\0。 12char ch1[] = &#123; &#x27;p&#x27;,&#x27;a&#x27;,&#x27;n&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;u&#x27; &#125;;char ch2[] = &quot;panghu&quot;; 这就会导致打印结果、字符串长度的不同。 strlen() 函数从字符串的开头位置依次向后计数，直到遇见\\0，然后返回计时器的值。最终统计的字符串长度不包括\\0。 12345678910#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char ch1[] = &#123; &#x27;p&#x27;,&#x27;a&#x27;,&#x27;n&#x27;,&#x27;g&#x27;,&#x27;h&#x27;,&#x27;u&#x27; &#125;; char ch2[] = &quot;panghu&quot;; printf(&quot;%s,%d\\n&quot;, ch1, strlen(ch1)); printf(&quot;%s,%d\\n&quot;, ch2,strlen(ch2)); return 0;&#125; 因为数组ch1没有添加终止符\\0，打印内容出现了意外，字符串长度也是一个随机数。 由数组中各元素的地址可知，一维数组在内存中是连续存放的，随着数组下标的增长，地址由低到高变化。（二维数组也是如此） 12345678910#include &lt;stdio.h&gt;int main()&#123; int arr[10] = &#123; 0 &#125;; int i = 0; for (i = 0; i &lt; 10; i++) &#123; printf(&quot;&amp;arr[%d]=%p\\n&quot;, i,&amp;arr[i]); &#125; return 0;&#125; 所以当我们知道数组中首元素的地址，便可以打印出所有元素。 123456789101112#include &lt;stdio.h&gt;int main()&#123; int arr[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; int *p = arr; int i = 0; for (i = 0; i &lt; 10; i++) &#123; printf(&quot;arr[%d]=%d\\n&quot;,i, *p); p++; &#125; return 0;&#125; 关于arr和&amp;arr： 12345int arr[] = &#123; 0,1,2,3,4 &#125;;printf(&quot;%p\\n&quot;, arr); //首元素地址printf(&quot;%p\\n&quot;, &amp;arr[0]);printf(&quot;%d\\n&quot;, sizeof(arr)); //整个数组的大小printf(&quot;%p\\n&quot;, &amp;arr); //整个数组的地址 数组名是首元素的地址。 sizeof(数组名)表示的是整个数组的大小，单位是字节。 &amp;数组名表示的是整个数组，取出的是整个数组的地址。 首元素地址和数组地址的值是一样的，但意义不同，可以试着输出&amp;数组名+1和数组名+1，进行比较。 数组作为函数传参时，形参可以写成两种形式： 一是数组形式，二是指针形式。 12345678int arr[10];//函数定义void test(int arr[10]) //写法②：void test(int *arr)&#123;&#125;&#123; ……&#125;test(arr); //函数调用","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"WebApiⅢ：事件、事件对象","slug":"js-shijian","date":"2021-09-16T09:45:54.000Z","updated":"2021-09-16T13:07:36.000Z","comments":true,"path":"2021/09/16/js-shijian/","link":"","permalink":"https://youngsay.cn/2021/09/16/js-shijian/","excerpt":"","text":"注册事件 传统方式 btn.onclick = function() &#123;&#125; 传统事件注册具有唯一性：同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 方法监听注册方式 1eventTarget.addEventListener(type,listener[,useCapture]) type：事件类型字符串，比如 click、mouseover。这里不需要加on listener：事件处理函数，事件发生时，会调用该监听函数 useCapture：可选参数，是一个布尔值，默认是false。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;button&gt; 传统注册事件 &lt;/button&gt; &lt;button&gt; 事件监听注册事件 &lt;/button&gt; &lt;script&gt; var btns = document.querySelectorAll(&#x27;button&#x27;); //传统注册事件 btns[0].onclick = function()&#123; alert(&#x27;hi&#x27;); &#125; btns[0].onclick = function()&#123; alert(&#x27;传统注册事件&#x27;); &#125; //运行程序，点击传统注册事件按钮，弹出提示框：传统注册事件。第一个hi提示框被覆盖，不会弹出。 //事件侦听注册事件 btns[1].addEventListener(&#x27;click&#x27;,function()&#123; alert(&#x27;事件监听注册事件&#x27;); &#125;) btns[1].addEventListener(&#x27;click&#x27;,function()&#123; alert(&#x27;事件监听注册事件2&#x27;); &#125;) //运行程序，点击事件监听注册事件按钮，弹出提示框：事件监听注册事件，点击确定后，再次弹出“事件监听注册事件2”的提示框 //在事件侦听注册事件的方法中事件类型要加引号并且没有on &lt;/script&gt;&lt;/body&gt; 删除事件 传统方式 eventTarget.onclick = null; 方法监听注册方式 1eventTarget.removeEventListener(type,listener[,useCapture]) 1234567891011121314151617&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt; var divs = document.querySelectorAll(&#x27;div&#x27;); divs[0].onclick = function() &#123; alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; &#125; // 2. removeEventListener 删除事件 divs[1].addEventListener(&#x27;click&#x27;, fn) // 里面的fn 不需要调用加小括号 function fn() &#123; alert(22); divs[1].removeEventListener(&#x27;click&#x27;, fn); &#125;&lt;/script&gt; DOM事件流 事件流描述的是从页面接受事件的顺序，这个传播顺序就是DOM事件流。 DOM事件流会历经 捕获阶段、当前目标阶段、冒泡阶段 这三个阶段 js代码只能执行捕获或冒泡其中的一个阶段 onclick、attachEvent只有冒泡阶段 addEventListener(type,listener,true)表示在事件捕获阶段调用事件处理程序，如果第三个参数是false表示在事件冒泡阶段调用事件处理程序。 事件冒泡 12345678910111213141516171819202122&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // onclick 和 attachEvent（ie） 在冒泡阶段触发 // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 // son -&gt; father -&gt;body -&gt; html -&gt; document var son = document.querySelector(&#x27;.son&#x27;); // 给son注册单击事件 son.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;son&#x27;); &#125;, false); // 给father注册单击事件 var father = document.querySelector(&#x27;.father&#x27;); father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, false); // 给document注册单击事件，省略第3个参数 document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;)&lt;/script&gt; 事件捕获 123456789101112131415161718192021&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发 // document -&gt; html -&gt; body -&gt; father -&gt; son var son = document.querySelector(&#x27;.son&#x27;); // 给son注册单击事件，第3个参数为true son.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;son&#x27;); &#125;, true); var father = document.querySelector(&#x27;.father&#x27;); // 给father注册单击事件，第3个参数为true father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, true); // 给document注册单击事件，第3个参数为true document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;, true)&lt;/script&gt; 事件对象 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。 比如： 谁绑定了这个事件。 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。 123456789&lt;div&gt;123&lt;/div&gt;&lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); div.onclick = function(e) &#123; // 事件对象 可以写成e、evt、event e = e || window.event; //兼容性写法 console.log(e); &#125;&lt;/script&gt; 事件对象的属性和方法 123456789101112131415&lt;ul&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector(&#x27;ul&#x27;); ul.addEventListener(&#x27;click&#x27;, function(e) &#123; // 我们给ul 绑定了事件 那么this 就指向ul console.log(this); // ul // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li console.log(e.target); // li &#125;);&lt;/script&gt; 阻止默认行为 html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。 1234567891011121314151617&lt;a href=&quot;https://blog.wangyouwu.cn&quot;&gt;胖虎同学&lt;/a&gt;&lt;script&gt; // 2. 阻止默认行为 让链接不跳转 var a = document.querySelector(&#x27;a&#x27;); a.addEventListener(&#x27;click&#x27;, function(e) &#123; e.preventDefault(); // dom 标准写法 &#125;); // 3. 传统的注册方式 a.onclick = function(e) &#123; // 普通浏览器 e.preventDefault(); 方法 e.preventDefault(); // 低版本浏览器 ie678 returnValue 属性 e.returnValue = false; // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 return false; &#125;&lt;/script&gt; 阻止事件冒泡 12345678910111213141516171819202122&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector(&#x27;.son&#x27;); // 给son注册单击事件 son.addEventListener(&#x27;click&#x27;, function(e) &#123; alert(&#x27;son&#x27;); e.stopPropagation(); // stop 停止 Propagation 传播 window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 &#125;, false); var father = document.querySelector(&#x27;.father&#x27;); // 给father注册单击事件 father.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;father&#x27;); &#125;, false); // 给document注册单击事件 document.addEventListener(&#x27;click&#x27;, function() &#123; alert(&#x27;document&#x27;); &#125;) &lt;/script&gt; 事件委托 事件委托也称为事件代理，在 jQuery 里面称为事件委派。 给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。 123456789101112131415&lt;ul&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt; &lt;li&gt;点我一下试试&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector(&#x27;ul&#x27;); ul.addEventListener(&#x27;click&#x27;, function(e) &#123; // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = &#x27;pink&#x27;; &#125;)&lt;/script&gt; 常用鼠标事件 禁止鼠标右键 contextmenu 禁止鼠标选中 selectstar 12345678910111213&lt;body&gt; 休想复制我 &lt;script&gt; // 1. contextmenu 禁用右键菜单 document.addEventListener(&#x27;contextmenu&#x27;, function(e) &#123; e.preventDefault(); &#125;) // 2. selectstart 禁止选中文字 document.addEventListener(&#x27;selectstart&#x27;, function(e) &#123; e.preventDefault(); &#125;) &lt;/script&gt;&lt;/body&gt; 鼠标事件对象 12345678910111213141516171819&lt;script&gt; // 鼠标事件对象 MouseEvent document.addEventListener(&#x27;click&#x27;, function(e) &#123; // 1. client 鼠标在可视区的x和y坐标 console.log(e.clientX); console.log(e.clientY); console.log(&#x27;---------------------&#x27;); // 2. page 鼠标在页面文档的x和y坐标 console.log(e.pageX); console.log(e.pageY); console.log(&#x27;---------------------&#x27;); // 3. screen 鼠标在电脑屏幕的x和y坐标 console.log(e.screenX); console.log(e.screenY); &#125;) &lt;/script&gt; 常用键盘事件 onkeypress不识别功能键，如shift等，但区分大小写 三个事件执行顺序：keydown、keypress、keyup 1234567891011121314151617&lt;script&gt; // 常用的键盘事件 //1. keyup 按键弹起的时候触发 document.addEventListener(&#x27;keyup&#x27;, function() &#123; console.log(&#x27;我弹起了&#x27;); &#125;) //3. keypress 按键按下的时候触发 不能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#x27;keypress&#x27;, function() &#123; console.log(&#x27;我按下了press&#x27;); &#125;) //2. keydown 按键按下的时候触发 能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#x27;keydown&#x27;, function() &#123; console.log(&#x27;我按下了down&#x27;); &#125;) // 4. 三个事件的执行顺序 keydown -- keypress -- keyup&lt;/script&gt; 键盘事件对象 12345678910111213141516&lt;script&gt; // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值 document.addEventListener(&#x27;keyup&#x27;, function(e) &#123; console.log(&#x27;up:&#x27; + e.keyCode); // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键 if (e.keyCode === 65) &#123; alert(&#x27;您按下的a键&#x27;); &#125; else &#123; alert(&#x27;您没有按下a键&#x27;) &#125; &#125;) document.addEventListener(&#x27;keypress&#x27;, function(e) &#123; // console.log(e); console.log(&#x27;press:&#x27; + e.keyCode); &#125;)&lt;/script&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"WebApiⅡ：自定义属性、节点","slug":"js-node","date":"2021-09-13T13:45:54.000Z","updated":"2021-09-16T09:05:24.000Z","comments":true,"path":"2021/09/13/js-node/","link":"","permalink":"https://youngsay.cn/2021/09/13/js-node/","excerpt":"","text":"自定义属性 获取属性值 element.属性 ：获取内置属性值 element.getAttribute(‘属性’) ：获取自定义属性值 12345678910&lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); // 1. 获取元素的属性值 // (1) element.属性 console.log(div.id); //demo //(2) element.getAttribute(&#x27;属性&#x27;) console.log(div.getAttribute(&#x27;id&#x27;)); //demo console.log(div.getAttribute(&#x27;index&#x27;)); //1&lt;/script&gt; 设置属性值 element.属性 = ‘属性值’ element.setAttribute (‘属性’,‘属性值’) ：设置自定义属性值 123456// (1) element.属性= &#x27;值&#x27; div.id = &#x27;test&#x27;; div.className = &#x27;navs&#x27;;// (2) element.setAttribute(&#x27;属性&#x27;, &#x27;值&#x27;); 主要针对于自定义属性 div.setAttribute(&#x27;index&#x27;, 2); div.setAttribute(&#x27;class&#x27;, &#x27;footer&#x27;); 移除属性 element.removeAttribute ('属性') h5自定义属性 自定义属性获取是通过getAttribute(‘属性’) 获取。 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 1234567891011121314151617&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;&lt;script&gt; var div = document.querySelector(&#x27;div&#x27;); // console.log(div.getTime); console.log(div.getAttribute(&#x27;getTime&#x27;)); div.setAttribute(&#x27;data-time&#x27;, 20); console.log(div.getAttribute(&#x27;data-index&#x27;)); console.log(div.getAttribute(&#x27;data-list-name&#x27;)); // h5新增的获取自定义属性的方法 它只能获取data-开头的 // dataset 是一个集合里面存放了所有以data开头的自定义属性 console.log(div.dataset); console.log(div.dataset.index); console.log(div.dataset[&#x27;index&#x27;]); // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法 console.log(div.dataset.listName); console.log(div.dataset[&#x27;listName&#x27;]);&lt;/script&gt; 节点 网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 元素节点 nodeType 为1 属性节点 nodeType 为2 文本节点 nodeType 为3（文字、空格、换行） 实际开发中，节点操作主要操作元素节点 父级节点 node.parentNode parentNode返回某节点的父节点（最近的），没有则返回null 12345678&lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;dad&quot;&gt; &lt;span class=&quot;son&quot;&gt;×&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; console.log(son.parentNode); &lt;/script&gt; 子节点 parentNode.chlidNodes(标准) 返回值包含所有子节点，包括元素、文本节点等，so一般不用childNodes parentNode.children(非标准) 返回值只有元素字节，so提倡用children 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;胖虎同学&lt;/li&gt; &lt;li&gt;panghutx&lt;/li&gt; &lt;li&gt;www.wangyouwu.cn&lt;/li&gt; &lt;li&gt;blog.wangyouwu.cn&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // DOM 提供的方法（API）获取 var ul = document.querySelector(&#x27;ul&#x27;); var lis = ul.querySelectorAll(&#x27;li&#x27;); // 1. 子节点 childNodes 所有的子节点 包含 元素节点 文本节点等等 console.log(ul.childNodes); console.log(ul.childNodes[0].nodeType); //3 console.log(ul.childNodes[1].nodeType); //1 // 2. children 获取所有的子元素节点 也是我们实际开发常用的 console.log(ul.children); console.log(ul.children[0]); //第一个li console.log(ul.children[ul.children.length - 1]);//最后一个li&lt;/script&gt; 创建/添加节点 创建节点 document.creatElement('tagName') 添加节点 node.appendChild(child) 将节点添加到父节点的子节点列表末尾 node.inserBefore(child,指定元素) 将节点添加到父节点的子节点列表开头 1234567891011121314&lt;ul&gt; &lt;li&gt;胖虎同学&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1. 创建节点元素节点 var li = document.createElement(&#x27;li&#x27;); // 2. 添加节点 node.appendChild(child) node 父级 child 是子级 后面追加元素 var ul = document.querySelector(&#x27;ul&#x27;); ul.appendChild(li); // 3. 添加节点 node.insertBefore(child, 指定元素); var lili = document.createElement(&#x27;li&#x27;); ul.insertBefore(lili, ul.children[0]); // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素&lt;/script&gt; 删除节点 node.removeChild() 从node节点中删除子节点，返回的是删除节点 123456789101112131415161718192021&lt;button&gt;删除&lt;/button&gt; &lt;ul&gt; &lt;li&gt;胖虎&lt;/li&gt; &lt;li&gt;胖虎同学&lt;/li&gt; &lt;li&gt;胖虎同学的博客&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1.获取元素 var ul = document.querySelector(&#x27;ul&#x27;); var btn = document.querySelector(&#x27;button&#x27;); // 2. 删除元素 node.removeChild(child) // ul.removeChild(ul.children[0]); // 3. 点击按钮依次删除里面的孩子 btn.onclick = function() &#123; if (ul.children.length == 0) &#123; this.disabled = true; &#125; else &#123; ul.removeChild(ul.children[0]); &#125; &#125; &lt;/script&gt; 克隆节点 node.cloneNode() 如果括号参数为空或false，则为浅拷贝，只克隆节点本身，不克隆里面的子节点 括号参数为true，则为深拷贝，会克隆字节本身以及里面所有子节点 123456789101112&lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector(&#x27;ul&#x27;); // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容 // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容 var lili = ul.children[0].cloneNode(true); ul.appendChild(lili);&lt;/script&gt; DOM重点总结 文档对象模型（Document Object Model），处理可拓展标记语言的编程接口，可以改变网页内容、结构、样式。 关于DOM操作，主要针对元素操作，主要有创建、增删改查、属性操作、实践操作。 创建： document.write innerHTML creatElement 增加 appendChild insertBefore 删除 removeChild 改 查 属性操作 事件操作","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"读《认知觉醒》","slug":"read-renzhi","date":"2021-09-05T10:49:01.000Z","updated":"2025-10-10T08:21:22.000Z","comments":true,"path":"2021/09/05/read-renzhi/","link":"","permalink":"https://youngsay.cn/2021/09/05/read-renzhi/","excerpt":"","text":"年轻的时候，人人都自命不凡，认定美好生活会自然到来。后来他们不得不敲碎那颗高傲的心，在无奈和叹息中接受平庸的自己。 杨绛说：“你的问题在于想得太多，读书太少”。学而不思则罔，思而不学则怠，学习和思考是缺一不可的。看完《认知觉醒》，我觉得还有一点更重要的，行动。“道理我都懂，就是做不到”，“听过很多道理，依然过不好这一生”，都是因为缺少行动。懂得百点不如改变一点，真正的成长不是懂得多少道理，而是做出多少改变。 做出行动和改变 急于求成、避难趋易是人的天性。从难度上来讲，阅读&lt;思考&lt;行动，一些人往往选择最简单的阅读，却不愿行动，这是避难趋易的天性；读完一本书马不停蹄地读下一本，没有思考和行动，却又想立刻见到成效，这是急于求成的天性。就功课的学习而言，我喜欢看视频学习，很少刷题。我知道刷题能取得更快的提升，但我还是看视频来麻木自己。因为相对刷题，看视频是更省力的方式，这都是避难趋易的天性在作怪。所以一件事如何去做，不必去找什么方法技巧，你最不愿意尝试的那个就是最有效的方法。什么最重要，每个人都心知肚明，却不愿面对，人们愿意活在自己的舒适区。 正确的行动往往是反天性的，让你觉得舒服和容易的事往往得不到好结果， 而一开始你认为难受和困难的事才能让你真正产生收获， 活在舒适区边缘 活在轻车熟路的舒适区不会有任何提升，闯入望尘莫及的困难区也很难进步，我们应该在舒适区边缘不断试探。在舒适区边缘，既有挑战又有成就，能够不断扩宽自己舒适区的边界。如果只是阅读，就是单纯的输入，这是活在自己的舒适区，不会有成效。而阅读时的思考，思考后的改变，就是在舒适区的边缘试探，虽然有挑战但有收获。很多人的焦虑痛苦就是只顾着表层的学习，努力到感动自己，却一直没有跳出舒适区。如果不关注思考、行动、改变，就不会学有所获，还会怀疑是自己学的不够，陷入“越学越焦虑”的怪圈。 “多即是少，少即是多”，停在表层，我们就会陷入欲望漩涡，什么都想学、什么都想要，忙忙碌碌却收效甚微；若是能深入底层，盯住实际改变，我们就能跳出盲目、焦虑、浮躁的怪圈。 读一本书，不求记住多少知识。哪怕一个观点对你有益，让你因此改变，这就够了，因为你已经走出了舒适区。舒适区边缘10%的努力，也要胜过舒适区100%的努力（自我欺骗）。活在舒适区边缘，不专注表面，就会走出焦虑怪圈。怕什么真理无穷，进一步有进一步的欢喜。 找寻更好的视角 无论你当前处于何种情绪旋涡，只要自己愿意， 总能找到更好的角度。 只是有的人面对再好的事情时都盯着一点瑕疵不放， 而有的 人却能从任何一件糟糕的事情中找到闪光点并放大，忽视其他不足之处。 就像《被讨厌的勇气》所说的，要寻找更大的共同体。不要拘泥于一个共同体，不要只看到一个视角。身处逆境，有的人深陷其中不能自拔，有的人处在逆境却不自知，反而乐在其中。一辆车停在那里不动，我们可以找到一个更好的角度去拍摄它。一件事也许不能改变，但我们可以改变看待事情的态度。就像”塞翁失马，焉知非福“，”祸兮福所倚，福兮祸所伏“，”反者道之动“，这都是事物发展的规律、是哲学的智慧，不是一种自我欺骗。即使有人仍认为这是一种自我欺骗，但我们每天不都是在自我欺骗吗。人就是解释型动物，活着有意义吗，人们为了有意义，赋予了活着的意义；世界有意义吗，人们为了有意义，赋予了世界的意义。 tips “ 刻意练习四要素”：定义明确的目标、极度的专注、有效的反馈、在拉伸区练习。 时常问自己：这个道理还能用在什么地方？ 游戏心态：我不是在做这件事，我是在做另一件事。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"读《你的第一本哲学书》","slug":"read-allmeans","date":"2021-08-20T12:49:01.000Z","updated":"2025-10-10T08:21:08.000Z","comments":true,"path":"2021/08/20/read-allmeans/","link":"","permalink":"https://youngsay.cn/2021/08/20/read-allmeans/","excerpt":"","text":"引言 《你的第一本哲学书》是本很精简的哲学入门书，没有专业术语，没有各种学派，直接面向最基本的哲学问题。看译后记发现个有趣的事：原著书名是“What does it all mean”，译者综合考虑译为《哲学冒险》，结果出版社考虑对读者的吸引力，起名为“你的第一本哲学书”😂 我们每天都使用一些平常的概念，却从未加以反思；而哲学的主要工作就是去询问和理解这些概念。 你要探究的概念越是基础，可以帮助你的工具也就越是匮乏。 以我的能力读这本书还是很费力，作者谈及的都是一些习以为常的事情，都是在平时没有思考过而默认的概念。 自由意志 假设在学习和娱乐面前，我选择了娱乐。期末考试要来了，我后悔地说道：“我本可以好好学习”。 “我本可以好好学习”这句话什么意思？在同样的时间、环境、条件下，我仍然可以选择学习。人们在外在条件一模一样的情况下，并不需要发生任何不同的事情作为前提，就能够做某些他们实际上并没有做的事情。这意味着什么呢？ 这说明在选择娱乐之前，学习仍是开放的可能性，选择学习还是娱乐是由我的自由意志决定的，不由外界决定。 不过，决定论认为我们做什么事情都是事先决定好的，永远也不可能做实际上所没有做的事。 世界上所发生的一切事情都是被自然法则所主宰的，就好像行星的运动被自然法则所主宰一样，一个行为的诸多条件正是通过这些自然法则的安排，才能够决定这个行为，并且排除掉其他一切可能性。 如果真是这样，那很可怕。当我想学习还是娱乐时，我的选择已经被决定，娱乐还是学习这一想法只不过是事先被决定的结果在我的意识中出现的过程。在我出生之前，我这一时刻选择娱乐的决定已经被决定，我的选择是直接被前一刻的情境所决定的，而前一刻的情境又是被再往前一刻的情境所决定的，这样可以无穷追溯下去。 如果真是这样，”我本可以好好学习“这句话毫无意义。这都是被决定好的。我不能责备自己没有好好学习，更不能决定罪犯，惩罚坏人便没有意义。因为一个人做了他绝不可能不做的事而去惩罚他，这是没有意义的。 如果决定论是真的，社会秩序将荡然无存，人类的一切行为也没有了意义。决定论是否正确，我们不得而知。 假设决定论是假的，”我本可以好好学习“这句话又是什么意思？你相信是你通过做出选择，决定了自己将要做什么。这一选择并非事先被决定，但是也不是自己发生的。你选择了它，并且你也能够选择别的。但是这又意味着什么？ 一些人认为，这个问题没有答案。自由行为是世界上的一种基本特性，不能够再加以分解。某件事情不需要原因而发生，和一个行为不需要原因而被人做出，二者间有着微妙的不同。 即使我们的选择并非事先已被决定，我们以何种方式能够做我们实际上所没有做的事情，仍然很难理解。两种选择在事先皆有可能，但是除非是“我”决定选其中某个，否则我仍然不需要对这种选择负责，正如如果它是被在我之外的原因所决定的，我不需要为此负责一样。如果决定论是正确的，先前的条件就该为我们的行为负责，如果决定论是错误的，就没什么东西要负责了。 …… 死亡 人终会死去，我们无法想象死后的样子。 如果二元论正确，人是由身体和灵魂组成，身体和灵魂时独立的，身体死后灵魂会不会离开身体，依附一个新的身体而存在。即使二元论正确，也可能不存在死后生活，灵魂很可能完全依赖身体。 如果二元论是错的，就不存在死后生活。 我们以何种态度面对自己的死亡？如果不存在死后生活，死亡就是一了百了，我们又是什么态度？ 书中写道，必然是一种消极的善或者恶。换句话说，它是一片虚无，如果是好的，那么一定是因为它避免了某种坏事（例如无聊或痛苦），如果是坏的，也一定是因为它失去了某种好事（例如在世时有趣的或愉悦的体验）。 如果死后就是一了百了，这也许并不可怕。在我们出生之前的漫长岁月里，世界如常存在，但是却没有我们，对此我们安之若素。那么，想到我们死后就不复存在，这又有什么可怕的呢？ 人生的意义 我认为，人生不论有无意义，这都毫无意义。无论有无意义，我们照样过着自己的日子。 但总有人把自己看得很重要，他希望自己的人生整体从外在看，也具有意义。 许多人活着不只是为了活下去和过得舒适，而是为了满足自己的雄心壮志，付出了种种艰辛努力，其心理动力往往就是来自于一种“重要感”。这种感觉就是：你所做的一切不只是对你来说才重要，在某种更大的意义上来说，它本身就很重要。如果我们放弃了这种重要感，我们就不再能鼓起前进的风帆。如果浮生若梦，万事无常，最终都归于尘土，那么也许我们的雄心壮志不过徒然为荒诞不经的玩笑而已。 从另一方面来说，如果我们无可救药地执着于自己的意义，或许也只能安于自身的可笑。也许生命不仅没有意义，而且也是一出荒诞剧？","categories":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"《穷爸爸 富爸爸》读书分享","slug":"read-richdad","date":"2021-08-20T07:49:01.000Z","updated":"2025-10-10T08:22:36.000Z","comments":true,"path":"2021/08/20/read-richdad/","link":"","permalink":"https://youngsay.cn/2021/08/20/read-richdad/","excerpt":"","text":"前言 《穷爸爸 富爸爸》是暑假读的第二本书，关于这本书也褒贬不一。取其精华，去其糟粕。关于财富，书中提到：**财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久？**财富的增加不是依靠收入，而是资产的积累。头脑是真正的资产，要养成终身学习的习惯，再次引用书中一段话：轻松的道路往往会越走越艰难，而艰难的道路往往会越走越轻松。 不为钱而工作 人们为了实现欲望而工作。他们认为钱能买来快乐，可用钱买来的快乐往往是短暂的，所以不久他们就需要更多的钱来买更多的快乐、更多的开心、更多的舒适和更多的安全感。于是他们继续工作，以为钱能安抚他们备受恐惧和欲望折磨的灵魂，但实际上钱是无法做到这一点的。 **工作只是试图用暂时的办法来解决长期的问题。**钱控制了他们的生活，确切地说是，对钱的无知和恐惧控制了他们的生活。所以他们拼命工作。他们的思想被他们的感情，而不是他们的头脑控制着。” 不为钱而工作不是说不在乎钱，不谈钱就像依赖钱一样是一种精神上的疾病。我们不能陷入为钱工作的死循环，要看到他人看不到的东西。 资产和负债 书中写道：资产是能把钱放进你口袋里的东西。负债是把钱从你口袋里取走的东西。 也就是说，资产带来收入，负债带来支出。 增加财富就是要积累资产。拼命工作增加的只是收入，将收入买入资产还是负债，抑或支出，划分了穷人、中产阶级和富人。 富人买入资产。 穷人只有支出。 中产阶级购买自以为是资产的负债。 一个受过高等教育的人，也可能是财务上的文盲。他们努力工作，却不知道如何让钱为自己工作，甚至不知道他们真正的问题在于他们选择的消费方式，那才是他们在财务困境中苦苦挣扎的原因。 书中有这样一段话： 日本人注重3种力量：剑、宝石和镜子。 剑象征着武器的力量。美国人在武器上已经花了上千亿美元，是世界上的超级军事大国。 宝石象征着金钱的力量。有句格言很有道理：“记住黄金规则：有黄金的人制定规则。” 镜子象征着自知的力量。从日本的传奇故事中我们得知，自知是3种力量中最宝贵的。 穷人和资产阶级往往被金钱控制着，却不相信自知的力量。人们总是不相信自己内在的智慧，只会随波逐流，人云亦云。**他们做事情只是因为其他人也这么做，他们总是服从而不去提问。**他们总是轻率地重复别人告诉他们的东西，例如：“分期付款”、“你的房子就是你的资产”、“你的房子是你最大的投资”、“欠债可以抵税”、“找一个稳定的工作”、“别犯错误”、“别冒险”之类的话。他们害怕与别人不同。大多数人热衷于“稳定”是出于恐惧。 学校的教育也是一样，学校教育我们就像企业的流水线产品，被要求循规蹈矩，所以说学校是生产好雇员而不是好雇主的地方。 关注自己的事业 什么是自己的事业，你的事业不是你的工作，如果你把工作当成事业，便会耗尽一生去关注别人的事业并使他人致富。你事业的重心是你的资产项，而不是收入项。夫人关心的是资产而其他人关心的是收入。 麦当劳的创始人雷·克罗克说，我的事业不是做汉堡🍔，而是房地产。在他的商业计划中，麦当劳的大额收入来源是出售分店所得的费用。 教育比金钱更有价值 书中有个有意思的观点，job=just over broke，工作一次就是比破产强一点。工人付出最大努力以免于被解雇，而雇主提供最低工资以防止工人辞职。即使这样，也没人敢不满，他们只想找一份稳定的工作，大部分人都是为了短期的工资和福利工作。你越努力工作，老板也就越富有。 相反，工作是为了能力的提升，要弄清自己想要获得什么技能，不要为钱而工作。从长远看，教育比金钱更有价值。 克服困难 掌握财务知识的人却不能积累丰厚的资产项，其主要原因书中列举了5个，这里举出两个。 恐惧心理 投资有风险，没有人会一直成功。要克服恐惧心理，正视失败。对于胜利者，失败会激励他们；对于失败者，失败则会击垮他们。他们在财务上不成功是因为对他们而言亏钱所造成的痛苦远远大于致富所带来的乐趣。 愤世嫉俗 书中谈到小鸡的故事，“天要塌下来了，天要塌下来了”，小鸡总是围着谷仓转，警告大家即将到来的厄运。我们知道有的人也爱这么做，其实我们每个人的心里也都有一只“小鸡”。愤世嫉俗的人就像“小鸡”一样，每当心里害怕、怀疑的时候，他们就会像“小鸡”一样杞人忧天。愤世者抱怨现实，而成功者分析现实。我们需要极大的勇气，不让谣言和杞人忧天的怀疑加剧我们的恐惧和疑虑。","categories":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"读《被讨厌的勇气》","slug":"read-courage","date":"2021-08-20T03:49:01.000Z","updated":"2025-10-10T08:20:38.000Z","comments":true,"path":"2021/08/20/read-courage/","link":"","permalink":"https://youngsay.cn/2021/08/20/read-courage/","excerpt":"","text":"『因为拥有了被讨厌的勇气，于是有了真正幸福的可能』 前言 暑假快结束了，想为假期读过几本书写几篇读书笔记。暑假读的第一本书是《被讨厌的勇气》，书中有很多启发我的观点。其中之一是自卑和自卑情结，这我在之前谈到过；还有一个是对人生的描述，人生是点状的，是每一个刹那，不是一条线、一个整体。书中还有个有趣的比喻：当你站在舞台上，聚光灯打向你，你什么也看不见。当聚光灯打向“此时此刻”，也就看不到过去和将来。书中很难理解和践行的是共同体的概念，要做到自我接纳、他者信任和他者贡献。用了一上午时间，略读了一遍，不知不觉写了3000字。 像《理想国》一样，这本书由现代不常用的对话体写就，通过哲人和青年五夜的对话，向我们阐释了阿德勒心理学。 不幸来源 弗洛伊德的原因论认为，过去决定了现在的我们，现在的不幸、行为都能在过去找到原因，如果是这样，我们将没有能力改变现状，我们将是无力、痛苦的。阿德勒心理学否认了弗洛伊德的原因论，他认为过去并不重要，重要的是我们赋予过去的意义。你的不幸、痛苦不是因为过去，而是因为你的选择。 「你在人生的某个阶段里选择了“不幸”。这既不是因为你生在了不幸的环境中，也不是因为你陷入了不幸的境地中，而是因为你认为“不幸”对你自身而言是一种“善”。」 就像“弱者”常常利用自己的弱者优势，站在道德制高点。阿德勒指出：“在我们的文化中，弱势其实非常强大而且具有特权。”就像田园女👊一样，义务和责任避而不谈，大搞“按闹分配”，我不行，我不做，你要为我做，你要为我担责。而女权主义是我能行，我要做，我去做，我担责，我争取权益，我实现自我。 「阿德勒的目的论是说：“无论之前的人生发生过什么，都对今后的人生如何度过没有影响。”决定自己人生的是活在“此时此刻”的你自己。」 人际关系 「之所以感觉孤独并不是因为只有你自己一个人，感觉自己被周围的他人、社会和共同体所疏远才会孤独。我们要想体会孤独也需要有他人的存在。也就是说，人只有在社会关系中才会成为“个人”。」 就像孤独是个群体概念，有了他人的存在，才有孤独的存在。阿德勒提出，人的烦恼皆源于人际关系。如果宇宙中没有他人只有自己，那么一切烦恼将会消失。这和后面提到的共同体并不冲突。我们过分在意他人的看法，甚至有些人是在为他人而活，觉得自己的一举一动都会被别人关注。事实上，在意你的，只有你自己。 阿德勒心理学是勇气心理学，也是“使用的心理学”。提出人的烦恼皆源于人际关系，是让你不过分在乎他人的看法，为自己而活。 课题分离 「首先要思考一下“这是谁的课题”。然后进行课题分离——哪些是自己的课题，哪些是别人的课题，要冷静地划清界限。而且，不去干涉别人的课题也不让别人干涉自己的课题。」 孩子的学习是自己的课题，家长可以为孩子营造好的学习环境、提供力所能及的帮助，而不应该干涉他的学习，毕竟这是他的课题。很多人活得很累、烦恼很多，就是因为不会课题分离。 他人对你的看法、对你的期待这不是由你决定的，这不是你的课题。自由就是不寻求认可，不活在他人的期待中。倘若自己都不为自己活出自己的人生，那还有谁会为自己而活呢？ 共同体 「不幸之源也在于人际关系。反过来说，幸福之源也在于人际关系。共同体感觉是幸福的人际关系的最重要的指标。」 我们都处在共同体之中，共同体不仅包括家庭、学校、城市，还包括国家、人类、过去、未来……只要有两个人，就可以构成共同体。我们把每个人都当作伙伴，我们生活在伙伴之中，我们能够从中找到自己的位置，这就是共同体的感觉。把对自己的执著（self interest）变成对他人的关心（social interest）。 对自己的执着，就是以自己为中心。那些过分在意他人看法的人，在意他人如何关注、评价自己，是在满足自己的欲求，看似迎合他人，实际上眼里只有自己。 「无论是你还是我，我们都不是世界的中心，必须用自己的脚主动迈出一步去面对人际关系课题；不是考虑“这个人会给我什么”，而是要必须思考一下“我能给这个人什么”。这就是对共同体的参与和融入。」 我们要在更广阔的天地寻找自己的位置。如果一个人只看到家庭、学校这个共同体，那么在学校受欺负、交不到朋友或者学习不好的人就无法在这里产生归属感，然后逃到家庭这个更小的共同体，就会躲在家里不愿出去，产生心理问题。 除了家庭、学校，还有更大的共同体，在家庭、学校之外，还有更广阔的世界，我们可以在更大的共同体中找到归属感。当你在家庭、学校感到身陷囹圄，只要发现世界之大，就会明白这只不过是“杯中风暴”。跳出被子，再猛烈的风也会变成微风。 「当我们在人际关系中遇到困难或者看不到出口的时候，首先应该考虑的是“倾听更大共同体的声音”这一原则。」 人生和谐 如何建立共同体感觉，在共同体中获得归属感，要做到：“自我接纳”“他者信赖”和“他者贡献”。 要分清“能够改变的”和“不能改变的”。我们无法改变“被给予了什么”。但是，关于“如何去利用被给予的东西”，我们却可以用自己的力量去改变。这就是不去关注“无法改变的”，而是去关注“可以改变的”。这就是自我接纳。 你现在一味地担心“被背叛”，也只关注因此受到的伤痛。但是，如果不敢去信赖别人，那最终就会与任何人都建立不了深厚的关系。正如前面的功课分离，被背叛是他人的课题，而信赖他人是自己的课题。我们可以相信也可以怀疑；并且，我们的目标是把别人当作朋友。如此一来，是该选择信任还是怀疑，答案就非常明显了。 工作的本质是对他人的贡献。劳动不是赚钱的手段，而是实现他者贡献的途径。通过劳动，参与共同体，获得自己的存在价值。很多富豪们已经有了一生都花不完的财富，但还在忙碌工作着，是因为无穷的欲望吗？是因为他者贡献来实现自我价值，获得归属感。 「正因为接受了真实的自我——也就是“自我接纳”——才能够不惧背叛地做到“他者信赖”；而且，正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能够做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”。」 我们惯用大家、一切、总是这类的词语，“大家都讨厌我”这个大家其实就是几个人。犹太教教义中有这么一段话：“假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。” 这种时候，是应该关注讨厌你的1个人还是喜欢你的2个人，或是大多数的7个人呢？当你因为某件事或某个缺点被别人讨厌或笑话，但笑话你的只是少数人，而你因为少数人就判断了所有人。真正的问题在于无法做到自我接纳、他者信赖和他者贡献，却将焦点聚集到微不足道的一个方面并企图以此来评价整个世界。这就是缺乏人生和谐的错误生活方式。 此时此刻 请你想象一下自己站在剧场舞台上的样子。此时，如果整个会场都开着灯，那就可以看到观众席的最里边。但是，如果强烈的聚光灯打向自己，那就连最前排也看不见。我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来。 我们应该更加认真地过好“此时此刻”。如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根本不会说出那样的话。 人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。 世界很简单，人生也一样！","categories":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"WebApiⅠ：操作元素","slug":"WebApi1","date":"2021-08-19T12:45:54.000Z","updated":"2021-08-19T00:28:56.000Z","comments":true,"path":"2021/08/19/WebApi1/","link":"","permalink":"https://youngsay.cn/2021/08/19/WebApi1/","excerpt":"","text":"1.1. Web API介绍 1.1.1 API的概念 API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。 1.1.2 Web API的概念 ​ Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。 ​ MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API ​ 因为 Web API 很多，所以我们将这个阶段称为 Web APIs。 ​ 此处的 Web API 特指浏览器提供的一系列API(很多函数或对象方法)，即操作网页的一系列工具。例如：操作html标签、操作页面地址的方法。 1.1.3 API 和 Web API 总结 API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现 Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。 Web API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法（函数） 学习 Web API 可以结合前面学习内置对象方法的思路学习 1.2. DOM 介绍 1.2.1 什么是DOM ​ 文档对象模型（Document Object Model，简称DOM），是 W3C组织推荐的处理可扩展标记语言的标准编程接口 ​ W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 ​ DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。 1.2.2. DOM树 DOM树 又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。 文档：一个页面就是一个文档，DOM中使用document表示 节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示 标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示 DOM把以上内容都看作是对象。 1.3. 获取元素 为什么要获取页面元素？ 例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。 1.3.1. 根据ID获取 1语法：document.getElementById(id) 作用：根据ID获取元素对象 参数：id值，区分大小写的字符串 返回值：元素对象 或 null 案例代码 1234567891011&lt;body&gt; &lt;div id=&quot;news&quot;&gt;2021-8-16:吴亦凡被批捕&lt;/div&gt; &lt;script&gt; // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面 var new = document.getElementById(&#x27;news&#x27;); console.log(news); console.log(typeof new); // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法 console.dir(new); &lt;/script&gt;&lt;/body&gt; 1.3.2. 根据标签名获取元素 1语法：document.getElementsByTagName(&#x27;标签名&#x27;) 或者 element.getElementsByTagName(&#x27;标签名&#x27;) 作用：根据标签名获取元素对象 参数：标签名 返回值：伪数组 案例代码 123456789101112131415161718192021222324&lt;ul&gt; &lt;li&gt;炼金术士&lt;/li&gt; &lt;li&gt;牧羊少年的奇幻之旅&lt;/li&gt; &lt;li&gt;The Alchemist&lt;/li&gt;&lt;/ul&gt;&lt;ul id=&quot;nav&quot;&gt; &lt;li&gt;小王子&lt;/li&gt; &lt;li&gt;追风筝的人&lt;/li&gt; &lt;li&gt;月亮与六便士&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的 var lis = document.getElementsByTagName(&#x27;li&#x27;); console.log(lis); console.log(lis[1]); // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式 for (var i = 0; i &lt; lis.length; i++) &#123; console.log(lis[i]); &#125; // 3. element.getElementsByTagName() 可以得到这个元素里面的某些标签 var nav = document.getElementById(&#x27;nav&#x27;); //获得nav元素 var navLis = nav.getElementsByTagName(&#x27;li&#x27;); console.log(navLis);&lt;/script&gt; 因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。 getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。 1.3.3. H5新增获取元素 代码 说明 备注 document.getElementsByClassName (‘类名’) 根据类名获得某些元素集合 document.querySelector(‘选择器’) 根据指定选择器返回第一个元素对象 加符号 ‘#nav’ document.querySelectorAll(‘选择器’) 根据指定选择器返回所有元素对象 加符号 ‘#nav’ 案例代码 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class=&quot;box&quot;&gt;盒子1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;盒子2&lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 1. getElementsByClassName 根据类名获得某些元素集合 var boxs = document.getElementsByClassName(&#x27;box&#x27;); console.log(boxs); // 2. querySelector 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav var firstBox = document.querySelector(&#x27;.box&#x27;); console.log(firstBox); var nav = document.querySelector(&#x27;#nav&#x27;); console.log(nav); var li = document.querySelector(&#x27;li&#x27;); console.log(li); // 3. querySelectorAll()返回指定选择器的所有元素对象集合 var allBox = document.querySelectorAll(&#x27;.box&#x27;); console.log(allBox); var lis = document.querySelectorAll(&#x27;li&#x27;); console.log(lis); &lt;/script&gt;&lt;/body&gt; 1.3.4 获取特殊元素 获取body元素 获取html元素 document.body document.documentElement 1.4. 事件基础 1.4.1. 事件概述 JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发— 响应机制。 ​ 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。 1.4.2. 事件三要素 事件源（谁）：触发事件的元素 事件类型（什么事件）： 例如 click 点击事件 事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数 案例代码 12345678910111213body&gt; &lt;button id=&quot;btn&quot;&gt;点我点我&lt;/button&gt; &lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件三要素：事件源 事件类型 事件处理程序 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById(&#x27;btn&#x27;); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() &#123; alert(&#x27;谁让你点我的&#x27;); &#125; &lt;/script&gt; 1.4.3. 执行事件的步骤 获取事件源 注册事件（绑定事件） 添加事件处理程序（采取函数赋值形式） 案例代码 123456789101112131415&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector(&#x27;div&#x27;); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() &#123; console.log(&#x27;我被选中了&#x27;); &#125; &lt;/script&gt;&lt;/body&gt; 1.4.4. 常见的鼠标事件 鼠标事件 触发事件 onclick 鼠标点击左键触发 onmouseover 鼠标经过触发 onmouseout 鼠标离开触发 onfocus 获得鼠标焦点触发 onblur 失去鼠标焦点触发 onmouseup 鼠标弹起触发 onmousedown 鼠标按下触发 1.5. 操作元素 ​ JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的） 1.5.1. 改变元素内容（获取或设置） innerText改变元素内容 12345678910111213141516171819202122232425&lt;body&gt; &lt;button&gt;显示当前系统时间&lt;/button&gt; &lt;div&gt;某个时间&lt;/div&gt; &lt;p&gt;1123&lt;/p&gt; &lt;script&gt; // 当我们点击了按钮， div里面的文字会发生变化 // 1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var div = document.querySelector(&#x27;div&#x27;); // 2.注册事件 btn.onclick = function() &#123; // div.innerText = &#x27;2021-8-17&#x27;; div.innerHTML = getDate(); &#125; function getDate() &#123; var date = new Date(); var year = date.getFullYear(); var month = date.getMonth() + 1; var dates = date.getDate(); var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;]; var day = date.getDay(); return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day]; &#125; &lt;/script&gt;&lt;/body&gt; innerText和innerHTML的区别 获取内容时的区别： ​ innerText会去除空格和换行，而innerHTML会保留空格和换行 设置内容时的区别： ​ innerText不会识别html，而innerHTML会识别 案例代码 12345678910111213141516171819&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt; 我是文字 &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;script&gt; // innerText 和 innerHTML的区别 // 1. innerText 不识别html标签 非标准 去除空格和换行 var div = document.querySelector(&#x27;div&#x27;); // div.innerText = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;; // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的 div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#x27;; // 这两个属性是可读写的 可以获取元素里面的内容 var p = document.querySelector(&#x27;p&#x27;); console.log(p.innerText); console.log(p.innerHTML); &lt;/script&gt;&lt;/body&gt; 1.5.2. 常用元素的属性操作 innerText、innerHTML 改变元素内容 src、href id、alt、title 1元素对象.属性名 = 修改的内容 案例代码 123456789101112131415161718192021&lt;body&gt; &lt;button id=&quot;ldh&quot;&gt;刘德华&lt;/button&gt; &lt;button id=&quot;zxy&quot;&gt;张学友&lt;/button&gt; &lt;br&gt; &lt;img src=&quot;images/ldh.jpg&quot; alt=&quot;&quot; title=&quot;刘德华&quot;&gt; &lt;script&gt; // 修改元素属性 src // 1. 获取元素 var ldh = document.getElementById(&#x27;ldh&#x27;); var zxy = document.getElementById(&#x27;zxy&#x27;); var img = document.querySelector(&#x27;img&#x27;); // 2. 注册事件 处理程序 zxy.onclick = function() &#123; img.src = &#x27;images/zxy.jpg&#x27;; img.title = &#x27;张学友&#x27;; &#125; ldh.onclick = function() &#123; img.src = &#x27;images/ldh.jpg&#x27;; img.title = &#x27;刘德华&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 1.5.3. 表单元素的属性操作 获取属性的值 元素对象.属性名 设置属性的值 元素对象.属性名 = 值 表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。 案例代码 123456789101112131415161718&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type=&quot;text&quot; value=&quot;输入内容&quot;&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var input = document.querySelector(&#x27;input&#x27;); // 2. 注册事件 处理程序 btn.onclick = function() &#123; // 表单里面的值 文字内容是通过 value 来修改的 input.value = &#x27;被点击了&#x27;; // 如果想要某个表单被禁用 不能再点击 disabled 我们想要这个按钮 button禁用 // btn.disabled = true; this.disabled = true; // this 指向的是事件函数的调用者 btn &#125; &lt;/script&gt;&lt;/body&gt; 1.5.4. 样式属性操作 我们可以通过 JS 修改元素的大小、颜色、位置等样式。 常用方式 element.style 行内样式操作 element.className 类名样式操作 方式1：通过操作style属性 元素对象的style属性也是一个对象！ 元素对象.style.样式属性 = 值; 注意： JS里面的样式采取驼峰命名法，如：fontSize、backgroundColor JS修改style样式操作，产生的是行内样式，css权重比较高 案例代码 12345678910111213&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 1. 获取元素 var div = document.querySelector(&#x27;div&#x27;); // 2. 注册事件 处理程序 div.onclick = function() &#123; // div.style里面的属性 采取驼峰命名法 this.style.backgroundColor = &#x27;purple&#x27;; this.style.width = &#x27;250px&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 方式2：通过操作className属性 元素对象.className = 值; 因为class是关键字，所有使用className。 案例代码 123456789101112131415161718&lt;body&gt; &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt; &lt;script&gt; // 1. 使用 element.style 获得修改元素样式 如果样式比较少 或者 功能简单的情况下使用 var test = document.querySelector(&#x27;div&#x27;); test.onclick = function() &#123; // this.style.backgroundColor = &#x27;purple&#x27;; // this.style.color = &#x27;#fff&#x27;; // this.style.fontSize = &#x27;25px&#x27;; // this.style.marginTop = &#x27;100px&#x27;; // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况 // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器 // this.className = &#x27;change&#x27;; this.className = &#x27;first change&#x27;; &#125; &lt;/script&gt;&lt;/body&gt; 1.6. 总结","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅳ：内置对象","slug":"js4","date":"2021-08-16T08:26:54.000Z","updated":"2021-08-16T09:27:48.000Z","comments":true,"path":"2021/08/16/js4/","link":"","permalink":"https://youngsay.cn/2021/08/16/js4/","excerpt":"","text":"1 - 内置对象 1.1 内置对象 ​ JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象 ​ 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发 ​ JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 1.2 查文档 Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 ​ MDN:https://developer.mozilla.org/zh-CN/ 1.3 Math对象 ​ Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()/Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 ​ 注意：上面的方法使用时必须带括号 ​ 获取指定范围内的随机整数： 123function getRandom(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min; &#125; 1.4 Date对象 ​ Date 对象和 Math 对象不一样，Date是一个构造函数，使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 使用Date实例化日期对象 获取当前时间必须实例化： 1var now = new Date(); 获取指定时间的日期对象 1var future = new Date(&#x27;2022-8-16 16:50:00&#x27;); 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 使用Date实例的方法和属性 通过Date实例获取总毫秒数 总毫秒数的含义 ​ 基于1970年1月1日（世界标准时间）起的毫秒数 获取总毫秒数 123456789// 实例化Date对象var now = new Date();// 1. 用于获取对象的原始值console.log(date.valueOf()) console.log(date.getTime()) // 2. ★简单写可以这么做var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题var now = Date.now(); 1.5 数组对象 创建数组的两种方式 字面量方式 示例代码如下： 1var arr = [1,&quot;test&quot;,true]; new Array() 示例代码如下： 1var arr = new Array(); 注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数 ​ 参数传递规则如下： 如果只传入一个参数，则参数规定了数组的长度 如果传入了多个参数，则参数称为数组的元素 检测是否为数组 instanceof 运算符 instanceof 可以判断一个对象是否是某个构造函数的实例 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // false Array.isArray() Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 1234var arr = [1, 23];var obj = &#123;&#125;;console.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素的方法 数组中有进行增加、删除元素的方法，部分方法如下表 注意：push、unshift为增加元素方法；pop、shift为删除元素的方法 数组排序 数组中有对数组本身排序的方法，部分方法如下表 注意：sort方法需要传入参数来设置升序、降序排序 如果传入“function(a,b){ return a-b;}”，则为升序 如果传入“function(a,b){ return b-a;}”，则为降序 12345var arr=[1,12,3,4];arr.sort(function(a,b)&#123; //sort(函数) return a-b; //升序&#125;) console.log(arr); //1,3,4,12 数组索引方法 数组中有获取数组指定元素索引值的方法，部分方法如下表 数组转换为字符串 数组中有把数组转化为字符串的方法，部分方法如下表 注意：join方法如果不传入参数，则按照 “ , ”拼接元素 其他方法 1.6 字符串对象 基本包装类型 ​ 为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 ​ 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 123// 下面代码有什么问题？var str = &#x27;andy&#x27;;console.log(str.length); ​ 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 ​ js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1. 生成临时变量，把简单类型包装为复杂数据类型var temp = new String(&#x27;andy&#x27;);// 2. 赋值给我们声明的字符变量str = temp;// 3. 销毁临时变量temp = null; 字符串的不可变 ​ 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 ​ 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。 ​ 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 根据字符返回位置 ​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法： ​ 案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数 先查找第一个o出现的位置 然后 只要indexOf 返回的结果不是 -1 就继续往后查找 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 123456789var str = &#x27;abcoefoxyozzopp&#x27;;var index = str.indexOf(&#x27;o&#x27;);var num = 0;while(index != -1)&#123; console.log(index); //3 num++; index = str.indexOf(&#x27;o&#x27;,index+1);&#125;console.log(&#x27;o出现的次数是：&#x27;+ num +&#x27;次&#x27;); 根据位置返回字符 ​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符： ​ 案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 ​ 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数 123456789101112131415161718192021222324var str = &#x27;abcoefoxyozzopp&#x27;;var o = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; var chars = str.charAt(i); // chars 是 字符串的每一个字符 if (o[chars]) &#123; // o[chars] 得到的是属性值 o[chars]++; &#125; else &#123; o[chars] = 1; &#125;&#125;console.log(o);// 2. 遍历对象var max = 0;var ch = &#x27;&#x27;;for (var k in o) &#123; // k 得到是 属性名 // o[k] 得到的是属性值 if (o[k] &gt; max) &#123; max = o[k]; ch = k; &#125;&#125;console.log(max);console.log(&#x27;最多的字符是&#x27; + ch); 字符串操作方法 ​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法： replace()方法 ​ replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下： 1字符串.replace(被替换的字符串， 要替换为的字符串)； split()方法 ​ split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 ​ 其使用格式如下： 1字符串.split(&quot;分割字符&quot;) 2 - 简单数据类型和复杂数据类型 2.1 简单数据类型 ​ 简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null 2.2 复杂数据类型 ​ 复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 2.3 堆栈 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 ​ 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 ​ 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 2.4 简单类型传参 ​ 函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 1234567function fn(a) &#123; a++; console.log(a); &#125;var x = 10;fn(x);console.log(x); ​ 运行结果是：11 10 2.5 复杂数据类型传参 ​ 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 123456789101112function Person(name) &#123; this.name = name;&#125;function f1(x) &#123; // x = p console.log(x.name); // 2. 这个输出什么 ? x.name = &quot;罗志祥&quot;; console.log(x.name); // 3. 这个输出什么 ? &#125;var p = new Person(&quot;吴亦凡&quot;);console.log(p.name); // 1. 这个输出什么 ? f1(p);console.log(p.name); // 4. 这个输出什么 ? ​ 运行结果是：吴亦凡 吴亦凡 罗志祥 罗志祥","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅲ：作用域和对象","slug":"js3","date":"2021-08-15T11:26:54.000Z","updated":"2021-08-15T11:44:32.000Z","comments":true,"path":"2021/08/15/js3/","link":"","permalink":"https://youngsay.cn/2021/08/15/js3/","excerpt":"","text":"1 - 作用域 ​ 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。 JavaScript（es6前）中的作用域有两种： 全局作用域：作用于所有代码执行的环境(整个script标签内部)或独立的js文件。 局部作用域（函数作用域）：作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。 ❗ jS没有块级作用域 块作用域由 { } 包括。 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码： java有块级作用域： 12345if(true)&#123; int num = 123; system.out.print(num); // 123&#125;system.out.print(num); // 报错 ​ 以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；而与之类似的JavaScript代码，则不会报错。 js中没有块级作用域（在ES6之前） 12345if(true)&#123; var num = 123; console.log(123); //123&#125;console.log(123); //123 2 - 变量的作用域 在JavaScript中，根据作用域的不同，变量可以分为两种： 全局变量 局部变量 2.1 全局变量 在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用） 2.2 局部变量 在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量） 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 2.3 全局变量和局部变量的区别 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间 3 - 作用域链 ​ 写在函数内部的是局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。 12345678910案例分析1：function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 1234567891011121314151617作用域链：采取就近原则的方式来查找变量最终的值var a = 1;function fn1() &#123; var a = 2; var b = &#x27;22&#x27;; fn2(); function fn2() &#123; var a = 3; fn3(); function fn3() &#123; var a = 4; console.log(a); //a的值 ? console.log(b); //b的值 ? &#125; &#125;&#125;fn1(); 4 - 预解析 JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。 代码执行： 从上到下执行JS语句。 注意：预解析会把变量和函数的声明在代码执行之前执行完成。 1变量预解析 ​ 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。 12console.log(num); // 结果是多少？var num = 10; // ？ 结果：undefined ★注意：变量提升只提升声明，不提升赋值 4.3 函数预解析 ​ 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。 1234fn();function fn() &#123; console.log(&#x27;打印&#x27;);&#125; 结果：控制台打印字符串 — ”打印“ 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！ 4.4 函数表达式声明函数问题 函数表达式创建函数，会执行变量提升 1234fn();var fn = function() &#123; console.log(&#x27;想不到吧&#x27;);&#125; 结果：报错提示 ”fn is not a function&quot; 解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用 5 - 对象 对象：在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的。 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 1var arr = [‘吴签’, ‘30&#x27;, &#x27;选妃&#x27;]; ​ 上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。 ​ 为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。 使用对象记录上组数据为： 12345var obj = &#123; name:&#x27;吴签&#x27;, age:30, works:&#x27;选妃&#x27;,&#125; JS中的对象表达结构更清晰，更强大。 创建对象的三种方式 利用字面量创建对象 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 代码如下： 1234567891011var star = &#123; name : &#x27;张哲瀚&#x27;, age : 30, sex : &#x27;男&#x27;, sayLove : function()&#123; alert(&#x27;我很爱国&#x27;); &#125;&#125;;console.log(star.name) // 调用名字属性console.log(star[&#x27;name&#x27;]) // 调用名字属性star.sayLove(); // 调用 sayLove 方法,注意一定要带后面的括号 上述代码中 star即是创建的对象。 变量、属性、函数、方法总结 - 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明 函数：单独存在的，通过“函数名()”的方式就可以调用 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用 利用 new Object 创建对象 12345678910var Star = new Object(); //创建空对象Star.name=&#x27;吴亦凡&#x27;; // 给空对象添加属性Star.age=30;Star.works=&#x27;选妃&#x27;;Star.sayHi=function()&#123; // 给空对象添加方法 console.log(&#x27;我的很大，你要忍一下~&#x27;);&#125;console.log(Star.name);console.log(Star[&#x27;age&#x27;]);Star.sayHi(); Object() ：第一个字母大写 使用的格式：对象.属性 = 值; 利用构造函数创建对象 构造函数 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 构造函数的封装格式： 123456function 构造函数名(形参1,形参2,形参3) &#123; this.属性名1 = 参数1; this.属性名2 = 参数2; this.属性名3 = 参数3; this.方法名 = 函数体;&#125; 构造函数的调用格式 1var obj = new 构造函数名(实参1，实参2，实参3) 示例 123456789101112131415161718// 封装function Star(name,age,works)&#123; this.name=name; this.age=age; this.works=works; this.result = function(result)&#123; //方法 console.log(result); &#125;&#125;// 调用var wyf = new Star(&#x27;吴亦凡&#x27;,30,&#x27;选妃&#x27;);var lzx = new Star(&#x27;罗志祥&#x27;,42,&#x27;时间管理&#x27;);var zzh = new Star(&#x27;张哲瀚&#x27;,30,&#x27;靖国神社&#x27;);wyf.result(&#x27;坐牢&#x27;);lzx.result(&#x27;退圈&#x27;);zzh.result(&#x27;封杀&#x27;);console.log(wyf.works);console.log(zzh[&#x27;works&#x27;]); 注意事项 构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 其他 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class） 创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 new关键字的作用 在构造函数代码开始执行之前，创建一个空对象； 修改this的指向，把this指向创建出来的空对象； 执行函数的代码 在函数完成之后，返回this—即创建出来的对象 5.3 遍历对象 ​ for…in 语句用于对数组或者对象的属性进行循环操作。 ​ 其语法如下： 123for (变量 in 对象名字) &#123; // 在此执行代码&#125; ​ 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。 1234for (var k in obj) &#123; console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅱ：数组和函数","slug":"js2","date":"2021-08-15T03:26:54.000Z","updated":"2021-08-15T03:28:26.000Z","comments":true,"path":"2021/08/15/js2/","link":"","permalink":"https://youngsay.cn/2021/08/15/js2/","excerpt":"","text":"1-数组 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。 1-1创建数组 JS 中创建数组有两种方式： 利用 new 创建数组 12var 数组名 = new Array() ；var arr = new Array(); // 创建一个新的空数组 注意 Array () ，A 要大写 利用数组字面量创建数组 1234//1. 使用数组字面量方式创建空的数组var 数组名 = []；//2. 使用数组字面量方式创建带初始值的数组var 数组名 = [&#x27;胖虎&#x27;,&#x27;panghutx&#x27;,&#x27;blog.wangyouwu.cn&#x27;]; 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 1var arrStus = [&#x27;小白&#x27;,12,true,28.9]; 1-2获取数组中的元素 ​ 索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。 1234// 定义数组var arrStus = [1,2,3];// 获取数组中的第2个元素alert(arrStus[1]); 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined 1-3遍历数组 数组遍历 ​ 把数组中的每个元素从头到尾都访问一次，可以通过 for 循环索引遍历数组中的每一项 1234var arr = [&#x27;red&#x27;,&#x27;green&#x27;, &#x27;blue&#x27;];for(var i = 0; i &lt; arr.length; i++)&#123; console.log(arrStus[i]);&#125; 数组的长度 数组的长度：默认情况下表示数组中元素的个数 使用“数组名.length”可以访问数组元素的数量（数组长度）。 12var arrStus = [1,2,3];alert(arrStus.length); // 3 注意： 此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。 当数组元素个数发生变化， length 属性跟着一起变化 2-函数 ​ 函数：封装一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 2-1函数的声明调用 声明函数 1234// 声明函数function 函数名() &#123; //函数体代码&#125; function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 调用函数 12// 调用函数函数名(); // 通过调用函数名来执行函数体代码 调用的时候千万不要忘记添加小括号 口诀：函数不调用，自己不执行 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 例子：封装计算1-100累加和 12345678910111213/* 计算1-100之间值的函数*/// 声明函数function getSum()&#123; var sumNum = 0;// 准备一个变量，保存数字和 for (var i = 1; i &lt;= 100; i++) &#123; sumNum += i;// 把每个数值 都累加 到变量中 &#125; alert(sumNum);&#125;// 调用函数getSum(); 2-2函数的参数 函数参数语法 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 函数参数的运用： 123456// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) &#123; // 可以定义任意多的参数，用逗号分隔 // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3...); 调用的时候实参值是传递给形参的 形参简单理解为：不用声明的变量 实参和形参的多个参数之间用逗号（,）分隔 函数形参和实参数量不匹配时 注意：在JavaScript中，形参的默认值是undefined。 小结： 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔 2-3函数的返回值 return 语句 返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。 1234567// 声明函数function 函数名（）&#123; ... return 需要返回的值；&#125;// 调用函数函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break ,continue ,return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 2-4arguments的使用 ​ **当不确定有多少个参数传递的时候，可以用 arguments 来获取。**JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法 注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。 2-5函数案例 函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。 1234567891011121314151617181920//用户输入年份，输出当前年份2月份的天数function backDay()&#123; var year = prompt(&#x27;请输入年份：&#x27;); if(isRunYear(year))&#123; alert(year+&#x27;是闰年，2月份有29天&#x27;); &#125;else &#123; alert(year+&#x27;是平年，2月份有28天&#x27;); &#125;&#125; backDay(); // 判断是否是闰年function isRunYear(year)&#123; //如果是闰年返回true，否则else var flag = false; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; //能被4整除且不能被100整除或者能被400整除 flag=true; &#125; return flag; &#125; 2-6函数的两种声明方式 自定义函数方式(命名函数) 利用函数关键字 function 自定义函数方式 1234// 声明定义方式function fn() &#123;...&#125;// 调用 fn(); 因为有名字，所以也被称为命名函数 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 函数表达式方式(匿名函数） 利用函数表达式方式的写法如下： 1234// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;；// 调用的方式，函数调用必须写到函数体下面fn(); 因为函数没有名字，所以也被称为匿名函数 这个fn 里面存储的是一个函数 函数表达式方式原理跟声明变量方式是一致的 函数调用的代码必须写到函数体后面","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js练习Ⅰ：循环、数组、函数","slug":"js-exercise","date":"2021-08-14T13:45:54.000Z","updated":"2021-08-15T03:12:54.000Z","comments":true,"path":"2021/08/14/js-exercise/","link":"","permalink":"https://youngsay.cn/2021/08/14/js-exercise/","excerpt":"","text":"🙂循环 一行打印★★★★★ 12345var str = &#x27;&#x27;;for (var i = 1;i&lt;=5;i++) &#123; str = str + &#x27;★&#x27;; //追加字符串&#125; console.log(str); 倒序打印★ 第一行9个，第九行1个 12345678var str = &#x27;&#x27;;for (var i=1;i&lt;10; i++) &#123; // 控制行数 for (var j=i;j&lt;10;j++) &#123; // 控制每一行★个数 str = str + &#x27;★&#x27;; &#125; str = str + &#x27;\\n&#x27;; // 每行结尾换行&#125; console.log(str); 正序打印★ 第一行1个，第九行9个 12345678var str = &#x27;&#x27;;for (var i=1;i&lt;10;i++) &#123; for (var j =1 ;j&lt;=i;j++) &#123; str = str + &#x27;★&#x27;; &#125; str = str + &#x27;\\n&#x27;;&#125;console.log(str); 打印九九乘法表 12345678var str =&#x27;&#x27;;for (var i=1 ; i&lt;10;i++) &#123; for (var j=1;j&lt;=i;j++) &#123; str = str + j + &#x27;x&#x27; +i + &#x27;=&#x27; + j*i + &#x27;\\t&#x27;; &#125; str = str + &#x27;\\n&#x27;;&#125;console.log(str); 接收用户输入的用户名和密码，若用户名为 “admin” ,且密码为 “123456” ,则提示用户登录成功! 否则，让用户一直输入。 12345do &#123; var name = prompt(&#x27;请输入用户名&#x27;); var password = prompt(&#x27;请输入密码&#x27;);&#125;while (name != &#x27;admin&#x27; || password != &#x27;123456&#x27;); //两个有一个不满足就要进入循环，切忌写成&amp;&amp;alert(&#x27;登陆成功&#x27;); 求整数1～100的累加值，但要求跳过所有个位为3的数。 12345678var sum = 0;for (var i=1;i&lt;=100;i++) &#123; if(i%10==3) &#123; continue; &#125; sum = sum + i;&#125;console.log(sum); 1234567var sum = 0;for (var i=1;i&lt;=100;i++) &#123; if(i%10!=3) &#123; sum = sum + i; &#125; &#125;console.log(sum); ATM机 12345678910111213141516var sum =100;do&#123;var choice = prompt(&#x27;请输入你要的操作：\\n1.存钱 \\n2.取钱\\n3.显示余额\\n4.退出\\n &#x27;);if(choice==1)&#123; var num1 = prompt(&#x27;请输入存入金额：&#x27;) var sum = parseInt(sum) + parseInt(num1); alert(&#x27;你的余额是&#x27;+ sum +&#x27;元&#x27;)&#125;else if(choice == 2)&#123; var num2 = prompt(&#x27;请输入取出金额：&#x27;) var sum = parseInt(sum) - parseInt(num2); alert(&#x27;你的余额是&#x27;+ sum +&#x27;元&#x27;)&#125;else if(choice == 3)&#123; alert(&#x27;你的余额是&#x27;+ sum +&#x27;元&#x27;)&#125;&#125;while(choice!=4)alert(&#x27;退出成功&#x27;); 求从1开始第35个能被7和3整除的整数 1234567var count = 0;for(var i =1; count&lt;35;i++)&#123; if(i%3==0&amp;&amp;i%7==0)&#123; count++; console.log(i); &#125;&#125; 🙂数组 求出数组总和和平均数 12345678var arr = [2,6,1,7,4]; var sum = 0; var average = 0; for(var i =0; i &lt; arr.length ; i++)&#123; sum =sum +arr[i] // 求和是加数组元素arr[i]，不是数组下标i &#125; average = sum/arr.length; console.log(sum,average); // 输出多个变量，用，逗号隔开即可 求数组[2,6,1,77,52,25,7]中的最大值 12345678var arr = [2,6,1,77,52,25,7];var max =arr[0];for(i=0;i&lt;arr.length;i++)&#123; if(max&lt;arr[i])&#123; max=arr[i]; &#125;&#125;console.log(max); 将数组[‘red’,‘green’,‘blue’,‘pink’]转换为字符串，并使用|分割 123456var arr = [&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;,&#x27;pink&#x27;];var str = &#x27;&#x27;;for(var i=0;i&lt;arr.length;i++) &#123; str = str + arr[i] + &#x27;|&#x27;;&#125;console.log(str); 新建一个数组，里面存放10个整数（1-10） 123456ar arr = [];for(var i =0;i&lt;10;i++)&#123; // arr = 1 x 不要直接给数组名赋值 arr[i]=i+1;&#125;console.log(arr); 将数组[2,0,6,1,77,0,52,0,25,7]中大于等于10的元素选出来，放入新数组 12345678910var arr = [2,0,6,1,77,0,52,0,25,7];var arr1=[];var a=0;for(var i =0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;=10)&#123; arr1[a]=arr[i] a++; &#125;&#125; console.log(arr1); 123456789var arr = [2,0,6,1,77,0,52,0,25,7];var arr1=[]; //arr1.length就是0var a=0;for(var i =0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;=10)&#123; arr1[arr1.length]=arr[i] &#125;&#125; console.log(arr1); 将数组[2,0,6,1,77,0,52,0,25,7]中的0去掉，形成一个新数组 1234567var arr = [2,0,6,1,77,0,52,0,25,7];var arr1 = [];for(var i = 0; i&lt;arr.length;i++)&#123; if(arr[i]!=0 )&#123; arr1[arr1.length]=arr[i]; &#125;&#125; 将数组[1,2,3,4,5,6]内容反过来存放 1234567891011var arr = [1,2,3,4,5,6];var arr1 = [];var num = arr.length;for(var i = 0; i&lt;arr.length;i++)&#123; num--; arr1[arr1.length]=arr[num]; &#125;console.log(arr1); ★★★冒泡排序★★★ 将数组[2,1,3,5,4]元素由大到小排列 123456789101112var arr = [2,1,3,5,4];for(var i=0;i &lt;= arr.length-1;i++)&#123; // 趟数 for(var j=0;j&lt;=arr.length-1-i;j++) &#123; //每趟的次数w if(arr[j]&lt;arr[j+1])&#123; var temp =0; temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125;&#125;console.log(arr); 🙂函数 利用函数求两个数的最大值 12345678910function Getmax (num1,num2) &#123; var max = num1; if(num1&gt;num2)&#123; max = num1; &#125;else &#123; max = num2; &#125; return max;&#125;console.log(Getmax(6,9)); 1234function Getmax (num1,num2) &#123; return num1&gt;num2 ? num1 : num2; //三元运算符&#125;console.log(Getmax(6,9)); 利用函数求数组中的最大值 1234567891011function Getmax (arr) &#123; //接收一个数组 var max = arr[0]; for(var i=0; i&lt;arr.length; i++) &#123; if(max&lt;arr[i])&#123; max=arr[i]; &#125; &#125; return max;&#125;var re = Getmax([5,2,99,101,67,77]); //实参是一个数组传过去console.log(re); 利用函数求任意个数中的最大值 1234567891011function getMax()&#123; var max = arguments[0]; for(var i=0;i&lt;arguments.length;i++)&#123; if(max&lt;arguments[i])&#123; max=arguments[i]; &#125; &#125; return max;&#125;var re=getMax(3,1,5,76,34);console.log(re); 利用函数,翻转任意一个数组 123456789function reverse(arr)&#123; var newArr=[]; for(var i=0;i&lt;arr.length;i++)&#123; newArr[newArr.length]=arr[arr.length-1-i]; &#125; return newArr;&#125;var arr1 = reverse([1,2,3,4,5]);console.log(arr1); 利用函数,对数组从小到大排序—冒泡排序 1234567891011121314function sort(arr)&#123; for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=0;j&lt;arr.length-1-i;j++) &#123; if(arr[j]&gt;arr[j+1])&#123; var temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; return arr;&#125;var arr1=sort([1,4,2,6,5]);console.log(arr1); 用户输入年份，输出当前年份2月份的天数 12345678910111213141516171819function backDay()&#123; var year = prompt(&#x27;请输入年份：&#x27;); if(isRunYear(year))&#123; alert(year+&#x27;是闰年，2月份有29天&#x27;); &#125;else &#123; alert(year+&#x27;是平年，2月份有28天&#x27;); &#125;&#125; backDay(); // 判断是否是闰年function isRunYear(year)&#123; //如果是闰年返回true，否则else var flag = false; if(year%4==0&amp;&amp;year%100!=0||year%400==0) &#123; //能被4整除且不能被100整除或者能被400整除 flag=true; &#125; return flag; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"js基础Ⅰ：变量和数据类型","slug":"js1","date":"2021-08-12T12:45:54.000Z","updated":"2021-08-15T03:28:16.000Z","comments":true,"path":"2021/08/12/js1/","link":"","permalink":"https://youngsay.cn/2021/08/12/js1/","excerpt":"","text":"JavaScript输入输出语句 为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下： 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。 变量 什么是变量 白话：变量就是一个装东西的盒子。 通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。 变量的使用 12345var age; // 声明一个 名称为age 的变量 age = 10; // 给 age 这个变量赋值为 10 var age = 18; // 声明变量同时赋值为 18// 声明一个变量并赋值， 我们称之为变量的初始化。var age = 10, name = &#x27;zs&#x27;, sex = 2; //同时声明多个变量 声明变量特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10; console.log (age); 不声明 只赋值 10 数据类型 数据类型简介 变量的数据类型 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定： 12var age = 10; // 这是一个数字型var areYouOk = &#x27;是的&#x27;; // 这是一个字符串 ​ 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： 12var x = 6; // x 为数字var x = &quot;Bill&quot;; // x 为字符串 数据类型的分类 JS 把数据类型分为两类： 简单数据类型 （Number,String,Boolean,Undefined,Null） 复杂数据类型 （object) 简单数据类型 简单数据类型（基本数据类型） JavaScript 中的简单数据类型及其说明如下： 数字型 Number ​ JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。 12var age = 21; // 整数var Age = 21.3747; // 小数 数字型进制 最常见的进制有二进制、八进制、十进制、十六进制。 123456 // 1.八进制数字序列范围：0~7var num1 = 07; // 对应十进制的7var num2 = 019; // 对应十进制的19var num3 = 08; // 对应十进制的8 // 2.十六进制数字序列范围：0~9以及A~Fvar num = 0xA; 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x 数字型范围 JavaScript中数值的最大和最小值 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32 数字型三个特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 NaN ，Not a number，代表一个非数值 isNaN 用来判断一个变量是否为非数字的类型，返回 true 或者 false 12345 var usrAge = 21;var isOk = isNaN(userAge); console.log(isNum); // false ，21 不是一个非数字var usrName = &quot;andy&quot;; console.log(isNaN(userName));// true ，&quot;andy&quot;是一个非数字 字符串型 String ​ 字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’ 1234var strMsg = &quot;胖虎同学panghutx&quot;; // 使用双引号表示字符串var strMsg2 = &#x27;胖虎同学panghutx&#x27;; // 使用单引号表示字符串// 常见错误var strMsg3 = 胖虎同学; // 报错，没使用引号，会被认为是js代码，但js没有这些语法 字符串转义符 ​ 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 ​ 转义符都是 \\ 开头的，常用的转义符及其说明如下： 转义符 解释说明 \\n 换行符，n 是 newline 的意思 \\ \\ 斜杠 \\ \\’ ’ 单引号 \\&quot; ”双引号 \\t tab 缩进 \\b 空格 ，b 是 blank 的意思 字符串长度 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 12var strMsg = &quot;我是胖虎同学！&quot;;alert(strMsg.length); // 显示 7 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 123456//1.1 字符串 &quot;相加&quot;alert(&#x27;hello&#x27; + &#x27; &#x27; + &#x27;world&#x27;); // hello world//1.2 数值字符串 &quot;相加&quot;alert(&#x27;100&#x27; + &#x27;100&#x27;); // 100100//1.3 数值字符串 + 数值alert(&#x27;11&#x27; + 12); // 1112 + 号总结口诀：数值相加 ，字符相连 字符串拼接加强 12345console.log(&#x27;胖虎同学&#x27; + 20); // 只要有字符就会相连 var age = 20;console.log(&#x27;胖虎同学age岁&#x27;); // 这样不行哦console.log(&#x27;胖虎同学&#x27; + age); // 胖虎同学20console.log(&#x27;胖虎同学&#x27; + age + &#x27;岁啦&#x27;); // 胖虎同学20岁啦 经常会将字符串和变量来拼接，变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间 布尔型Boolean ​ 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 ​ 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12console.log(true + 1); // 2console.log(false + 1); // 1 Undefined和 Null ​ 一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果） 12345var variable;console.log(variable); // undefinedconsole.log(&#x27;你好&#x27; + variable); // 你好undefinedconsole.log(11 + variable); // NaNconsole.log(true + variable); // NaN ​ 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null) 1234var vari = null;console.log(&#x27;你好&#x27; + vari); // 你好nullconsole.log(11 + vari); // 11console.log(true + vari); // 1 获取变量数据类型 获取检测变量的数据类型 ​ typeof 可用来获取检测变量的数据类型 12var num = 18;console.log(typeof num) // 结果 number ​ 不同类型的返回值 数据类型转换 ​ 什么是数据类型转换？ ​ 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换： 123转换为字符串类型转换为数字型转换为布尔型 转换为字符串 转换为数字型 转换为布尔型 代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined 其余值都会被转换为 true 1234567console.log(Boolean(&#x27;&#x27;)); // falseconsole.log(Boolean(0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean(&#x27;小白&#x27;)); // trueconsole.log(Boolean(12)); // true","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"}]},{"title":"c语言：函数","slug":"c-function","date":"2021-08-10T02:31:01.000Z","updated":"2022-01-23T12:10:14.000Z","comments":true,"path":"2021/08/10/c-function/","link":"","permalink":"https://youngsay.cn/2021/08/10/c-function/","excerpt":"","text":"函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。 调用函数 函数名() ()起到了表示函数调用的作用，即使没有参数也需要()；如果有参数，则需要给出正确的数量和顺序，这些值会被按照顺序依次用来初始化函数中的参数。 123456789101112131415#include&lt;stdio.h&gt;void sum(int begain, int end)&#123; int i = 0; int sum = 0; for (i=begain; i &lt;= end; i++) &#123; sum += i; &#125; printf(&quot;%d到%d的和是%d&quot;, begain, end, sum);&#125;int main()&#123; sum(1, 10); return 0;&#125; 从函数中返回值 return停止函数的执行，并返回一个值。 12345678910111213141516171819#include&lt;stdio.h&gt;int max(int a, int b)&#123; int ret = 0; if (a &gt; b) &#123; ret = a; &#125; else &#123; ret = b; &#125; printf(&quot;最大值是%d&quot;, ret); return ret;&#125;int main()&#123; max(11, 20); return 0;&#125; 函数原型 函数头，以分号’;'结尾，构成了函数原型 函数原型目的是告诉编译器函数长什么样（名称、参数、返回类型） 1234567891011121314151617181920#include&lt;stdio.h&gt;int max(int a, int b); //声明【函数原型】int main()&#123; max(11, 20); return 0;&#125;int max(int a, int b) //定义 【实际的函数头】&#123; int ret = 0; if (a &gt; b) &#123; ret = a; &#125; else &#123; ret = b; &#125; printf(&quot;最大值是%d&quot;, ret); return ret;&#125; 传值 传值：每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。 c语言在调用函数时，永远只能传值给函数 本地变量 参数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量。 定义在函数内部的变量就是本地变量，参数也是本地变量 变量的生存期与作用域 生存期：什么时候这个变量开始出现了，到什么时候它消亡了 作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用） 对于本地变量，这两个问题的答案是统一的：大括号内——块 本地变量的规则 本地变量是定义在块内的，它可以定义在函数的块内，也可以定义在语句的块内。 程序进入块之前，其中的变量不存在，离开块，其中的变量消失。 块外面定义的变量在里面仍然有效，块内的同名变量会掩盖外面的变量","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"c语言：数据类型","slug":"c-date-type","date":"2021-08-09T03:31:01.000Z","updated":"2022-01-23T12:07:50.000Z","comments":true,"path":"2021/08/09/c-date-type/","link":"","permalink":"https://youngsay.cn/2021/08/09/c-date-type/","excerpt":"","text":"整数 char：1字节（8比特） -128~127 short：2字节 -32768~32767 int：取决于编译器（CPU），通常意义是“1个字” long：取决于编译器（CPU），通常意义是“1个字” long long：8字节 整数的内部表达都是二进制 补码 补码的意义就是拿补码和原码可以加出一个溢出的“零” 0-1=-1 (1)00000000 - 00000001 --&gt; 11111111 11111111被看作纯二进制看待时，是255，被当作补码看待时是-1 同理，-a的补码是0-a，实际上是 (n是这种类型的位数) 2n−a2^n-a 2n−a 8进制和16进制： 一个以0开始的数字字面量是8进制 一个以x开始的数字字面量是16进制 %0用于8进制，%x用于16进制 8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关 浮点数 类型 字长 有效数字 scanf printf float 32 7 %f %f，%e double 64 15 %lf %f，%e 输出精度：在%和f之间加上.n可以指定输出小数点后几位，输出是4舍5入的 printf(“%.3f\\n”,-0.0056); —&gt; 输出结果为-0.006 float需要用f或F后缀来表明身份，带小数点的字面量默认是double 自动类型转换：当运算符两边出现不一致的类型时，会自动转换成较大（数的范围打）的类型 char–&gt;short–&gt;int–&gt;long–&gt;long long int–&gt;float–&gt;double 强制类型转换：(类型)值 如(int)6.66表示把float转换成int 逻辑运算 运算符 描述 示例 结果 ！ 逻辑非 !a a=1,!a=0 &amp;&amp; 逻辑与 a&amp;&amp;b 如果a和b都是true，结果才是true；否则就是false || 逻辑或 a||b 如果a和b有一个是true，结果就是true。 运算符优先级 优先级 运算符 结合性 1 () 从左到右 2 ! + - ++ – 从右到左（单目的+和-） 3 */% 从左到右 4 ± 从左到右 5 &lt; &lt;= &gt; &gt;= 从左到右 6 == != 从左到右 7 &amp;&amp; 从左到右 8 || 从左到右 9 = += -+ *= /= %= 从右到左 对于&amp;&amp;，左边是false时就不做右边了；对于||，左边是true时就不做右边了。 逗号表达式 优先级别最低，它将两式联接起来，如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后表达式2，整个表达式值是表达式2的值，如：（3+5，6+8）的值是14，（a=20/4,a*4）的值是20，原因在于赋值运算优先级高于逗号表达式。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"移动web开发——rem布局","slug":"rem","date":"2021-08-05T07:07:01.000Z","updated":"2021-08-05T07:36:50.000Z","comments":true,"path":"2021/08/05/rem/","link":"","permalink":"https://youngsay.cn/2021/08/05/rem/","excerpt":"","text":"rem基础 rem (root em)是一个相对单位，类似于em，em是父元素字体大小。 不同的是rem的基准是相对于html元素的字体大小。 比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。 12345678/* 根html 为 12px */html &#123; font-size: 12px;&#125;/* 此时 div 的字体大小就是 24px */ div &#123; font-size: 2rem;&#125; rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。 媒体查询 什么是媒体查询 媒体查询（Media Query）是CSS3新语法。 使用 @media查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询 媒体查询语法规范 用 @media开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性必须有小括号包含 123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; mediatype 查询类型 ​ 将不同的终端设备划分成不同的类型，称为媒体类型 关键字 ​ 关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性 每种媒体类型都具有各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。 注意他们要加小括号包含 媒体查询书写规则 注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁 less 基础 维护css弊端 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 less 介绍 Less（LeanerStyle Sheets 的缩写）是一门 CSS扩展语言，也成为CSS预处理器。 它在CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。 Less中文网址：http://lesscss.cn/ 常见的CSS预处理器：Sass、Less、Stylus less安装 ①安装nodejs，可选择版本(8.0)，网址：http://nodejs.cn/download/ ②检查是否安装成功，使用cmd命令（win10是window+r 打开运行输入cmd） —输入“node –v”查看版本即可 ③基于nodejs在线安装Less，使用cmd命令“npm install -g less”即可 ④检查是否安装成功，使用cmd命令“ lessc -v ”查看版本即可 less使用 less变量 变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 1@变量名:值; 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 1@color: pink; less嵌套 1234567891011// 将css改为less#header .logo &#123; width: 300px;&#125;#header &#123; .logo &#123; width: 300px; &#125;&#125; 如果遇见 （交集|伪类|伪元素选择器） ，利用&amp;进行连接 12345678a:hover&#123; color:red;&#125;a&#123; &amp;:hover&#123; color:red; &#125;&#125; less运算 任何数字、颜色或者变量都可以参与运算。就是Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。 123456789101112/*Less 里面写*/@witdh: 10px + 5;div &#123; border: @witdh solid red;&#125;/*生成的css*/div &#123; border: 15px solid red;&#125;/*Less 甚至还可以这样 */width: (@width + 5) * 2; 乘号（*）和除号（/）的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"移动web开发——flex布局","slug":"flex","date":"2021-07-26T10:25:01.000Z","updated":"2021-07-26T10:44:48.000Z","comments":true,"path":"2021/07/26/flex/","link":"","permalink":"https://youngsay.cn/2021/07/26/flex/","excerpt":"","text":"flex 是 flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 给父盒子添加flex属性，来控制子盒子的位置和排列方式 父项常见属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex-direction 设置主轴方向，在flex布局中分为主轴和侧轴（x、y轴），默认主轴是x轴，水平向右。 1234flex-direction: row; /*主轴为x轴，从左到右*/flex-direction: row-reverse; /*，主轴为x轴，从右到左*/flex-direction: column; /*主轴为y轴，从上到下*/flex-direction: column-reverse; /*，主轴为y轴，从下到上*/ justify-content 设置主轴上子元素的排列方式，使用该属性前要先定好主轴。 12345justify-content: flex-start;/*从前开始*/justify-content: flex-end;/*从后开始*/justify-content: center;/*居中对齐*/justify-content: space-around;/*平分剩余空间*/justify-content: space-between;/*★两边贴边后再平分剩余空间*/ flex-wrap flex中项目默认都排列在一行，通过flex-wrap属性可换行 12flex-wrap: nowrap;/*默认值，不换行*/flex-wrap: wrap;/*换行*/ align-items 设置侧轴上子元素的排列方式，在子项为单行时使用 12345align-items: flex-start;(flex-end/center/streth)/*flex-start 从头部开始flex-end 从尾部开始center 居中显示stretch 拉伸*/ align-content 设置侧轴上子元素的排列方式，在子项为多行时使用 1align-content: flex-start; align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结:单行用align-items，多行用 align-content flex-flow flex-direction和flex-wrap的符合属性 1flex-flow: row wrap;/*主轴为x轴，换行*/ 子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） flex flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 123.item &#123; flex: &lt;number&gt;; /* 默认值 0 */&#125; align-self align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 123span:nth-child(2) &#123; align-self: flex-end;&#125; order order属性定义项目的排列顺序，数值越小，排列越靠前，默认为0。和 z-index 不同。 123.item &#123; order: &lt;number&gt;;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"移动web开发","slug":"viewport","date":"2021-07-25T10:25:01.000Z","updated":"2021-07-25T10:25:38.000Z","comments":true,"path":"2021/07/25/viewport/","link":"","permalink":"https://youngsay.cn/2021/07/25/viewport/","excerpt":"","text":"meta标签 为使网站在移动端有理想的阅读宽度，需添加meta标签。 meta标签的目的：使布局视口的宽度与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no,maximum-scale=1.0,minimum-scale=1.0&quot;&gt; width - viewport的宽度，width=device-width页面适应设备宽度 initial-scale - 初始的缩放比 minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放，yes or no（1或0） 二倍图 物理像素&amp;物理像素比 CSS 像素：又称为虚拟像素、设备独立像素或逻辑像素，也可以理解为直觉像素。CSS 像素是 Web 编程的概念，指的是 CSS 样式代码中使用的逻辑像素。 iPhone 6 的 CSS 像素数为 375 x 667px。 物理像素：指屏幕显示的最小颗粒从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了。 iPhone 6 的物理像素为 750 x 1334 物理像素比：物理像素 / CSS 像素，这里的 CSS 像素其实是理想视口。iPhone 6 物理像素为 750 x 1334，理想视口 375 x 667 ，DPR = 2 对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，会造成图片模糊。在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题。 背景缩放background-size background-size 属性规定背景图像的尺寸 1background-size: 背景图片宽度 背景图片高度; 单位可以是 长度、百分比、cover、contain; 移动端开发 常见布局 移动端单独制作 流式布局（百分比布局） flex 弹性布局 less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp css3盒子模型 传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型：盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding CSS3中的盒子模型， padding 和 border 不会撑大盒子 1234/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box; 特殊样式 123456789/*CSS3盒子模型*/ box-sizing: border-box; -webkit-box-sizing: border-box; /*清除高亮,设置为transparent 完成透明*/ -webkit-tap-highlight-color: transparent; /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/ -webkit-appearance: none; /*禁用长按页面时的弹出菜单*/ img,a &#123; -webkit-touch-callout: none; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"暑假，目的论，自卑情结","slug":"summer","date":"2021-07-21T05:45:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2021/07/21/summer/","link":"","permalink":"https://youngsay.cn/2021/07/21/summer/","excerpt":"","text":"7月7日回到家，8.26号返校，不知不觉已经在家呆14天了，还有一个月就大二了…… 正如李宗盛《给自己的歌》中写道：“等你发现时间是贼了，它早已偷光你的选择”。想到第一次去学校的场景，现在还历历在目，一年的时间已经溜走，大学已完成了1/4，大学中能做的选择也已被偷走了1/4。 沉湎于过去毫无意义，过去已经不属于我了，我拥有的只有现在。我的人生就取决于当下。 《被讨厌的勇气》里有这样一段： 我有一位年轻朋友，虽然梦想着成为小说家，但却总是写不出作品。他说是因为工作太忙、写小说的时间非常有限，所以才写不出来作品，也从未参加过任何比赛。但真是如此吗？实际上，他是想通过不去比赛这一方式来保留一种“如果做的话我也可以”的可能性，即不愿出去被人评价，更不愿去面对因作品拙劣而落选的现实。他只想活在“只要有时间我也可以、只要环境具备我也能写、自己有这种才能”之类的可能性中。或许再过5年或者10年，他又会开始使用“已经不再年轻”或者“也已经有了家庭”之类的借口。 阿德勒心理学不同于弗洛伊德的“原因论”，ta主张的是“目的论”。一件事的结果不是由原因决定的，而是由目的决定的。上面的案例，那位梦想成为小说家的年轻人不能写出作品、没有参加过比赛并不是由时间太忙导致的，而是由他的目的决定的。他最直接的目的就是不想写小说、不想参加比赛。 我们做一件事也要以目的为导向，不能成为“原因论”的信徒。如果那位年轻人一直以“没有时间”为原因，他就永远写不出小说。如果一位有着心理创伤、恐惧出门的朋友一直以“受到过心理创伤”为原因就永远不能走出家门。 这就告诉我们过去怎样并不重要，决定我们人生的只有现在。所以做好手头的事、过好当下的每一天就够了。很流行的那句话“不念过去，不畏将来”不也是说的这个道理吗？ 书中还有一部分提到了自卑感和自卑情结，这对我很有启发。 阿德勒认为，自卑感不是一件坏事。人是作为一种无力的存在活在这个世界上。并且，人希望摆脱这种无力状态，继而就有了普遍欲求。阿德勒称其为“追求优越性”。 人都处于追求优越性这一“希望进步的状态”之中，树立某些理想或目标并努力为之奋斗。同时，对于无法达成理想的自己就会产生一种自卑感。例如，越是有远大志向的厨师也许就越会产生“还很不熟练”或者“必须做出更好的料理”之类的自卑感。 所以说我们要正视自卑，利用自卑感，使之成为努力和成长的催化剂。 你也许会说，自卑感越强，人就会变得越消极，最终肯定会认为自己一无是处。这不是自卑感，而是自卑情结。 这一点请注意。目前“自卑情结”这个词似乎在使用的时候与自卑感是一样的意思。就像“我为自己的单眼皮感到自卑”或者“他对自己的学历有自卑感”之类的描述中全都用“自卑情结”这个词来表示自卑感。其实，这完全是一种误用。自卑情结一词原本表示的是一种复杂而反常的心理状态，跟自卑感没有关系。例如，即使弗洛伊德提出的“俄狄浦斯情结”原本也是指一种对同性父母亲的反常对抗心理。 我理解的是自卑感不是坏事，而有了自卑情结是坏事。自卑情结是把自己的自卑当作一种借口。“因为我没有时间所以我写不出文章”“因为我小时候受过心理创伤所以不敢走出家门”，这都是在以自卑为借口，这是一种自卑情结。 虽然写不出作品和没有时间有一定关系，不出门与心理创伤有关，但这都不是必然联系。阿德勒用“外部因果律”来说明，就是说将原本没有任何因果关系的事情解释成似乎有重大因果关系一样。就像哲学中的主次矛盾，你一直以没有时间，以心理创伤为由，但这只是次要矛盾，甚至连矛盾都不算。如果抱着“因为我没有时间所以我写不出文章”之类的想法，那就不是“没时间写文章”而是“不想写文章”了。","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"元素显示与隐藏","slug":"visibility","date":"2021-06-16T14:00:01.000Z","updated":"2021-06-16T14:13:40.000Z","comments":true,"path":"2021/06/16/visibility/","link":"","permalink":"https://youngsay.cn/2021/06/16/visibility/","excerpt":"","text":"类似网站中的广告，点击关闭时消失，重新刷新页面再出现。 本质：让一个元素在页面中隐藏或者显示出来。 display display: none ；隐藏对象 display：block ；显示元素/转换为块元素 display 隐藏元素后，不再占有原来的位置。 visibility visibility：visible; 元素可视 visibility：hidden; 元素隐藏 visibility 隐藏元素后，仍占有原来的位置。 overflow overflow 属性指定在元素的内容太大而无法放入指定区域时是剪裁内容还是添加滚动条。 overflow 属性可设置以下值： visible - 默认。溢出没有被剪裁。内容在元素框外渲染 hidden - 溢出被剪裁，其余内容将不可见 scroll - 溢出被剪裁，同时添加滚动条以查看其余内容 auto - 与 scroll 类似，但仅在必要时添加滚动条 注释：overflow属性仅适用于具有指定高度的块元素。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css定位","slug":"position","date":"2021-06-12T05:49:01.000Z","updated":"2021-06-16T12:54:56.000Z","comments":true,"path":"2021/06/12/position/","link":"","permalink":"https://youngsay.cn/2021/06/12/position/","excerpt":"","text":"定位 浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。 定位=定位模式+边偏移 定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。 定位模式 1234position: static; /*静态定位*/position: relative; /*相对定位*/position: absolute; /*绝对定位*/position: fixed; /*固定定位*/ 边偏移 1234top: 20px; /*顶级偏移量，定义元素相对于父元素上边距的距离*/bottom: 20px; /*底部偏移量，定义元素相对于父元素下边距的距离*/left: 20px; /*左侧偏移量，定义元素相对于父元素左边距的距离*/right: 20px; /*右侧偏移量，定义元素相对于父元素右边距的距离*/ static 静态定位是元素的默认定位方式，无定位的意思。 1选择器 &#123; position: static; &#125; 静态定位按照标准流特性摆放位置，它没有边偏移 静态定位在布局时很少用到 relative 相对定位的偏移量相对于自身位置移动 1选择器 &#123;position: relative&#125;; 原来在标准流的位置继续占有，后面盒子仍以标准流方式对待它。 absolute 绝对定位的偏移量相对于父级元素移动。 1选择器 &#123; position: absolute; &#125; 当没有父级元素或父级元素没有定位时，以浏览器来偏移。 绝对定位不占有原先位置（脱标） 子绝父相 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。 父盒子需要加定位限制子盒子在父盒子内显示。 父盒子布局时，需要占有位置，因此父亲只能是相对定位。 fixed 固定定位是元素固定于浏览器可视区的位置。在浏览器页面滚动时不改变元素位置。 1选择器 &#123; position: fixed; &#125; 固定定位不占有原先位置（脱标） 小技巧：固定在版心右侧 小算法： 让固定定位的盒子 left: 50%. 走到浏览器可视区（版心） 的一半位置。 让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走版心宽度的一半位置就可以让固定定位的盒子贴着版心右侧对齐了。 总结 定位叠放次序 z-index 在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴)。 1z-index: auto; 数值可以是正整数、负整数或 0, 默认是 auto，数值越大，盒子越靠上。 如果属性值相同，则按照书写顺序，后来居上。 数字后面不能加单位。 只有定位的盒子才有 z-index 属性。 拓展 绝对定位盒子居中 加了绝对定位的盒子不能通过 margin:0 auto 水平居中 居中方法与【小技巧：固定在版心右侧】相似 ① left: 50%;：让盒子的左侧移动到父级元素的水平中心位置。 ② margin-left: -100px;：让盒子向左移动自身宽度的一半 定位特殊特性 绝对定位和固定定位也和浮动类似。 行内元素添加绝对或者固定定位，可以直接设置高度和宽度。 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。 外边距塌陷 脱标的盒子不会触发外边距塌陷。浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 绝对定位（固定定位）会完全压住盒子 浮动元素只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）。 绝对定位（固定定位） 会压住下面标准流所有的内容。 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素。","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css浮动","slug":"float","date":"2021-06-05T15:31:01.000Z","updated":"2021-06-06T03:37:56.000Z","comments":true,"path":"2021/06/05/float/","link":"","permalink":"https://youngsay.cn/2021/06/05/float/","excerpt":"","text":"网页布局 标准流 块级元素：独占一行，从上向下顺序排列。 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素：按照顺序从左到右顺序排列，碰到父元素边缘则自动换行。 常用元素：span、a、i、em等 以上都是标准流布局，标准流是最基本的布局方式。 浮动 定位 浮动 float属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。 1float: left; /*right/none*/ 浮动和标准流的父盒子搭配。 先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置 一个元素浮动了，理论上其余的兄弟元素也要浮动。 一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。 浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流。 清除浮动 为什么要清除浮动 由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。 清除浮动本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 清除浮动 额外标签法 额外标签法也称为隔墙法，是 W3C 推荐的做法。 额外标签法会在浮动元素末尾添加一个空的标签。 1&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt; 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差 注意： 要求这个新的空标签必须是块级元素。 父级添加overflow 给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll 优点：代码简洁 缺点：无法显示溢出的部分 :after伪元素法 给父元素添加 12345678910.clearfix:after &#123; content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; /* IE6、7 专有 */ *zoom: 1;&#125; 优点：没有增加标签，结构更简单 缺点：照顾低版本浏览器 代表网站： 百度、淘宝网、网易等 双伪元素法 给父元素添加 12345678910.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 优点：代码更简洁 缺点：照顾低版本浏览器 代表网站：小米、腾讯等 总结","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"盒子边框","slug":"box","date":"2021-06-03T05:25:01.000Z","updated":"2022-03-31T04:12:32.000Z","comments":true,"path":"2021/06/03/box/","link":"","permalink":"https://youngsay.cn/2021/06/03/box/","excerpt":"","text":"边框 12345border-width/*定义边框粗细，单位px*/border-style /*边框样式 solid实先 dashed虚线 dotted点线 */border-color /*边框颜色*/border: 1px solid red; /*简写*/border-collapse:collapse; /*表示相邻边框合并*/ 内边距 padding内边距，即边框和内容之间的距离 1234567padding:5px; /*上下左右都有5像素内边距*/padding:5px 10px; /*上下5px，左右10px*/padding:5px 10px 20px; /*上内边距5px，左右10px，下20px*/padding:5px 10px 20px 30px; /*上5，右10，下20，左30*/ 外边距 margin 用于设置外边距，即控制盒子和盒子之间的距离。 块级盒子水平居中 外边距可以让块级盒子水平居中，但是必须满足两个条件： ①盒子必须指定了宽度（width）。 ②盒子左右的外边距都设置为auto 。 123456789.header&#123; width:960px; margin:0 auto;&#125;/*常见写法：*/margin-left: auto;margin-right: auto;margin: auto;margin: 0 auto; 清除内外边距 1234* &#123; padding:0;/*清除内边距*/ margin:0;/*清除外边距*/&#125; 圆角边框 1border-radius: length; /*参数值可以为数值或百分比的形式*/ 盒子阴影 1box-shadow: h-shadow v-shadow blur spread color inset;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"讲座，机会，关系","slug":"new","date":"2021-06-02T12:25:01.000Z","updated":"2025-10-10T08:30:40.000Z","comments":true,"path":"2021/06/02/new/","link":"","permalink":"https://youngsay.cn/2021/06/02/new/","excerpt":"","text":"换新电脑了，开心o(￣▽￣)ブ 旧电脑有些年头了，太卡了，打开个VS Code都要卡好久，严重影响心情……趁着618在京东入手了荣耀Magicbook pro 2020，我的要求不高，能满足日常学习娱乐就行。新电脑体验不错，激活电脑后就在新电脑上部署了Hexo博客，参考了这篇教程。 在新电脑上部署Hexo 讲座 前不久听了一位学长的讲座，学长现在在字节跳动实习，做着我憧憬的工作👨‍💻。 学长是我们学院信科专业的，考上了北京理工大学的研究生。他讲了大学、考研、实习经历，听后我很佩服，也很羡慕。想起了薛兆丰的话，大意是：**看见别人打到鱼你也要打鱼，你有网吗？打鱼只要一天，织网呢？**是啊，我只看到了他收获的果实，却没看到他为此付出的努力。即使天资聪颖的人想要成功，都要付出努力，何况平庸的我呢！他做的是前端岗位，我也对前端很感兴趣。讲座后他展示了他的微信，我加了，但一直没敢聊天，内向+不知道说些什么…… 机会 在日常生活中，我们会得到很多机会，但我大都没把握住。 军训休息时，我们连和十二连一起做游戏。1v1蒙眼pk，最先碰到头的人胜。十二连的人都很积极，我们连仅有几个人参与，我也一直没敢参与，到最后没有人参与了。然后我们被教官罚了，全体蹲了5分钟。 电工学最后一堂课，老师给我们一些回答问题的机会，帮我们加下平时成绩。很多问题我都会，但没有回答，到最后没有机会再回答了。 人们后悔的往往不是做错了什么，而是错过了什么。 关系 我们每天都在面对各种各样的关系。人与世界的关系，人与人之间的关系，最重要的是人和自己内心的关系。我现在处理最多的就是我与室友的关系。同学、室友都不是我们主动选择的，能相遇仅仅是缘分。三观不合、兴趣不同是正常的事，能遇到合得来的室友才是意外的惊喜。室友，毕竟是舍友；舍友，不就是个舍友吗。《千与千寻》中写道： 人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。 没有长久的关系，只有短暂的相遇。想想小学、初中和高中的同学，能来往的又有几人。有些事必须是一个人也只能是一个人做的。与人与自己内心的关系相比，人与人的关系显得不那么重要。处理好人与自己内心的关系，人和人的关系便没有关系，没有关系是最稳定的关系。","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[]},{"title":"typora+picgo+Gitee实现图片上传","slug":"picgo","date":"2021-05-12T07:42:01.000Z","updated":"2021-08-19T07:43:24.000Z","comments":true,"path":"2021/05/12/picgo/","link":"","permalink":"https://youngsay.cn/2021/05/12/picgo/","excerpt":"","text":"Typora 设置上传图片功能，图片可以自动提交到图床，大大提高了工作效率。如何将Typora编辑器中的图片上传到自己的图床，我们将用Typora+PicGo+Gitee实现图片上传。 Gitee 1.注册、登录码云 Gitee网址：https://gitee.com （注册登录操作不再介绍） 2.创建一个仓库当做图床 注意我标红的地方，然后选择创建就ok了。 3.创建私人令牌 找到设置——安全设置——生成新令牌 描述私人令牌，选择projects，提交。==复制令牌，可以记录在text等地方，稍后会用到。== PicGo 一款可以上传、管理图床的工具，支持腾讯图床、七牛图床等多种图床，可以自己探索。本篇用的是GItee图床。 1.下载、安装PicGo 下载地址：https://github.com/Molunerfinn/picgo/releases 选择自己的版本，下载安装即可。 2.安装Gitee插件 注：若没有 node.js ，无法安装Gitee插件。官网：https://nodejs.org/zh-cn 下载安装即可。 一切顺利，打开PicGO——插件设置——搜索gitee 有两个插件，任选其一安装即可。==当插件安装不了，一直显示安装中，请执行下面操作。安装成功的可以忽略。== 在搜索中输入cmd，以管理员身份运行命令行提示符（右键–&gt;以管理员身份运行）。 输入：cd &quot;C:\\Users\\用户名\\AppData\\Roaming\\picgo&quot;，进入picgo目录，输入：npm install picgo-plugin-插件名称安装插件。安装gitee插件可直接输入：npm install picgo-plugin-gitee-uploader。 3.配置Gitee插件 在PicGo设置中选择Gitee图床 配置图床 后三个配置可以默认，之后点确定就大功告成了。可以手动上传图片了。 Typora 1.下载、安装Typora 官网地址：https://www.typora.io 2.配置Typora 文件——偏好设置——图形 3.上传验证 点击验证图片上传选项验证是否配置成功 常见错误 1. Failed to fetch PicGo的端口设置错误，打开 PicGo设置 &gt; 设置Service，将端口设置为36677。 2. {“success”,false} 文件名重复错误，PicGo设置``中开启时间戳重命名`","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"每日一道c语言","slug":"c-100","date":"2021-05-08T11:31:01.000Z","updated":"2022-02-20T09:33:16.000Z","comments":true,"path":"2021/05/08/c-100/","link":"","permalink":"https://youngsay.cn/2021/05/08/c-100/","excerpt":"","text":"我又来给自己挖坑了，定个小目标。从今天起每天一道c语言，争取做够100道。 5.8 题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去 掉不满足条件的排列。 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; int i, j, k; for (i = 1; i &lt; 5; i++) // 以下为三重循环 &#123; for (j = 1; j &lt; 5; j++) &#123; for (k = 1; k &lt; 5; k++) // 确保i、j、k三位互不相同 &#123; if (i != k &amp;&amp; i != j &amp;&amp; j != k) &#123; printf(&quot;%d%d%d\\n&quot;, i, j, k); &#125; &#125; &#125; &#125; return 0;&#125; 百位有4种选择，为使十位与百位不重复，十位有3种选择，同理，个位有2中选择，总共有4x3x2=24种选择。 5.9 题目：企业发放的奖金根据利润提成。 利润(I)低于或等于10万元时，奖金可提10%； 利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%； 20万到40万之间时，高于20万元的部分，可提成5%； 40万到60万之间时高于40万元的部分，可提成3%； 60万到100万之间时，高于60万元的部分，可提成1.5%； 高于100万元时，超过100万元的部分按1%提成。 从键盘输入当月利润I，求应发放奖金总数？ 程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main()&#123; double i=0; double a = 0; printf(&quot;输入你的利润&quot;); scanf(&quot;%lf&quot;, &amp;i); if (i &lt;= 100000) &#123; a = 0.1 * i; &#125; else if (i &lt;= 200000) &#123; a = 0.1 * 100000 + 0.075 * (i - 100000); &#125; else if (i &lt;= 400000) &#123; a = (i - 200000) * 0.05; &#125; else if (i &lt;= 600000) &#123; a = (i - 400000) * 0.03; &#125; else if (i &lt;= 1000000) &#123; a = (i - 600000) * 0.015; &#125; else if (i &gt; 1000000) &#123; a = (i - 1000000) * 0.01; &#125; printf(&quot;你的净利润为%lf\\n&quot;, i); printf(&quot;你的提成为%lf&quot;, a); return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"}]},{"title":"为hexo内的文章加密","slug":"password","date":"2021-05-07T01:58:37.000Z","updated":"2021-05-07T02:03:14.000Z","comments":true,"path":"2021/05/07/password/","link":"","permalink":"https://youngsay.cn/2021/05/07/password/","excerpt":"","text":"最近，我的博客地址被朋友知道了。这使我有些顾虑，写什么也变得不自在。每个人都有秘密，或许藏在心里，或许告诉亲密的人，或许分享给陌生人。 每个人都很难精神裸体，至少我很难。如果我写什么都要被朋友看到，那和发朋友圈有什么区别。于是决定给一些文章加密，密码统一为我全球最大的同性交友网站的用户名（你懂的，手动狗头）。 下面分享一下为hexo内文章加密的一种方法。 安装 1npm install --save hexo-blog-encrypt 快速开始 在 站点配置文件 中启用该插件: 12encrypt: enable: true 然后在文章头部添加上对应的字段，如 password, abstract, message 123456---keywords: 博客文章密码password: bugaosuniabstract: 这是一篇加密的文章message: 输入密码，查看文章--- password: 博客文章加密使用的密码 abstract: 文章摘要，会显示在博客的列表页 message: 博客查看时，密码输入框上面的描述性文字","categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"Linux磁盘管理","slug":"filesystem","date":"2021-05-01T04:25:01.000Z","updated":"2021-05-02T10:02:28.000Z","comments":true,"path":"2021/05/01/filesystem/","link":"","permalink":"https://youngsay.cn/2021/05/01/filesystem/","excerpt":"","text":"Linux磁盘管理好坏直接关系到整个系统的性能问题。 Linux磁盘管理常用命令为 df、du。 df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 df df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法： 1df [-ahikHTm] [目录或文件名] 选项与参数： -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 将系统内所有的文件系统列出来！# 在 Linux 底下如果 df 没有加任何选项# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！[root@kuangshen /]# dfFilesystem 1K-blocks Used Available Use% Mounted ondevtmpfs 889100 0 889100 0% /devtmpfs 899460 704 898756 1% /dev/shmtmpfs 899460 496 898964 1% /runtmpfs 899460 0 899460 0% /sys/fs/cgroup/dev/vda1 41152812 6586736 32662368 17% /tmpfs 179896 0 179896 0% /run/user/0# 将容量结果以易读的容量格式显示出来[root@kuangshen /]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 869M 0 869M 0% /devtmpfs 879M 708K 878M 1% /dev/shmtmpfs 879M 496K 878M 1% /runtmpfs 879M 0 879M 0% /sys/fs/cgroup/dev/vda1 40G 6.3G 32G 17% /tmpfs 176M 0 176M 0% /run/user/0# 将系统内的所有特殊文件格式及名称都列出来[root@kuangshen /]# df -aTFilesystem Type 1K-blocks Used Available Use% Mounted onsysfs sysfs 0 0 0 - /sysproc proc 0 0 0 - /procdevtmpfs devtmpfs 889100 0 889100 0% /devsecurityfs securityfs 0 0 0 - /sys/kernel/securitytmpfs tmpfs 899460 708 898752 1% /dev/shmdevpts devpts 0 0 0 - /dev/ptstmpfs tmpfs 899460 496 898964 1% /runtmpfs tmpfs 899460 0 899460 0% /sys/fs/cgroupcgroup cgroup 0 0 0 - /sys/fs/cgroup/systemdpstore pstore 0 0 0 - /sys/fs/pstorecgroup cgroup 0 0 0 - /sys/fs/cgroup/freezercgroup cgroup 0 0 0 - /sys/fs/cgroup/cpusetcgroup cgroup 0 0 0 - /sys/fs/cgroup/hugetlbcgroup cgroup 0 0 0 - /sys/fs/cgroup/blkiocgroup cgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_priocgroup cgroup 0 0 0 - /sys/fs/cgroup/memorycgroup cgroup 0 0 0 - /sys/fs/cgroup/pidscgroup cgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacctcgroup cgroup 0 0 0 - /sys/fs/cgroup/devicescgroup cgroup 0 0 0 - /sys/fs/cgroup/perf_eventconfigfs configfs 0 0 0 - /sys/kernel/config/dev/vda1 ext4 41152812 6586748 32662356 17% /systemd-1 - - - - - /proc/sys/fs/binfmt_miscmqueue mqueue 0 0 0 - /dev/mqueuedebugfs debugfs 0 0 0 - /sys/kernel/debughugetlbfs hugetlbfs 0 0 0 - /dev/hugepagestmpfs tmpfs 179896 0 179896 0% /run/user/0binfmt_misc binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc# 将 /etc 底下的可用的磁盘容量以易读的容量格式显示[root@kuangshen /]# df -h /etcFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.3G 32G 17% / du Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。 语法： 1du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； 测试： 12345678910111213141516171819202122232425# 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。[root@kuangshen home]# du16 ./redis8 ./www/.oracle_jre_usage # 包括隐藏文件的目录24 ./www48 . # 这个目录(.)所占用的总量# 将文件的容量也列出来[root@kuangshen home]# du -a4 ./redis/.bash_profile4 ./redis/.bash_logout ....中间省略....4 ./kuangstudy.txt # 有文件的列表了48 .# 检查根目录底下每个目录所占用的容量[root@kuangshen home]# du -sm /*0 /bin146 /boot.....中间省略....0 /proc.....中间省略....1 /tmp3026 /usr # 系统初期最大就是他了啦！513 /var2666 /www 通配符 * 来代表每个目录。 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。 磁盘挂载与卸除 根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令。 磁盘挂载语法： 1mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 测试： 123456# 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！[root@www ~]# mkdir /mnt/hdc6[root@www ~]# mount /dev/hdc6 /mnt/hdc6[root@www ~]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： 1umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除。 卸载/dev/hdc6 1[root@www ~]# umount /dev/hdc6","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"Linux用户和用户组的管理","slug":"useradd","date":"2021-04-30T13:23:01.000Z","updated":"2021-05-02T10:01:14.000Z","comments":true,"path":"2021/04/30/useradd/","link":"","permalink":"https://youngsay.cn/2021/04/30/useradd/","excerpt":"","text":"Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。 每个用户账号都拥有一个唯一的用户名和各自的口令。 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 一、用户账号管理 1、添加账户 1useradd 选项 用户名 -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 1# useradd –d /home/sam -m sam 此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。 2、删除帐号 如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。 删除一个已有的用户账号使用userdel命令，其格式如下： 1userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： 1# userdel -r sam 此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 3、切换账号 1su 用户名 $表示普通用户；#表示超级用户 4、修改帐号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 修改已有用户的信息使用usermod命令，其格式如下： 1usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 例如： 1# usermod -s /bin/ksh -d /home/z –g developer kuangshen 此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 5、用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。 命令的格式为： 1passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 如果默认用户名，则修改当前用户的口令。 例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令： 1234$ passwd Old password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令： 123# passwd kuangshenNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。 为用户指定空口令时，执行下列形式的命令： 1# passwd -d kuangshen 此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： 1# passwd -l kuangshen 二、用户组的管理 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。 1、增加用户组 1groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 1# groupadd group1 此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。 1# groupadd -g 101 group2 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。 2、删除用户组 1groupdel 用户组 3、修改用户组 1groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 1# groupmod -g 102 group2 此命令将组group2的组标识号修改为102。 1# groupmod –g 10000 -n group3 group2 此命令将组group2的标识号改为10000，组名修改为group3。 4、切换用户组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： 1$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。 来源：https://www.runoob.com/linux/linux-user-manage.html","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"vim的使用","slug":"vim","date":"2021-04-29T05:25:01.000Z","updated":"2021-05-02T10:00:04.000Z","comments":true,"path":"2021/04/29/vim/","link":"","permalink":"https://youngsay.cn/2021/04/29/vim/","excerpt":"","text":"什么是 vim？ Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vim 是一个程序开发工具而不是文字处理软件。 vim 键盘图： vi/vim 的使用 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： vi/vim 按键说明 除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制与贴上 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用) r, R 进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) 上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ [Esc] 退出编辑模式，回到一般模式中(常用) 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) ZQ 不保存，强制退出。效果等同于 :q!。 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。 举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。 来源：https://www.runoob.com/linux/linux-vim.html","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"Linux基础命令(2)","slug":"linux2","date":"2021-04-22T13:07:01.000Z","updated":"2021-05-02T10:08:04.000Z","comments":true,"path":"2021/04/22/linux2/","link":"","permalink":"https://youngsay.cn/2021/04/22/linux2/","excerpt":"","text":"看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用&quot;d&quot;表示。&quot;d&quot;在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限； 第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限； 第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 chgrp 更改文件属组 1chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 chown 更改文件属主，也可以同时更改文件属组 12chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名 chmod 更改文件9个属性 1chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： 1r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 1chmod 770 filename 查看文件内容 概述 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 cat 由第一行开始显示文件内容 语法： 1cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 测试： 12345# 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes tac tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： 1234[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0 nl 显示行号 语法： 1nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 测试： 1234[root@kuangshen ~]# nl /etc/sysconfig/network-scripts/ifcfg-eth01 DEVICE=eth02 BOOTPROTO=dhcp3 ONBOOT=yes more 一页一页翻动 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 123[root@kuangshen etc]# more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动 以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； head 取出文件前面几行 语法： 1head [-n number] 文件 选项与参数：-n 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： 1[root@kuangshen etc]# head -n 20 /etc/csh.login tail 取出文件后面几行 语法： 1tail [-n number] 文件 选项与参数： -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： 1[root@kuangshen etc]# tail -n 20 /etc/csh.login 拓展：Linux 链接概念 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。 情况下，ln 命令产生硬链接。 硬连接 硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软连接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试： 12345678910[root@kuangshen /]# cd /home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 12345678910111213# echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 依此您可以做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。 作者：狂神说","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"Linux基础命令(1)","slug":"linux1","date":"2021-04-21T14:57:01.000Z","updated":"2021-05-02T10:07:48.000Z","comments":true,"path":"2021/04/21/linux1/","link":"","permalink":"https://youngsay.cn/2021/04/21/linux1/","excerpt":"","text":"ls 列出目录 12[root@VM-16-9-centos /]# ls [-aAdfFhilnrRSt]目录文件 -a：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来 -l ：长数据串列出，包含文件的属性与权限等等数据 1[root@VM-16-9-centos www]# ls -al 将目录下的所有文件列出来(含属性与隐藏档) cd 切换目录 Change Directory 1cd [相对路径或绝对路径] 123456#回到自己的家目录，即/root[root@VM-16-9-centos /]# cd ~#回到根目录[root@VM-16-9-centos ~]# cd /#回到上一级[root@VM-16-9-centos /]# cd .. pwd 显示目前所在目录 Print Working Directory 12[root@VM-16-9-centos ~]# pwd/root -P：显示出确实的路径，而非使用连接(link) 路径 123456# 单纯显示出目前的工作目录[root@VM-16-9-centos bin]# pwd/bin# 如果是链接，要显示真实地址，可以使用 -P参数[root@VM-16-9-centos bin]# pwd -P/usr/bin mkdir 创建新目录 make directory 1mkdir [-mp] 目录名称 -m ：配置文件的权限。直接配置，不需要看默认权限 (umask) 的脸色 -p ：直接将所需要的目录(包含上一级目录)递归创建起来！ 123456# 创建多层目录[root@VM-16-9-centos /]# mkdir -p zhang/zhang/zhang# 创建权限为 rwx--x--x目录[root@VM-16-9-centos home]# mkdir -m 711 test2[root@VM-16-9-centos home]# ls -ldrwx--x--x 2 root root 4096 Mar 12 21:58 test2 rmdir 删除空目录 1rmdir [-p] 目录名称 -p：连同上一级空目录一起删除 cp 复制文件或目录 12[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory **-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) rm 移除文件或目录 1rm [-fir] 文件或目录 -f ：force，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除,非常危险 12345# 将刚刚在 cp 的实例中创建的 install.sh删除掉！[root@kuangshen home]# rm -i install.shrm: remove regular file ‘install.sh’? y# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf / mv 移动文件或目录，或修改名称 12[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 12345678910111213141516171819# 复制一个文件到当前目录[root@kuangshen home]# cp /root/install.sh /home# 创建一个文件夹 test[root@kuangshen home]# mkdir test# 将复制过来的文件移动到我们创建的目录，并查看[root@kuangshen home]# mv install.sh test[root@kuangshen home]# lstest[root@kuangshen home]# cd test[root@kuangshen test]# lsinstall.sh# 将文件夹重命名，然后再次查看！[root@kuangshen test]# cd ..[root@kuangshen home]# mv test mvtest[root@kuangshen home]# lsmvtest","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"}]},{"title":"css三大特性：层叠性、继承性、优先级","slug":"css-inherit","date":"2021-04-12T10:25:01.000Z","updated":"2021-04-12T12:05:56.000Z","comments":true,"path":"2021/04/12/css-inherit/","link":"","permalink":"https://youngsay.cn/2021/04/12/css-inherit/","excerpt":"","text":"层叠性 层叠性指当标签被设置了多个重复的样式时，一个属性会被覆盖。 不考虑优先级，层叠性遵循“就近原则”。如下，最终颜色为绿色。 123456div&#123; color:red;&#125;div&#123; color:green;&#125; 继承性 继承性是指子标签没有设置样式时，继承父标签样式。 继承性只适用于字体的颜色，大小、行间距等文本类属性，边框、外边距、内边距、定位、元素高度等与块级相关属性不能继承。 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style&gt; div&#123;color:green;font-size:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt; 我是绿色的 &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 优先级 !important &gt; 行内样式 &gt; ID 选择器 &gt; 类(伪元素、伪类、属性)选择器 &gt; 元素选择器 权重相同时，遵循“就近原则”；权重不同时，权重大的生效。 注意： 继承的权重为0 权重叠加： div ul li ----&gt; 0,0,0,3 .nav ul li ----&gt; 0,0,1,2 a:hover ----&gt; 0,0,1,1 #first .nav ----&gt; 0,1,1,0","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css背景","slug":"background","date":"2021-04-10T05:25:01.000Z","updated":"2021-04-11T03:06:12.000Z","comments":true,"path":"2021/04/10/background/","link":"","permalink":"https://youngsay.cn/2021/04/10/background/","excerpt":"","text":"通过CSS 背景属性，可以给页面元素添加背景样式。 背景属性可以设置背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定等。 123456background-color: 颜色值; /*背景颜色*/background-image: url(); /*背景图片*/background-repeat: repeat |no-repeat |repeat-x |repeat-y ; /*背景平铺*/background-position: x y; /*背景位置*/background-attachment: fixed|scroll; /*背景附着*/background: rgba(0,0,0,0.3) /*背景色半透明*/ 背景图片位置 参数是方位名词 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 参数是精确单位 如果参数值是精确坐标，那么第一个肯定是x 坐标，第二个一定是y坐标 如果只指定一个数值，那该数值一定是x坐标，另一个默认垂直居中 参数是混合单位 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标 背景复合写法 1background: transparent url(image.jpg) repeat-y fixed top ; 为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性background 中。从而节约代码量.当使用简写属性时，没有特定的书写顺序,一般习惯约定顺序为：background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"元素显示模式及转换","slug":"display","date":"2021-04-09T05:00:01.000Z","updated":"2021-04-09T05:04:06.000Z","comments":true,"path":"2021/04/09/display/","link":"","permalink":"https://youngsay.cn/2021/04/09/display/","excerpt":"","text":"元素显示模式就是元素（标签）以什么方式进行显示。比如&lt;div&gt;自己占一行，比如一行可以放多个&lt;span&gt;。HTML元素一般分为块元素和行内元素两种类型 块元素 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 特点： 自己独占一行。 高度，宽度、外边距以及内边距都可以控制。 宽度默认是容器（父级宽度）的100%。 是一个容器及盒子，里面可以放行内或者块级元素。 注意： 文字类的元素内不能使用块级元素 &lt;p&gt;标签主要用于存放文字，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt; &lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素 行内元素 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt; 标签是最典型的行内元素。有的地方也将行内元素称为内联元素。 特点： 相邻行内元素在一行上，一行可以显示多个。 高、宽直接设置是无效的。 默认宽度就是它本身内容的宽度。 行内元素只能容纳文本或其他行内元素。 注意： 链接里面不能再放链接 特殊情况链接&lt;a&gt; 里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全 行内块元素 在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。 特点： 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）。 默认宽度就是它本身内容的宽度（行内元素特点）。 高度，行高、外边距以及内边距都可以控制（块级元素特点） 元素转换 123display: block; /*转换为块元素*/display: inline; /*转换为行内元素*/display: inline-block; /*转换为行内块*/ 实例 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; a &#123; display: block; width: 230px; height: 40px; background-color: #55585a; font-size: 14px; color: #fff; text-decoration: none; text-indent: 2em; line-height: 40px; &#125; a:hover &#123; background-color: #ff6700;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot;&gt;手机 电话卡&lt;/a&gt; &lt;a href=&quot;&quot;&gt;电视&lt;/a&gt; &lt;a href=&quot;&quot;&gt;笔记本&lt;/a&gt; &lt;a href=&quot;&quot;&gt;穿戴&lt;/a&gt; &lt;a href=&quot;&quot;&gt;其他&lt;/a&gt;&lt;/html&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"css伪类选择器","slug":"css-hover","date":"2021-04-08T13:25:01.000Z","updated":"2021-04-09T05:04:48.000Z","comments":true,"path":"2021/04/08/css-hover/","link":"","permalink":"https://youngsay.cn/2021/04/08/css-hover/","excerpt":"","text":"伪类选择器用于向某些选择器添加特殊的效果，伪类选择器有链接伪类、结构伪类等。 链接伪类 1234a: link /*未访问的链接*/a: visited /*已访问的链接*/a: hover /*鼠标悬停的链接*/a: active /*已选择的链接*/ 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;/* unvisited link */a:link &#123; color: red;&#125;/* visited link */a:visited &#123; color: green;&#125;/* mouse over link */a:hover &#123; color: hotpink;&#125;/* selected link */a:active &#123; color: blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;CSS 链接&lt;/h1&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;/index.html&quot; target=&quot;_blank&quot;&gt;这是一个链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:hover 必须位于 a:link 和 a:visited 之后才能生效。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;在 CSS 定义中，a:active 必须位于 a:hover 之后才能生效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; focus伪类 :focus伪类选择器用于选取获得焦点的表单元素。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; input:focus &#123; background-color: aqua; color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;text&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"emmet语法","slug":"emmet","date":"2021-04-07T04:49:01.000Z","updated":"2021-04-07T07:12:48.000Z","comments":true,"path":"2021/04/07/emmet/","link":"","permalink":"https://youngsay.cn/2021/04/07/emmet/","excerpt":"","text":"Emmet语法的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该语法。 快速生成HTML结构语法 标签 div 然后tab 键 1&lt;div&gt;&lt;/div&gt; 多个相同标签 div*3 123&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 父子级标签 可以用 &gt; ，比如 ul &gt; li 123&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 兄弟标签 用 + ,比如 div+p 12&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 有类名或者id名字 直接写 .demo 或者 #two, tab 键 12&lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt; 有顺序的div类名 自增符号 ‘div `div‘div*5` 12345&lt;div1&gt;&lt;/div1&gt;&lt;div2&gt;&lt;/div2&gt;&lt;div3&gt;&lt;/div3&gt;&lt;div4&gt;&lt;/div4&gt;&lt;div5&gt;&lt;/div5&gt; 标签内部写内容 { } div{胖虎同学} 1&lt;div&gt;胖虎同学&lt;/div&gt; 快速生成CSS样式语法 w200 按tab 可以 生成 width: 200px; lh26px 按tab 可以生成 line-height: 26px; 参考资料： emmet语法,","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"},{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"}]},{"title":"html表单元素","slug":"html-form","date":"2021-04-06T14:32:01.000Z","updated":"2021-04-06T14:56:10.000Z","comments":true,"path":"2021/04/06/html-form/","link":"","permalink":"https://youngsay.cn/2021/04/06/html-form/","excerpt":"","text":"HTML 表单用于搜集不同类型的用户输入。 input元素 &lt;input type=&quot; &quot;&gt; radio 单选按钮 text 单行文本输入 submit 提交按钮 checkbox 多选按钮 password 定义密码字段 select元素 下拉列表， option 元素定义待选择的选项,selected 属性定义预定义选项。 12345&lt;select name=&quot;language&quot;&gt;&lt;option value=&quot;Chinese&quot; selected&gt;Chinese&lt;/option&gt;&lt;option value=&quot;English&quot;&gt;Saab&lt;/option&gt;&lt;option value=&quot;Japanese&quot;&gt;Fiat&lt;/option&gt;&lt;/select&gt; textarea元素 多行文本输入 综合实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;html表单练习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;!-- 第一行 --&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nan&quot;&gt; &lt;label for=&quot;nan&quot;&gt;&lt;img height=&quot;20px&quot; src=&quot;img/man.png&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nv&quot;&gt;&lt;label for=&quot;nv&quot;&gt;&lt;img height=&quot;20px&quot; src=&quot;img/woman.png&quot;&gt;女&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;月薪&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option &gt;请选择月薪范围&lt;/option&gt; &lt;option &gt;低于5k&lt;/option&gt; &lt;option &gt;5k-1w&lt;/option&gt; &lt;option &gt;1w-1.5w&lt;/option&gt; &lt;option &gt;1.5w-2w&lt;/option&gt; &lt;option &gt;2w+&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;地区：&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; value=&quot;输入工作地区&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;婚姻状况：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot; name=&quot;marry&quot; checked=&quot;checked&quot; id=&quot;marry&quot;&gt;&lt;label for=&quot;marry&quot;&gt;已婚&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot;&gt;已婚&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第五行 --&gt; &lt;tr&gt; &lt;td&gt;学历：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;输入学历&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第六行 --&gt; &lt;tr&gt; &lt;td&gt;性格：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;xingge&quot;&gt;活泼开朗 &lt;input type=&quot;checkbox&quot; name=&quot;xingge&quot;&gt;沉闷呆板 &lt;input type=&quot;checkbox&quot; name=&quot;xingge&quot;&gt;严肃稳重 &lt;/tr&gt; &lt;!-- 第七行 --&gt; &lt;tr&gt; &lt;td&gt;个人介绍：&lt;/td&gt; &lt;td&gt; &lt;textarea&gt; 个人简介 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第八行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;确认&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第九行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; value=&quot;确认&quot; checked=&quot;checked&quot;&gt;我承诺信息准确&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"}]},{"title":"css基础选择器和组合选择器","slug":"css","date":"2021-04-02T09:30:01.000Z","updated":"2021-04-02T09:30:46.000Z","comments":true,"path":"2021/04/02/css/","link":"","permalink":"https://youngsay.cn/2021/04/02/css/","excerpt":"","text":"css选择器用于选取要设置样式的HTML元素。 基础选择器 id选择器 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;style&gt;#para1 &#123; text-align: center; color: blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=&quot;para1&quot;&gt;胖虎同学&lt;/p&gt;&lt;p&gt;www.wangyouwu.cn&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 元素选择器 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;style&gt;h1 &#123; text-align: center; color: red;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;胖虎同学&lt;/h1&gt;&lt;p&gt;只有h1才会变红&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 类选择器 12345678910111213&lt;html&gt;&lt;head&gt;&lt;style&gt;.center &#123; background: green;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 class=&quot;center&quot;&gt;我被绿了&lt;/h1&gt;&lt;p&gt;你被绿了。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 表现： tips 组合器选择器 后代选择器（空格） 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;style&gt;div p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;后代选择器&lt;/h1&gt;&lt;p&gt;后代选择器匹配作为指定元素后代的所有元素。&lt;/p&gt;&lt;div&gt; &lt;p&gt;div 中的段落 1。&lt;/p&gt; &lt;p&gt;div 中的段落 2。&lt;/p&gt; &lt;section&gt;&lt;p&gt;div 中的段落 3。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;p&gt;段落 4。不在 div 中。&lt;/p&gt;&lt;p&gt;段落 5。不在 div 中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 子选择器（&gt;) 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;style&gt;div &gt; p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;子选择器&lt;/h1&gt;&lt;p&gt;子选择器 (&gt;) 选择属于指定元素子元素的所有元素。&lt;/p&gt;&lt;div&gt; &lt;p&gt;div 中的段落 1。&lt;/p&gt; &lt;p&gt;div 中的段落 2。&lt;/p&gt; &lt;section&gt;&lt;p&gt;div 中的段落 3。&lt;/p&gt;&lt;/section&gt; &lt;!-- 非子但属后代 --&gt; &lt;p&gt;div 中的段落 4。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;段落 5。不在 div 中。&lt;/p&gt;&lt;p&gt;段落 6。不在 div 中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 相邻兄弟选择器（+） 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt;&lt;style&gt;div + p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;相邻兄弟选择器&lt;/h1&gt;&lt;p&gt;相邻的同胞选择器（+）选择所有作为指定元素的相邻的同级元素。&lt;/p&gt;&lt;div&gt; &lt;p&gt;div 中的段落 1。&lt;/p&gt; &lt;p&gt;div 中的段落 2。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;段落 3。不在 div 中。&lt;/p&gt;&lt;p&gt;段落 4。不在 div 中。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： 通用兄弟选择器（~） 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt;&lt;style&gt;div ~ p &#123; background-color: yellow;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;通用兄弟选择器&lt;/h1&gt;&lt;p&gt;通用的兄弟选择器（~）选择指定元素的所有同级元素。&lt;/p&gt;&lt;p&gt;段落 1。&lt;/p&gt;&lt;div&gt; &lt;p&gt;段落 2。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;段落 3。&lt;/p&gt;&lt;code&gt;一些代码。&lt;/code&gt;&lt;p&gt;段落 4。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 表现： Tips 除此之外，还有伪类选择器（根据特定状态选取元素）、伪元素选择器（根据元素的一部分并设置其样式）、属性选择器（根据属性或属性值来选取元素）。随着以后遇到再深入学习。 css选择器,","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"}]},{"title":"HTML速查手册","slug":"html","date":"2021-03-31T11:59:01.000Z","updated":"2022-01-09T22:37:08.000Z","comments":true,"path":"2021/03/31/html/","link":"","permalink":"https://youngsay.cn/2021/03/31/html/","excerpt":"","text":"HTML Basic Document 12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Document name goes here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Visible text goes here&lt;/body&gt;&lt;/html&gt; Text Elements 1234&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;br&gt; (line break)&lt;hr&gt; (horizontal rule)&lt;pre&gt;This text is preformatted&lt;/pre&gt; Logical Styles 123&lt;em&gt;This text is emphasized&lt;/em&gt;&lt;strong&gt;This text is strong&lt;/strong&gt;&lt;code&gt;This is some computer code&lt;/code&gt; Physical Styles 12&lt;b&gt;This text is bold&lt;/b&gt;&lt;i&gt;This text is italic&lt;/i&gt; Links, Anchors, and Image Elements 12345&lt;a href=&quot;http://www.example.com/&quot;&gt;This is a Link&lt;/a&gt;&lt;a href=&quot;http://www.example.com/&quot;&gt;&lt;img src=&quot;URL&quot; alt=&quot;Alternate Text&quot;&gt;&lt;/a&gt;&lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;Send e-mail&lt;/a&gt;A named anchor:&lt;a name=&quot;tips&quot;&gt;Useful Tips Section&lt;/a&gt;&lt;a href=&quot;#tips&quot;&gt;Jump to the Useful Tips Section&lt;/a&gt; Unordered list 1234&lt;ul&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Next item&lt;/li&gt;&lt;/ul&gt; Ordered list 1234&lt;ol&gt;&lt;li&gt;First item&lt;/li&gt;&lt;li&gt;Next item&lt;/li&gt;&lt;/ol&gt; Definition list 123456&lt;dl&gt;&lt;dt&gt;First term&lt;/dt&gt;&lt;dd&gt;Definition&lt;/dd&gt;&lt;dt&gt;Next term&lt;/dt&gt;&lt;dd&gt;Definition&lt;/dd&gt;&lt;/dl&gt; Tables 12345678910&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;someheader&lt;/th&gt; &lt;th&gt;someheader&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;sometext&lt;/td&gt; &lt;td&gt;sometext&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; Frames 1234&lt;frameset cols=&quot;25%,75%&quot;&gt; &lt;frame src=&quot;page1.htm&quot;&gt; &lt;frame src=&quot;page2.htm&quot;&gt;&lt;/frameset&gt; Forms 1234567891011121314151617&lt;form action=&quot;http://www.example.com/test.asp&quot; method=&quot;post/get&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;lastname&quot;value=&quot;Nixon&quot; size=&quot;30&quot; maxlength=&quot;50&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;input type=&quot;reset&quot;&gt;&lt;input type=&quot;hidden&quot;&gt;&lt;select&gt;&lt;option&gt;Apples&lt;option selected&gt;Bananas&lt;option&gt;Cherries&lt;/select&gt;&lt;textarea name=&quot;Comment&quot; rows=&quot;60&quot;cols=&quot;20&quot;&gt;&lt;/textarea&gt;&lt;/form&gt; Entities 123&amp;lt; is the same as &lt;&amp;gt; is the same as &gt;&amp;#169; is the same as © Other Elements 123456789&lt;!-- This is a comment --&gt;&lt;blockquote&gt;Text quoted from some source.&lt;/blockquote&gt;&lt;address&gt;Address 1&lt;br&gt;Address 2&lt;br&gt;City&lt;br&gt;&lt;/address&gt;","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"}]},{"title":"yaml基础语法","slug":"yaml","date":"2021-03-29T12:45:54.000Z","updated":"2021-03-29T13:39:48.000Z","comments":true,"path":"2021/03/29/yaml/","link":"","permalink":"https://youngsay.cn/2021/03/29/yaml/","excerpt":"","text":"yaml简介 YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：“Yet Another Markup Language”（仍是一种标记语言）。yaml是能够被电脑识别的数据序列化格式。 基本语法 大小写敏感 使用缩进表示层级关系 缩进禁止用Tab，只允许用空格 空格数不重要，只要相同层级元素左对齐即可 用#表示注释 数据类型 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 对象 对象键值对用冒号表示，冒号后加一个空格 key: value，也可以使用key: &#123;key1: value1, key2: value2, ...&#125; 数组 以 - 开头的行表示构成一个数组： 123- A- B- C 多维数组的行内表示： 1key: [value1, value2, ...] 纯量 字符串 布尔值 整数 浮点数 Null 时间 日期 123456789101112131415161718192021boolean: - TRUE #true,True都可以 - FALSE #false，False都可以float: - 3.14 - 6.8523015e+5 #可以使用科学计数法int: - 123 - 0b1010_0111_0100_1010_1110 #二进制表示null: nodeName: &#x27;node&#x27; parent: ~ #使用~表示nullstring: - 哈哈 - &#x27;Hello world&#x27; #可以使用双引号或者单引号包裹特殊字符 - newline newline2 #字符串可以拆成多行，每一行会被转化成一个空格date: - 2018-02-17 #日期必须使用ISO 8601格式，即yyyy-MM-dddatetime: - 2018-02-17T15:02:31+08:00 #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 引用 &amp; 锚点和 * 别名，可以用来引用: 1234567891011defaults: &amp;defaults adapter: postgres host: localhostdevelopment: database: myapp_development &lt;&lt;: *defaultstest: database: myapp_test &lt;&lt;: *defaults 相当于 12345678910111213defaults: adapter: postgres host: localhostdevelopment: database: myapp_development adapter: postgres host: localhosttest: database: myapp_test adapter: postgres host: localhost 参考资料： YAML入门教程 yaml教程 YML简介 YAML语言教程","categories":[{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"yaml","slug":"yaml","permalink":"https://youngsay.cn/tags/yaml/"}]},{"title":"新学期，新博客，新开始！","slug":"go-school","date":"2021-03-29T05:58:37.000Z","updated":"2025-10-10T08:31:06.000Z","comments":true,"path":"2021/03/29/go-school/","link":"","permalink":"https://youngsay.cn/2021/03/29/go-school/","excerpt":"","text":"前言 新学期要开始了，把旧站关了，建个新站。本站用Hexo搭建，部署在github和vercel。 改用Hexo缘起幼稚园园长的博客，陷进去了（沈腾语气）。搭建博客出了些问题，感谢小茗同学的教程和小T同学的帮助。 博客内容 博客主要记录我的学习笔记、日常生活和想要分享的内容。 一直对编程感兴趣，尤其是前端。我想学的是计算机相关专业，憧憬的职业是程序员👨‍💻，无奈被调剂到了应用物理学。没关系，兴趣在，希望就在。我建该站的目的之一是记录自己的学习编程之路，所以博客的大部分内容是我的学习笔记。 时光稍纵即逝，记忆也会随时间冲淡。记录想要留存的记忆，1个月后，1年后，10年后回看，会有不同的感受。多年之后，我是否变成了自己讨厌的样子，曾经的豪言壮志是否都已实现，曾经的百思不解是否有的答案。年长的自己能够坐着时光机重识年轻的自己，这是件有趣的事。 万物皆有圈，生物圈、朋友圈、电竞圈……博客也有圈，博客圈的博主们遍布世界各地，从事各种领域，有着相同或不同的兴趣，认真地运营着自己的博客。世上的人遍地都是，说的着的千里难寻。浏览不同的博客，发现不同的世界，结交不同的朋友。 博客事件 2021.03.29 旧站关闭，新博客建成。起名“胖虎同学”，博客域名为blog.wangyouwu.cn。 2021.04.02 博客的第一条评论：来自琛苏设计 2021.04.18 博客的第一个友链：幼稚园园长","categories":[{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"}],"tags":[]}],"categories":[{"name":"分享","slug":"分享","permalink":"https://youngsay.cn/categories/%E5%88%86%E4%BA%AB/"},{"name":"感想","slug":"感想","permalink":"https://youngsay.cn/categories/%E6%84%9F%E6%83%B3/"},{"name":"学习","slug":"学习","permalink":"https://youngsay.cn/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/categories/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://youngsay.cn/tags/hexo/"},{"name":"年终总结","slug":"年终总结","permalink":"https://youngsay.cn/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"事务","slug":"事务","permalink":"https://youngsay.cn/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"MySQL","slug":"MySQL","permalink":"https://youngsay.cn/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://youngsay.cn/tags/%E7%B4%A2%E5%BC%95/"},{"name":"socket","slug":"socket","permalink":"https://youngsay.cn/tags/socket/"},{"name":"IO","slug":"IO","permalink":"https://youngsay.cn/tags/IO/"},{"name":"多线程","slug":"多线程","permalink":"https://youngsay.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://youngsay.cn/tags/JavaWeb/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://youngsay.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"JavaSE","slug":"JavaSE","permalink":"https://youngsay.cn/tags/JavaSE/"},{"name":"c","slug":"c","permalink":"https://youngsay.cn/tags/c/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://youngsay.cn/tags/Vue-js/"},{"name":"Python","slug":"Python","permalink":"https://youngsay.cn/tags/Python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://youngsay.cn/tags/JavaScript/"},{"name":"阅读","slug":"阅读","permalink":"https://youngsay.cn/tags/%E9%98%85%E8%AF%BB/"},{"name":"css","slug":"css","permalink":"https://youngsay.cn/tags/css/"},{"name":"linux","slug":"linux","permalink":"https://youngsay.cn/tags/linux/"},{"name":"html","slug":"html","permalink":"https://youngsay.cn/tags/html/"},{"name":"yaml","slug":"yaml","permalink":"https://youngsay.cn/tags/yaml/"}]}